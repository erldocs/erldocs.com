<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="latin1" />
    <title>crypto (crypto) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml"
          title="erldocs" href="/search.xml">
    <link type="text/css" rel="stylesheet" href="../erldocs.css" />
  </head>
  <body>

    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off"
             placeholder="press TAB to search" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>crypto</h1>
  <h2 class="modsummary">Crypto Functions</h2>
  <div class="description">
    <p>This module provides a set of cryptographic functions.
      </p>
    <p>References:</p>
    <list type="bulleted">
      <item>
        <p>md4: The MD4 Message Digest Algorithm (RFC 1320)</p>
      </item>
      <item>
        <p>md5: The MD5 Message Digest Algorithm (RFC 1321)</p>
      </item>
      <item>
        <p>sha: Secure Hash Standard (FIPS 180-2)</p>
      </item>
      <item>
        <p>hmac: Keyed-Hashing for Message Authentication (RFC 2104)</p>
      </item>
      <item>
        <p>des: Data Encryption Standard (FIPS 46-3)</p>
      </item>
      <item>
        <p>aes: Advanced Encryption Standard (AES) (FIPS 197) </p>
      </item>
      <item>
        <p>ecb, cbc, cfb, ofb, ctr: Recommendation for Block Cipher Modes
          of Operation (NIST SP 800-38A).</p>
      </item>
      <item>
        <p>rsa: Recommendation for Block Cipher Modes of Operation
          (NIST 800-38A)</p>
      </item>
      <item>
        <p>dss: Digital Signature Standard (FIPS 186-2)</p>
      </item>
    </list>
    <p>The above publications can be found at <url href="http://csrc.nist.gov/publications">NIST publications</url>, at <url href="http://www.ietf.org">IETF</url>.
      </p>
    <p><em>Types</em></p>
    <pre class="sh_erlang">
byte() = 0 ... 255
ioelem() = byte() | binary() | iolist()
iolist() = [ioelem()]
Mpint() = &lt;&lt;ByteLen:32/integer-big, Bytes:ByteLen/binary&gt;&gt;
    </pre>
    <p  />
  </div>
  <div class="functions"><h4>Functions</h4><hr  />
    <div class="function">
      <h3 id="start/0">start() -&gt; ok</h3>
      
      <div class="description">
        <p>Starts the crypto server.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="stop/0">stop() -&gt; ok</h3>
      
      <div class="description">
        <p>Stops the crypto server.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="info/0">info() -&gt; [atom()]</h3>
      
      <div class="description">
        <p>Provides the available crypto functions in terms of a list
          of atoms.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="info_lib/0">info_lib() -&gt; [{Name,VerNum,VerStr}]</h3>
      
      <ul class="type">
        <li><code>Name = binary()</code></li>
        <li><code>VerNum = integer()</code></li>
        <li><code>VerStr = binary()</code></li>
      </ul>
      <div class="description">
        <p>Provides the name and version of the libraries used by crypto.</p>
        <p><code>Name</code> is the name of the library. <code>VerNum</code> is
        the numeric version according to the library's own versioning
        scheme. <code>VerStr</code> contains a text variant of the version.</p>
        <pre class="sh_erlang">
&gt; <code>info_lib().</code>
[{&lt;&lt;"OpenSSL"&gt;&gt;,9469983,&lt;&lt;"OpenSSL 0.9.8a 11 Oct 2005"&gt;&gt;}]
        </pre>
      </div>
    </div>
    <div class="function">
      <h3 id="md4/1">md4(Data) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>MD4</code> message digest from <code>Data</code>, where
          the length of the digest is 128 bits (16 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md4_init/0">md4_init() -&gt; Context</h3>
      
      <ul class="type">
        <li><code>Context = binary()</code></li>
      </ul>
      <div class="description">
        <p>Creates an MD4 context, to be used in subsequent calls to
          <code>md4_update/2</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md4_update/2">md4_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Context = NewContext = binary()</code></li>
      </ul>
      <div class="description">
        <p>Updates an MD4 <code>Context</code> with <code>Data</code>, and returns
          a <code>NewContext</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md4_final/1">md4_final(Context) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Context = Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finishes the update of an MD4 <code>Context</code> and returns
          the computed <code>MD4</code> message digest.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5/1">md5(Data) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>MD5</code> message digest from <code>Data</code>, where
          the length of the digest is 128 bits (16 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5_init/0">md5_init() -&gt; Context</h3>
      
      <ul class="type">
        <li><code>Context = binary()</code></li>
      </ul>
      <div class="description">
        <p>Creates an MD5 context, to be used in subsequent calls to 
          <code>md5_update/2</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5_update/2">md5_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Context = NewContext = binary()</code></li>
      </ul>
      <div class="description">
        <p>Updates an MD5 <code>Context</code> with <code>Data</code>, and returns
          a <code>NewContext</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5_final/1">md5_final(Context) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Context = Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finishes the update of an MD5 <code>Context</code> and returns
          the computed <code>MD5</code> message digest.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha/1">sha(Data) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>SHA</code> message digest from <code>Data</code>, where
          the length of the digest is 160 bits (20 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha_init/0">sha_init() -&gt; Context</h3>
      
      <ul class="type">
        <li><code>Context = binary()</code></li>
      </ul>
      <div class="description">
        <p>Creates an SHA context, to be used in subsequent calls to 
          <code>sha_update/2</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha_update/2">sha_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>Context = NewContext = binary()</code></li>
      </ul>
      <div class="description">
        <p>Updates an SHA <code>Context</code> with <code>Data</code>, and returns
          a <code>NewContext</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha_final/1">sha_final(Context) -&gt; Digest</h3>
      
      <ul class="type">
        <li><code>Context = Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finishes the update of an SHA <code>Context</code> and returns
          the computed <code>SHA</code> message digest.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5_mac/2">md5_mac(Key, Data) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Key = Data = iolist() | binary()</code></li>
        <li><code>Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>MD5 MAC</code> message authentification code
          from <code>Key</code> and <code>Data</code>, where the the length of the
          Mac is 128 bits (16 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="md5_mac_96/2">md5_mac_96(Key, Data) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Key = Data = iolist() | binary()</code></li>
        <li><code>Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>MD5 MAC</code> message authentification code
          from <code>Key</code> and <code>Data</code>, where the length of the Mac
          is 96 bits (12 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="hmac_init/2">hmac_init(Type, Key) -&gt; Context</h3>
      
      <ul class="type">
        <li><code>Type = sha | md5 | ripemd160</code></li>
        <li><code>Key = iolist() | binary()</code></li>
        <li><code>Context = binary()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the context for streaming HMAC operations. <code>Type</code> determines
        which hash function to use in the HMAC operation. <code>Key</code> is the authentication
        key. The key can be any length.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="hmac_update/2">hmac_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
        <li><code>Context = NewContext = binary()</code></li>
        <li><code>Data = iolist() | binary()</code></li>
      </ul>
      <div class="description">
        <p>Updates the HMAC represented by <code>Context</code> using the given <code>Data</code>. <code>Context</code>
        must have been generated using an HMAC init function (such as 
        <a href="#hmac_init/2" class="seealso">hmac_init</a>). <code>Data</code> can be any length. <code>NewContext</code>
        must be passed into the next call to <code>hmac_update</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="hmac_final/1">hmac_final(Context) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Context = Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finalizes the HMAC operation referenced by <code>Context</code>. The size of the resultant MAC is
        determined by the type of hash function used to generate it.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="hmac_final_n/2">hmac_final_n(Context, HashLen) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Context = Mac = binary()</code></li>
        <li><code>HashLen = non_neg_integer()</code></li>
      </ul>
      <div class="description">
        <p>Finalizes the HMAC operation referenced by <code>Context</code>. <code>HashLen</code> must be greater than
        zero. <code>Mac</code> will be a binary with at most <code>HashLen</code> bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than <code>HashLen</code> bytes.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha_mac/2">sha_mac(Key, Data) -&gt; Mac</h3>
      <h3 id="sha_mac/3">sha_mac(Key, Data, MacLength) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Key = Data = iolist() | binary()</code></li>
        <li><code>Mac = binary()</code></li>
	<li><code>MacLenength = integer() =&lt; 20 </code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>SHA MAC</code> message authentification code
          from <code>Key</code> and <code>Data</code>, where the default length of the Mac
          is 160 bits (20 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="sha_mac_96/2">sha_mac_96(Key, Data) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Key = Data = iolist() | binary()</code></li>
        <li><code>Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes an <code>SHA MAC</code> message authentification code
          from <code>Key</code> and <code>Data</code>, where the length of the Mac
          is 96 bits (12 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cbc_encrypt/3">des_cbc_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to DES in CBC
          mode. <code>Text</code> must be a multiple of 64 bits (8
          bytes). <code>Key</code> is the DES key, and <code>IVec</code> is an
          arbitrary initializing vector. The lengths of <code>Key</code> and
          <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cbc_decrypt/3">des_cbc_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to DES in CBC mode.
          <code>Key</code> is the DES key, and <code>IVec</code> is an arbitrary
          initializing vector.  <code>Key</code> and <code>IVec</code> must have
          the same values as those used when encrypting. <code>Cipher</code>
          must be a multiple of 64 bits (8 bytes).  The lengths of
          <code>Key</code> and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cbc_ivec/1">des_cbc_ivec(Data) -&gt; IVec</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>IVec = binary()</code></li>
      </ul>
      <div class="description">
        <p>Returns the <code>IVec</code> to be used in a next iteration of 
          <code>des_cbc_[encrypt|decrypt]</code>. <code>Data</code> is the encrypted
          data from the previous iteration step.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cfb_encrypt/3">des_cfb_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to DES in 8-bit CFB
          mode. <code>Key</code> is the DES key, and <code>IVec</code> is an
          arbitrary initializing vector. The lengths of <code>Key</code> and
          <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cfb_decrypt/3">des_cfb_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to DES in 8-bit CFB mode.
          <code>Key</code> is the DES key, and <code>IVec</code> is an arbitrary
          initializing vector.  <code>Key</code> and <code>IVec</code> must have
          the same values as those used when encrypting.  The lengths of
          <code>Key</code> and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_cfb_ivec/2">des_cfb_ivec(IVec, Data) -&gt; NextIVec</h3>
      
      <ul class="type">
        <li><code>IVec = iolist() | binary()</code></li>
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>NextIVec = binary()</code></li>
      </ul>
      <div class="description">
        <p>Returns the <code>IVec</code> to be used in a next iteration of
          <code>des_cfb_[encrypt|decrypt]</code>. <code>IVec</code> is the vector
          used in the previous iteration step. <code>Data</code> is the encrypted
          data from the previous iteration step.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des3_cbc_encrypt/5">des3_cbc_encrypt(Key1, Key2, Key3, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key1 =Key2 = Key3 Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to DES3 in CBC
          mode. <code>Text</code> must be a multiple of 64 bits (8
          bytes). <code>Key1</code>, <code>Key2</code>, <code>Key3</code>, are the DES
          keys, and <code>IVec</code> is an arbitrary initializing
          vector. The lengths of each of <code>Key1</code>, <code>Key2</code>,
          <code>Key3</code> and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des3_cbc_decrypt/5">des3_cbc_decrypt(Key1, Key2, Key3, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key1 = Key2 = Key3 = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to DES3 in CBC mode.
          <code>Key1</code>, <code>Key2</code>, <code>Key3</code> are the DES key, and
          <code>IVec</code> is an arbitrary initializing vector.
          <code>Key1</code>, <code>Key2</code>, <code>Key3</code> and <code>IVec</code> must
          and <code>IVec</code> must have the same values as those used when
          encrypting. <code>Cipher</code> must be a multiple of 64 bits (8
          bytes).  The lengths of <code>Key1</code>, <code>Key2</code>,
          <code>Key3</code>, and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des3_cfb_encrypt/5">des3_cfb_encrypt(Key1, Key2, Key3, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key1 =Key2 = Key3 Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to DES3 in 8-bit CFB
          mode. <code>Key1</code>, <code>Key2</code>, <code>Key3</code>, are the DES
          keys, and <code>IVec</code> is an arbitrary initializing
          vector. The lengths of each of <code>Key1</code>, <code>Key2</code>,
          <code>Key3</code> and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des3_cfb_decrypt/5">des3_cfb_decrypt(Key1, Key2, Key3, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key1 = Key2 = Key3 = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to DES3 in 8-bit CFB mode.
          <code>Key1</code>, <code>Key2</code>, <code>Key3</code> are the DES key, and
          <code>IVec</code> is an arbitrary initializing vector.
          <code>Key1</code>, <code>Key2</code>, <code>Key3</code> and <code>IVec</code> must
          and <code>IVec</code> must have the same values as those used when
          encrypting.  The lengths of <code>Key1</code>, <code>Key2</code>,
          <code>Key3</code>, and <code>IVec</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="des_ecb_encrypt/2">des_ecb_encrypt(Key, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to DES in ECB mode.
          <code>Key</code> is the DES key. The lengths of <code>Key</code> and
          <code>Text</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="des_ecb_decrypt/2">des_ecb_decrypt(Key, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Cipher = iolist() | binary()</code></li>
        <li><code>Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to DES in ECB mode.
          <code>Key</code> is the DES key. The lengths of <code>Key</code> and
          <code>Cipher</code> must be 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="blowfish_ecb_encrypt/2">blowfish_ecb_encrypt(Key, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts the first 64 bits of <code>Text</code> using Blowfish in ECB mode. <code>Key</code> is the Blowfish key. The length of <code>Text</code> must be at least 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="blowfish_ecb_decrypt/2">blowfish_ecb_decrypt(Key, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts the first 64 bits of <code>Text</code> using Blowfish in ECB mode. <code>Key</code> is the Blowfish key. The length of <code>Text</code> must be at least 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="blowfish_cbc_encrypt/3">blowfish_cbc_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> using Blowfish in CBC mode. <code>Key</code> is the Blowfish key, and <code>IVec</code> is an
          arbitrary initializing vector. The length of <code>IVec</code>
          must be 64 bits (8 bytes). The length of <code>Text</code> must be a multiple of 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="blowfish_cbc_decrypt/3">blowfish_cbc_decrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Text</code> using Blowfish in CBC mode. <code>Key</code> is the Blowfish key, and <code>IVec</code> is an
          arbitrary initializing vector. The length of <code>IVec</code>
          must be 64 bits (8 bytes). The length of <code>Text</code> must be a multiple 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="blowfish_cfb64_encrypt/3">blowfish_cfb64_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> using Blowfish in CFB mode with 64 bit
          feedback. <code>Key</code> is the Blowfish key, and <code>IVec</code> is an
          arbitrary initializing vector. The length of <code>IVec</code>
          must be 64 bits (8 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="blowfish_cfb64_decrypt/3">blowfish_cfb64_decrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Text</code> using Blowfish in CFB mode with 64 bit
          feedback. <code>Key</code> is the Blowfish key, and <code>IVec</code> is an
          arbitrary initializing vector. The length of <code>IVec</code>
          must be 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="blowfish_ofb64_encrypt/3">blowfish_ofb64_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> using Blowfish in OFB mode with 64 bit
          feedback. <code>Key</code> is the Blowfish key, and <code>IVec</code> is an
          arbitrary initializing vector. The length of <code>IVec</code>
          must be 64 bits (8 bytes).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="aes_cfb_128_encrypt/3">aes_cfb_128_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      <h3 id="aes_cbc_128_encrypt/3">aes_cbc_128_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to AES in Cipher Feedback 
          mode (CFB) or Cipher Block Chaining mode (CBC). <code>Text</code>
          must be a multiple of 128 bits (16 bytes). <code>Key</code> is the
          AES key, and <code>IVec</code> is an arbitrary initializing vector.
          The lengths of <code>Key</code> and <code>IVec</code> must be 128 bits
          (16 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="aes_cfb_128_decrypt/3">aes_cfb_128_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      <h3 id="aes_cbc_128_decrypt/3">aes_cbc_128_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to Cipher Feedback Mode (CFB)
          or Cipher Block Chaining mode (CBC).
          <code>Key</code> is the AES key, and <code>IVec</code> is an arbitrary
          initializing vector. <code>Key</code> and <code>IVec</code> must have
          the same values as those used when encrypting. <code>Cipher</code>
          must be a multiple of 128 bits (16 bytes).  The lengths of
          <code>Key</code> and <code>IVec</code> must be 128 bits (16 bytes).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="aes_cbc_ivec/1">aes_cbc_ivec(Data) -&gt; IVec</h3>
      
      <ul class="type">
        <li><code>Data = iolist() | binary()</code></li>
        <li><code>IVec = binary()</code></li>
      </ul>
      <div class="description">
        <p>Returns the <code>IVec</code> to be used in a next iteration of 
          <code>aes_cbc_*_[encrypt|decrypt]</code>. <code>Data</code> is the encrypted
          data from the previous iteration step.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="aes_ctr_encrypt/3">aes_ctr_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>IVec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
      <p>Encrypts <code>Text</code> according to AES in Counter mode (CTR). <code>Text</code>
        can be any number of bytes. <code>Key</code> is the AES key and must be either
        128, 192 or 256 bits long. <code>IVec</code> is an arbitrary initializing vector of 128 bits
        (16 bytes).</p>
    </div>
    </div>
    <div class="function">
      <h3 id="aes_ctr_decrypt/3">aes_ctr_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Cipher = iolist() | binary()</code></li>
        <li><code>IVec = Text = binary()</code></li>
      </ul>
      <div class="description">
      <p>Decrypts <code>Cipher</code> according to AES in Counter mode (CTR). <code>Cipher</code>
        can be any number of bytes. <code>Key</code> is the AES key and must be either
        128, 192 or 256 bits long. <code>IVec</code> is an arbitrary initializing vector of 128 bits
        (16 bytes).</p>
    </div>
    </div>
    <div class="function">
      <h3 id="aes_ctr_stream_init/2">aes_ctr_stream_init(Key, IVec) -&gt; State</h3>
      
      <ul class="type">
        <li><code>State = { K, I, E, C }</code></li>
        <li><code>Key = K = iolist()</code></li>
        <li><code>IVec = I = E = binary()</code></li>
        <li><code>C = integer()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the state for use in streaming AES encryption using Counter mode (CTR).
        <code>Key</code> is the AES key and must be either 128, 192, or 256 bts long. <code>IVec</code> is
        an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with
        <a href="#aes_ctr_stream_encrypt/2" class="seealso">aes_ctr_stream_encrypt</a> and 
        <a href="#aes_ctr_stream_decrypt/2" class="seealso">aes_ctr_stream_decrypt</a>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="aes_ctr_stream_encrypt/2">aes_ctr_stream_encrypt(State, Text) -&gt; { NewState, Cipher}</h3>
      
      <ul class="type">
        <li><code>Text = iolist() | binary()</code></li>
        <li><code>Cipher = binary()</code></li>
      </ul>
      <div class="description">
      <p>Encrypts <code>Text</code> according to AES in Counter mode (CTR).  This function can be
        used to encrypt a stream of text using a series of calls instead of requiring all
        text to be in memory. <code>Text</code> can be any number of bytes. State is initialized using 
        <a href="#aes_ctr_stream_init/2" class="seealso">aes_ctr_stream_init</a>. <code>NewState</code> is the new streaming
        encryption state that must be passed to the next call to <code>aes_ctr_stream_encrypt</code>.
        <code>Cipher</code> is the encrypted cipher text.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="aes_ctr_stream_decrypt/2">aes_ctr_stream_decrypt(State, Cipher) -&gt; { NewState, Text }</h3>
      
      <ul class="type">
        <li><code>Cipher = iolist() | binary()</code></li>
        <li><code>Text = binary()</code></li>
      </ul>
      <div class="description">
      <p>Decrypts <code>Cipher</code> according to AES in Counter mode (CTR). This function can be
        used to decrypt a stream of ciphertext using a series of calls instead of requiring all
        ciphertext to be in memory.  <code>Cipher</code> can be any number of bytes. State is initialized using 
        <a href="#aes_ctr_stream_init/2" class="seealso">aes_ctr_stream_init</a>. <code>NewState</code> is the new streaming
        encryption state that must be passed to the next call to <code>aes_ctr_stream_encrypt</code>.
        <code>Text</code> is the decrypted data.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="erlint/1">erlint(Mpint) -&gt; N</h3>
      <h3 id="mpint/1">mpint(N) -&gt; Mpint</h3>
      
      <ul class="type">
        <li><code>Mpint = binary()</code></li>
        <li><code>N = integer()</code></li>
      </ul>
      <div class="description">
        <p>Convert a binary multi-precision integer <code>Mpint</code> to and from
          an erlang big integer. A multi-precision integer is a binary
          with the following form:
          <code>&lt;&lt;ByteLen:32/integer, Bytes:ByteLen/binary&gt;&gt;</code> where both
          <code>ByteLen</code> and <code>Bytes</code> are big-endian. Mpints are used in
          some of the functions in <code>crypto</code> and are not translated
          in the API for performance reasons.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="rand_bytes/1">rand_bytes(N) -&gt; binary()</h3>
      
      <ul class="type">
        <li><code>N = integer()</code></li>
      </ul>
      <div class="description">
        <p>Generates N bytes randomly uniform 0..255, and returns the
          result in a binary. Uses the <code>crypto</code> library pseudo-random
          number generator.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="strong_rand_bytes/1">strong_rand_bytes(N) -&gt; binary()</h3>
      
      <ul class="type">
        <li><code>N = integer()</code></li>
      </ul>
      <div class="description">
        <p>Generates N bytes randomly uniform 0..255, and returns the
        result in a binary. Uses a cryptographically secure prng seeded and
        periodically mixed with operating system provided entropy. By default
        this is the <code>RAND_bytes</code> method from OpenSSL.</p>
	<p>May throw exception <code>low_entropy</code> in case the random generator
	failed due to lack of secure "randomness".</p>
      </div>
    </div>
    <div class="function">
      <h3 id="rand_uniform/2">rand_uniform(Lo, Hi) -&gt; N</h3>
      
      <ul class="type">
        <li><code>Lo, Hi, N = Mpint | integer()</code></li>
        <li><code>Mpint = binary()</code></li>
      </ul>
      <div class="description">
        <p>Generate a random number <code>N, Lo =&lt; N &lt; Hi.</code> Uses the
          <code>crypto</code> library pseudo-random number generator. The
          arguments (and result) can be either erlang integers or binary
          multi-precision integers. <code>Hi</code> must be larger than <code>Lo</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="strong_rand_mpint/3">strong_rand_mpint(N, Top, Bottom) -&gt; Mpint</h3>
      
      <ul class="type">
        <li><code>N = non_neg_integer()</code></li>
        <li><code>Top = -1 | 0 | 1</code></li>
        <li><code>Bottom = 0 | 1</code></li>
        <li><code>Mpint = binary()</code></li>
      </ul>
      <div class="description">
        <p>Generate an N bit random number using OpenSSL's
        cryptographically strong pseudo random number generator
        <code>BN_rand</code>.</p>
        <p>The parameter <code>Top</code> places constraints on the most
        significant bits of the generated number. If <code>Top</code> is 1, then the
        two most significant bits will be set to 1, if <code>Top</code> is 0, the
        most significant bit will be 1, and if <code>Top</code> is -1 then no
        constraints are applied and thus the generated number may be less than
        N bits long.</p>
        <p>If <code>Bottom</code> is 1, then the generated number is
        constrained to be odd.</p>
	<p>May throw exception <code>low_entropy</code> in case the random generator
	failed due to lack of secure "randomness".</p>
      </div>
    </div>
    <div class="function">
      <h3 id="mod_exp/3">mod_exp(N, P, M) -&gt; Result</h3>
      
      <ul class="type">
        <li><code>N, P, M, Result = Mpint</code></li>
        <li><code>Mpint = binary()</code></li>
      </ul>
      <div class="description">
        <p>This function performs the exponentiation <code>N ^ P mod M</code>,
          using the <code>crypto</code> library.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rsa_sign/2">rsa_sign(Data, Key) -&gt; Signature</h3>
      <h3 id="rsa_sign/3">rsa_sign(DigestType, Data, Key) -&gt; Signature</h3> 
      
      <ul class="type">
        <li><code>Data = Mpint</code></li>
        <li><code>Key = [E, N, D]</code></li>
        <li><code>E, N, D = Mpint</code></li>
        <d>Where <code>E</code> is the public exponent, <code>N</code> is public modulus and 
	  <code>D</code> is the private exponent.</d>
	<li><code>DigestType = md5 | sha</code></li>
	<d>The default <code>DigestType</code> is sha.</d>
        <li><code>Mpint = binary()</code></li>
        <li><code>Signature = binary()</code></li>
      </ul>
      <div class="description">
        <p>Calculates a <code>DigestType</code> digest of the <code>Data</code>
	  and creates a RSA signature with the private key <code>Key</code>
	  of the digest.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rsa_verify/3">rsa_verify(Data, Signature, Key) -&gt; Verified</h3>
      <h3 id="rsa_verify/4">rsa_verify(DigestType, Data, Signature, Key) -&gt; Verified </h3> 
      
      <ul class="type">
        <li><code>Verified = boolean()</code></li>
        <li><code>Data, Signature = Mpint</code></li>
        <li><code>Key = [E, N]</code></li>
        <li><code>E, N = Mpint</code></li>
        <d>Where <code>E</code> is the public exponent and <code>N</code> is public modulus.</d>
	<li><code>DigestType = md5 | sha | sha256 | sha384 | sha512</code></li>
	<d> The default <code>DigestType</code> is sha.</d>
        <li><code>Mpint = binary()</code></li>
      </ul>
      <div class="description">
        <p>Calculates a <code>DigestType</code> digest of the <code>Data</code>
          and verifies that the digest matches the RSA signature using the
          signer's public key <code>Key</code>.
	</p>
	<p>May throw exception <code>notsup</code> in case the chosen <code>DigestType</code>
	is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>
    
    <div class="function">
      <h3 id="rsa_public_encrypt/3">rsa_public_encrypt(PlainText, PublicKey, Padding) -&gt; ChipherText</h3> 
      
      <ul class="type">
	<li><code>PlainText = binary()</code></li>
	<li><code>PublicKey = [E, N]</code></li>
	<li><code>E, N = Mpint</code></li>	
	<d>Where <code>E</code> is the public exponent and <code>N</code> is public modulus.</d>
	<li><code>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</code></li>
        <li><code>ChipherText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts the <code>PlainText</code> (usually a session key) using the <code>PublicKey</code>
	  and returns the cipher. The <code>Padding</code> decides what padding mode is used,
	  <code>rsa_pkcs1_padding</code> is PKCS #1 v1.5 currently the most
	  used mode and <code>rsa_pkcs1_oaep_padding</code> is EME-OAEP as
	  defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding
	  parameter. This mode is recommended for all new applications.
	  The size of the <code>Msg</code> must be less
	  than <code>byte_size(N)-11</code> if
	  <code>rsa_pkcs1_padding</code> is used, <code>byte_size(N)-41</code> if 
	  <code>rsa_pkcs1_oaep_padding</code> is used and <code>byte_size(N)</code> if <code>rsa_no_padding</code> 
	  is used.
	  Where byte_size(N) is the size part of an <code>Mpint-1</code>.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rsa_private_decrypt/3">rsa_private_decrypt(ChipherText, PrivateKey, Padding) -&gt; PlainText</h3> 
      
      <ul class="type">
	<li><code>ChipherText = binary()</code></li>
	<li><code>PrivateKey = [E, N, D]</code></li>
	<li><code>E, N, D = Mpint</code></li>
	<d>Where <code>E</code> is the public exponent, <code>N</code> is public modulus  and 
	  <code>D</code> is the private exponent.</d>
	<li><code>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</code></li>
        <li><code>PlainText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Decrypts the <code>ChipherText</code> (usually a session key encrypted with 
	  <a href="#rsa_public_encrypt/3" class="seealso">rsa_public_encrypt/3</a>) 
	  using the <code>PrivateKey</code> and returns the
	  message. The <code>Padding</code> is the padding mode that was
	  used to encrypt the data, 
	  see <a href="#rsa_public_encrypt/3" class="seealso">rsa_public_encrypt/3</a>.
	</p>
      </div>
    </div>
    <div class="function">
      <h3 id="rsa_private_encrypt/3">rsa_private_encrypt(PlainText, PrivateKey, Padding) -&gt; ChipherText</h3> 
      
      <ul class="type">
	<li><code>PlainText = binary()</code></li>
	<li><code>PrivateKey = [E, N, D]</code></li>
	<li><code>E, N, D = Mpint</code></li>	
	<d>Where <code>E</code> is the public exponent, <code>N</code> is public modulus and 
	  <code>D</code> is the private exponent.</d>
	<li><code>Padding = rsa_pkcs1_padding | rsa_no_padding</code></li>
        <li><code>ChipherText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts the <code>PlainText</code> using the <code>PrivateKey</code>
	  and returns the cipher. The <code>Padding</code> decides what padding mode is used,
	  <code>rsa_pkcs1_padding</code> is PKCS #1 v1.5 currently the most
	  used mode.
	  The size of the <code>Msg</code> must be less than <code>byte_size(N)-11</code> if
	  <code>rsa_pkcs1_padding</code> is used, and <code>byte_size(N)</code> if <code>rsa_no_padding</code> 
	  is used.  Where byte_size(N) is the size part of an <code>Mpint-1</code>.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rsa_public_decrypt/3">rsa_public_decrypt(ChipherText, PublicKey, Padding) -&gt; PlainText</h3> 
      
      <ul class="type">
	<li><code>ChipherText = binary()</code></li>
	<li><code>PublicKey = [E, N]</code></li>
	<li><code>E, N = Mpint</code></li>
	<d>Where <code>E</code> is the public exponent and <code>N</code> is public modulus</d>
	<li><code>Padding = rsa_pkcs1_padding | rsa_no_padding</code></li>
        <li><code>PlainText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Decrypts the <code>ChipherText</code> (encrypted with 
	  <a href="#rsa_private_encrypt/3" class="seealso">rsa_private_encrypt/3</a>) 
	  using the <code>PrivateKey</code> and returns the
	  message. The <code>Padding</code> is the padding mode that was
	  used to encrypt the data, 
	  see <a href="#rsa_private_encrypt/3" class="seealso">rsa_private_encrypt/3</a>.
	</p>
      </div>
    </div>
      
    <div class="function">
      <h3 id="dss_sign/2">dss_sign(Data, Key) -&gt; Signature</h3>
      <h3 id="dss_sign/3">dss_sign(DigestType, Data, Key) -&gt; Signature</h3>
      
      <ul class="type">
        <li><code>DigestType = sha | none (default is sha)</code></li>
        <li><code>Data = Mpint | ShaDigest</code></li>
        <li><code>Key = [P, Q, G, X]</code></li>
        <li><code>P, Q, G, X = Mpint</code></li>
	<d> Where <code>P</code>, <code>Q</code> and <code>G</code> are the dss
	  parameters and <code>X</code> is the private key.</d>
        <li><code>ShaDigest = binary() with length 20 bytes</code></li>
        <li><code>Signature = binary()</code></li>
      </ul>
      <div class="description">
        <p>Creates a DSS signature with the private key <code>Key</code> of a digest.
        If <code>DigestType</code> is 'sha', the digest is calculated as SHA1 of <code>Data</code>.
        If <code>DigestType</code> is 'none', <code>Data</code> is the precalculated SHA1 digest.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="dss_verify/3">dss_verify(Data, Signature, Key) -&gt; Verified</h3>
      <h3 id="dss_verify/4">dss_verify(DigestType, Data, Signature, Key) -&gt; Verified</h3>
      
      <ul class="type">
        <li><code>Verified = boolean()</code></li>
        <li><code>DigestType = sha | none</code></li>
        <li><code>Data = Mpint | ShaDigest</code></li>
        <li><code>Signature = Mpint</code></li>
        <li><code>Key = [P, Q, G, Y]</code></li>
        <li><code>P, Q, G, Y = Mpint</code></li>
	<d> Where <code>P</code>, <code>Q</code> and <code>G</code> are the dss
	  parameters and <code>Y</code> is the public key.</d>
        <li><code>ShaDigest = binary() with length 20 bytes</code></li>
      </ul>
      <div class="description">
        <p>Verifies that a digest matches the DSS signature using the public key <code>Key</code>.
        If <code>DigestType</code> is 'sha', the digest is calculated as SHA1 of <code>Data</code>.
        If <code>DigestType</code> is 'none', <code>Data</code> is the precalculated SHA1 digest.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rc2_cbc_encrypt/3">rc2_cbc_encrypt(Key, IVec, Text) -&gt; Cipher</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>Ivec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Encrypts <code>Text</code> according to RC2 in CBC mode.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rc2_cbc_decrypt/3">rc2_cbc_decrypt(Key, IVec, Cipher) -&gt; Text</h3>
      
      <ul class="type">
        <li><code>Key = Text = iolist() | binary()</code></li>
        <li><code>Ivec = Cipher = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypts <code>Cipher</code> according to RC2 in CBC mode.</p>
      </div>
    </div>
    
    <div class="function">
      <h3 id="rc4_encrypt/2">rc4_encrypt(Key, Data) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Key, Data = iolist() | binary()</code></li>
	<li><code>Result = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts the data with RC4 symmetric stream encryption.
	  Since it is symmetric, the same function is used for
	  decryption.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="dh_generate_key/1">dh_generate_key(DHParams) -&gt; {PublicKey,PrivateKey} </h3>
      <h3 id="dh_generate_key/2">dh_generate_key(PrivateKey, DHParams) -&gt; {PublicKey,PrivateKey} </h3>
      
      <ul class="type">
	<li><code>DHParameters = [P, G]</code></li>
	<li><code>P, G = Mpint</code></li>
	<d> Where <code>P</code> is the shared prime number and <code>G</code> is the shared generator.</d>
	<li><code>PublicKey, PrivateKey = Mpint()</code></li>
      </ul>
      <div class="description">
	<p>Generates a Diffie-Hellman <code>PublicKey</code> and <code>PrivateKey</code> (if not given).
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="dh_compute_key/3">dh_compute_key(OthersPublicKey, MyPrivateKey, DHParams) -&gt; SharedSecret</h3>
      
      <ul class="type">
	<li><code>DHParameters = [P, G]</code></li>
	<li><code>P, G = Mpint</code></li>
	<d> Where <code>P</code> is the shared prime number and <code>G</code> is the shared generator.</d>
	<li><code>OthersPublicKey, MyPrivateKey = Mpint()</code></li>
	<li><code>SharedSecret = binary()</code></li>
      </ul>
      <div class="description">
	<p>Computes the shared secret from the private key and the other party's public key.
	</p>
      </div>
    </div>
   

    <div class="function">
      <h3 id="exor/2">exor(Data1, Data2) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Data1, Data2 = iolist() | binary()</code></li>
	<li><code>Result = binary()</code></li>
      </ul>
      <div class="description">
	<p>Performs bit-wise XOR (exclusive or) on the data supplied.</p>
      </div>
    </div>
  </div>

  <div class="section">
    <h4>DES in CBC mode</h4>
    <p>The Data Encryption Standard (DES) defines an algorithm for
      encrypting and decrypting an 8 byte quantity using an 8 byte key
      (actually only 56 bits of the key is used).
      </p>
    <p>When it comes to encrypting and decrypting blocks that are
      multiples of 8 bytes various modes are defined (NIST SP
      800-38A). One of those modes is the Cipher Block Chaining (CBC)
      mode, where the encryption of an 8 byte segment depend not only
      of the contents of the segment itself, but also on the result of
      encrypting the previous segment: the encryption of the previous
      segment becomes the initializing vector of the encryption of the
      current segment.
      </p>
    <p>Thus the encryption of every segment depends on the encryption
      key (which is secret) and the encryption of the previous
      segment, except the first segment which has to be provided with
      an initial initializing vector. That vector could be chosen at
      random, or be a counter of some kind. It does not have to be
      secret.
      </p>
    <p>The following example is drawn from the old FIPS 81 standard
      (replaced by NIST SP 800-38A), where both the plain text and the
      resulting cipher text is settled. The following code fragment
      returns `true'.
      </p>
    <pre class="sh_erlang">

      Key = &lt;&lt;16#01,16#23,16#45,16#67,16#89,16#ab,16#cd,16#ef&gt;&gt;,
      IVec = &lt;&lt;16#12,16#34,16#56,16#78,16#90,16#ab,16#cd,16#ef&gt;&gt;,
      P = "Now is the time for all ",
      C = crypto:des_cbc_encrypt(Key, IVec, P),
         % Which is the same as 
      P1 = "Now is t", P2 = "he time ", P3 = "for all ",
      C1 = crypto:des_cbc_encrypt(Key, IVec, P1),
      C2 = crypto:des_cbc_encrypt(Key, C1, P2),
      C3 = crypto:des_cbc_encrypt(Key, C2, P3),

      C = &lt;&lt;C1/binary, C2/binary, C3/binary&gt;&gt;,
      C = &lt;&lt;16#e5,16#c7,16#cd,16#de,16#87,16#2b,16#f2,16#7c,
             16#43,16#e9,16#34,16#00,16#8c,16#38,16#9c,16#0f,
             16#68,16#37,16#88,16#49,16#9a,16#7c,16#05,16#f6&gt;&gt;,
      &lt;&lt;"Now is the time for all "&gt;&gt; == 
                        crypto:des_cbc_decrypt(Key, IVec, C).
    </pre>
    <p>The following is true for the DES CBC mode. For all
      decompositions <code>P1 ++ P2 = P</code> of a plain text message
      <code>P</code> (where the length of all quantities are multiples of 8
      bytes), the encryption <code>C</code> of <code>P</code> is equal to <code>C1 ++
      C2</code>, where <code>C1</code> is obtained by encrypting <code>P1</code> with
      <code>Key</code> and the initializing vector <code>IVec</code>, and where
      <code>C2</code> is obtained by encrypting <code>P2</code> with <code>Key</code>
      and the initializing vector <code>last8(C1)</code>,
      where <code>last(Binary)</code> denotes the last 8 bytes of the
      binary <code>Binary</code>.
      </p>
    <p>Similarly, for all decompositions <code>C1 ++ C2 = C</code> of a
      cipher text message <code>C</code> (where the length of all quantities
      are multiples of 8 bytes), the decryption <code>P</code> of <code>C</code>
      is equal to <code>P1 ++ P2</code>, where <code>P1</code> is obtained by
      decrypting <code>C1</code> with <code>Key</code> and the initializing vector
      <code>IVec</code>, and where <code>P2</code> is obtained by decrypting
      <code>C2</code> with <code>Key</code> and the initializing vector
      <code>last8(C1)</code>, where <code>last8(Binary)</code> is as above.
      </p>
    <p>For DES3 (which uses three 64 bit keys) the situation is the
      same.
    </p>
  </div>

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        <ul id="funs"><li><a href="#start/0">start/0</a></li><li><a href="#stop/0">stop/0</a></li><li><a href="#info/0">info/0</a></li><li><a href="#info_lib/0">info_lib/0</a></li><li><a href="#md4/1">md4/1</a></li><li><a href="#md4_init/0">md4_init/0</a></li><li><a href="#md4_update/2">md4_update/2</a></li><li><a href="#md4_final/1">md4_final/1</a></li><li><a href="#md5/1">md5/1</a></li><li><a href="#md5_init/0">md5_init/0</a></li><li><a href="#md5_update/2">md5_update/2</a></li><li><a href="#md5_final/1">md5_final/1</a></li><li><a href="#sha/1">sha/1</a></li><li><a href="#sha_init/0">sha_init/0</a></li><li><a href="#sha_update/2">sha_update/2</a></li><li><a href="#sha_final/1">sha_final/1</a></li><li><a href="#md5_mac/2">md5_mac/2</a></li><li><a href="#md5_mac_96/2">md5_mac_96/2</a></li><li><a href="#hmac_init/2">hmac_init/2</a></li><li><a href="#hmac_update/2">hmac_update/2</a></li><li><a href="#hmac_final/1">hmac_final/1</a></li><li><a href="#hmac_final_n/2">hmac_final_n/2</a></li><li><a href="#sha_mac/2">sha_mac/2</a></li><li><a href="#sha_mac/3">sha_mac/3</a></li><li><a href="#sha_mac_96/2">sha_mac_96/2</a></li><li><a href="#des_cbc_encrypt/3">des_cbc_encrypt/3</a></li><li><a href="#des_cbc_decrypt/3">des_cbc_decrypt/3</a></li><li><a href="#des_cbc_ivec/1">des_cbc_ivec/1</a></li><li><a href="#des_cfb_encrypt/3">des_cfb_encrypt/3</a></li><li><a href="#des_cfb_decrypt/3">des_cfb_decrypt/3</a></li><li><a href="#des_cfb_ivec/2">des_cfb_ivec/2</a></li><li><a href="#des3_cbc_encrypt/5">des3_cbc_encrypt/5</a></li><li><a href="#des3_cbc_decrypt/5">des3_cbc_decrypt/5</a></li><li><a href="#des3_cfb_encrypt/5">des3_cfb_encrypt/5</a></li><li><a href="#des3_cfb_decrypt/5">des3_cfb_decrypt/5</a></li><li><a href="#des_ecb_encrypt/2">des_ecb_encrypt/2</a></li><li><a href="#des_ecb_decrypt/2">des_ecb_decrypt/2</a></li><li><a href="#blowfish_ecb_encrypt/2">blowfish_ecb_encrypt/2</a></li><li><a href="#blowfish_ecb_decrypt/2">blowfish_ecb_decrypt/2</a></li><li><a href="#blowfish_cbc_encrypt/3">blowfish_cbc_encrypt/3</a></li><li><a href="#blowfish_cbc_decrypt/3">blowfish_cbc_decrypt/3</a></li><li><a href="#blowfish_cfb64_encrypt/3">blowfish_cfb64_encrypt/3</a></li><li><a href="#blowfish_cfb64_decrypt/3">blowfish_cfb64_decrypt/3</a></li><li><a href="#blowfish_ofb64_encrypt/3">blowfish_ofb64_encrypt/3</a></li><li><a href="#aes_cfb_128_encrypt/3">aes_cfb_128_encrypt/3</a></li><li><a href="#aes_cbc_128_encrypt/3">aes_cbc_128_encrypt/3</a></li><li><a href="#aes_cfb_128_decrypt/3">aes_cfb_128_decrypt/3</a></li><li><a href="#aes_cbc_128_decrypt/3">aes_cbc_128_decrypt/3</a></li><li><a href="#aes_cbc_ivec/1">aes_cbc_ivec/1</a></li><li><a href="#aes_ctr_encrypt/3">aes_ctr_encrypt/3</a></li><li><a href="#aes_ctr_decrypt/3">aes_ctr_decrypt/3</a></li><li><a href="#aes_ctr_stream_init/2">aes_ctr_stream_init/2</a></li><li><a href="#aes_ctr_stream_encrypt/2">aes_ctr_stream_encrypt/2</a></li><li><a href="#aes_ctr_stream_decrypt/2">aes_ctr_stream_decrypt/2</a></li><li><a href="#erlint/1">erlint/1</a></li><li><a href="#mpint/1">mpint/1</a></li><li><a href="#rand_bytes/1">rand_bytes/1</a></li><li><a href="#strong_rand_bytes/1">strong_rand_bytes/1</a></li><li><a href="#rand_uniform/2">rand_uniform/2</a></li><li><a href="#strong_rand_mpint/3">strong_rand_mpint/3</a></li><li><a href="#mod_exp/3">mod_exp/3</a></li><li><a href="#rsa_sign/2">rsa_sign/2</a></li><li><a href="#rsa_sign/3">rsa_sign/3</a></li><li><a href="#rsa_verify/3">rsa_verify/3</a></li><li><a href="#rsa_verify/4">rsa_verify/4</a></li><li><a href="#rsa_public_encrypt/3">rsa_public_encrypt/3</a></li><li><a href="#rsa_private_decrypt/3">rsa_private_decrypt/3</a></li><li><a href="#rsa_private_encrypt/3">rsa_private_encrypt/3</a></li><li><a href="#rsa_public_decrypt/3">rsa_public_decrypt/3</a></li><li><a href="#dss_sign/2">dss_sign/2</a></li><li><a href="#dss_sign/3">dss_sign/3</a></li><li><a href="#dss_verify/3">dss_verify/3</a></li><li><a href="#dss_verify/4">dss_verify/4</a></li><li><a href="#rc2_cbc_encrypt/3">rc2_cbc_encrypt/3</a></li><li><a href="#rc2_cbc_decrypt/3">rc2_cbc_decrypt/3</a></li><li><a href="#rc4_encrypt/2">rc4_encrypt/2</a></li><li><a href="#dh_generate_key/1">dh_generate_key/1</a></li><li><a href="#dh_generate_key/2">dh_generate_key/2</a></li><li><a href="#dh_compute_key/3">dh_compute_key/3</a></li><li><a href="#exor/2">exor/2</a></li></ul>
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59760-14']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script');
        ga.src = ('https:' == document.location.protocol ?
          'https://ssl' : 'http://www') +
          '.google-analytics.com/ga.js';
        ga.setAttribute('async', 'true');
        document.documentElement.firstChild.appendChild(ga);
      })();
    </script>
  </body>
</html>

