<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="latin1" />
    <title>erl_syntax (syntax_tools) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml"
          title="erldocs" href="/search.xml">
    <link type="text/css" rel="stylesheet" href="../erldocs.css" />
  </head>
  <body>

    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off"
             placeholder="press TAB to search" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>erl_syntax</h1>
<h2 class="modsummary">Abstract Erlang syntax trees.</h2>
<div class="description">
<p>Abstract Erlang syntax trees.</p>
 
  <p>This module defines an abstract data type for representing Erlang
  source code as syntax trees, in a way that is backwards compatible
  with the data structures created by the Erlang standard library
  parser module <code>erl_parse</code> (often referred to as "parse
  trees", which is a bit of a misnomer). This means that all
  <code>erl_parse</code> trees are valid abstract syntax trees, but the
  reverse is not true: abstract syntax trees can in general not be used
  as input to functions expecting an <code>erl_parse</code> tree.
  However, as long as an abstract syntax tree represents a correct
  Erlang program, the function <a href="#revert-1" class="seealso">revert/1</a> should be able to
  transform it to the corresponding <code>erl_parse</code>  
representation.</p>
 
  <p>A recommended starting point for the first-time user is the
  documentation of the <a href="#type-syntaxTree" class="seealso">syntaxTree()</a> data type, and
  the function <a href="#type-1" class="seealso">type/1</a>.</p>
 
  <p><em>NOTES:</em></p>
 
  <p>This module deals with the composition and decomposition of
  <em>syntactic</em> entities (as opposed to semantic ones); its  
purpose is to hide all direct references to the data structures used  
to represent these entities. With few exceptions, the functions in  
this module perform no semantic interpretation of their inputs, and  
in general, the user is assumed to pass type-correct arguments - if  
this is not done, the effects are not defined.</p>
 
  <p>With the exception of the <code>erl_parse</code> data structures,
  the internal representations of abstract syntax trees are subject to
  change without notice, and should not be documented outside this
  module. Furthermore, we do not give any guarantees on how an abstract
  syntax tree may or may not be represented, <em>with the following
  exceptions</em>: no syntax tree is represented by a single atom, such
  as <code>none</code>, by a list constructor <code>[X | Y]</code>, or
  by the empty list <code>[]</code>. This can be relied on when writing
  functions that operate on syntax trees.</p></div>
<div class="section"><h4>DATA TYPES</h4><span id="types"> </span>

<taglist>
<dt><code>erl_parse() = parse_tree() (see module erl_parse)</code></dt>
<item><span id="type-erl_parse"> </span>
<p>The "parse tree"
  representation built by the Erlang standard library parser
  <code>erl_parse</code>. This is a subset of the
  <a href="#type-syntaxTree" class="seealso">syntaxTree</a> type.
 </p>
</item>
<dt><code>forms() = syntaxTree() | [syntaxTree()]</code></dt>
<item><span id="type-forms"> </span> </item>
<dt><code>syntaxTree()</code></dt>
<item><span id="type-syntaxTree"> </span>
<p>An abstract syntax tree. The
  <code>erl_parse</code> "parse tree" representation is a subset of the
  <code>syntaxTree()</code> representation.</p>
 
  <p>Every abstract syntax tree node has a <em>type</em>, given by the
  function <a href="#type-1" class="seealso">type/1</a>. Each node also
  has associated <em>attributes</em>; see <a href="#get_attrs-1" class="seealso">get_attrs/1</a> for details. The
  functions <a href="#make_tree-2" class="seealso">make_tree/2</a> and <a href="#subtrees-1" class="seealso">subtrees/1</a> are generic
  constructor/decomposition functions for abstract syntax trees. The
  functions <a href="#abstract-1" class="seealso">abstract/1</a> and <a href="#concrete-1" class="seealso">concrete/1</a> convert between
  constant Erlang terms and their syntactic representations. The set of
  syntax tree nodes is extensible through the <a href="#tree-2" class="seealso">tree/2</a> function.</p>
 
  <p>A syntax tree can be transformed to the <code>erl_parse</code>
  representation with the <a href="#revert-1" class="seealso">revert/1</a>
  function.</p>
</item>
<dt><code>syntaxTreeAttributes()</code></dt>
<item><span id="type-syntaxTreeAttributes"> </span>
<p>This is an abstract representation of
  syntax tree node attributes; see the function <a href="#get_attrs-1" class="seealso">get_attrs/1</a>.
 </p>
</item>
</taglist></div>
<div class="functions"><h4>Functions</h4><hr  />
<div class="function">
<h3 id="type/1">type(Node::syntaxTree()) -&gt; atom()</h3>


<div class="description"><span id="type-1"> </span>

<p>Returns the type tag of <code>Node</code>. If <code>Node</code>
  does not represent a syntax tree, evaluation fails with reason
  <code>badarg</code>. Node types currently defined by this module are:
  </p><p>
   
    application
    arity_qualifier
    atom
    attribute
   <br  />
    binary
    binary_field
    block_expr
    case_expr
   <br  />
    catch_expr
    char
    class_qualifier
    clause
   <br  />
    comment
    cond_expr
    conjunction
    disjunction
   <br  />
    eof_marker
    error_marker
    float
    form_list
   <br  />
    fun_expr
    function
    generator
    if_expr
   <br  />
    implicit_fun
    infix_expr
    integer
    list
   <br  />
    list_comp
    macro
    match_expr
    module_qualifier
   <br  />
    nil
    operator
    parentheses
    prefix_expr
   <br  />
    qualified_name
    query_expr
    receive_expr
    record_access
   <br  />
    record_expr
    record_field
    record_index_expr
    rule
   <br  />
    size_qualifier
    string
    text
    try_expr
   <br  />
    tuple
    underscore
    variable
    warning_marker
   <br  />
  </p>
  <p>The user may (for special purposes) create additional nodes
  with other type tags, using the <code>tree/2</code> function.</p>
 
  <p>Note: The primary constructor functions for a node type should
  always have the same name as the node type itself.</p>
 
<p><em>See also:</em> <a href="#application-3" class="seealso">application/3</a>, <a href="#arity_qualifier-2" class="seealso">arity_qualifier/2</a>, <a href="#atom-1" class="seealso">atom/1</a>, <a href="#attribute-2" class="seealso">attribute/2</a>, <a href="#binary-1" class="seealso">binary/1</a>, <a href="#binary_field-2" class="seealso">binary_field/2</a>, <a href="#block_expr-1" class="seealso">block_expr/1</a>, <a href="#case_expr-2" class="seealso">case_expr/2</a>, <a href="#catch_expr-1" class="seealso">catch_expr/1</a>, <a href="#char-1" class="seealso">char/1</a>, <a href="#class_qualifier-2" class="seealso">class_qualifier/2</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#cond_expr-1" class="seealso">cond_expr/1</a>, <a href="#conjunction-1" class="seealso">conjunction/1</a>, <a href="#disjunction-1" class="seealso">disjunction/1</a>, <a href="#eof_marker-0" class="seealso">eof_marker/0</a>, <a href="#error_marker-1" class="seealso">error_marker/1</a>, <a href="#float-1" class="seealso">float/1</a>, <a href="#form_list-1" class="seealso">form_list/1</a>, <a href="#fun_expr-1" class="seealso">fun_expr/1</a>, <a href="#function-2" class="seealso">function/2</a>, <a href="#generator-2" class="seealso">generator/2</a>, <a href="#if_expr-1" class="seealso">if_expr/1</a>, <a href="#implicit_fun-2" class="seealso">implicit_fun/2</a>, <a href="#infix_expr-3" class="seealso">infix_expr/3</a>, <a href="#integer-1" class="seealso">integer/1</a>, <a href="#list-2" class="seealso">list/2</a>, <a href="#list_comp-2" class="seealso">list_comp/2</a>, <a href="#macro-2" class="seealso">macro/2</a>, <a href="#match_expr-2" class="seealso">match_expr/2</a>, <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>, <a href="#nil-0" class="seealso">nil/0</a>, <a href="#operator-1" class="seealso">operator/1</a>, <a href="#parentheses-1" class="seealso">parentheses/1</a>, <a href="#prefix_expr-2" class="seealso">prefix_expr/2</a>, <a href="#qualified_name-1" class="seealso">qualified_name/1</a>, <a href="#query_expr-1" class="seealso">query_expr/1</a>, <a href="#receive_expr-3" class="seealso">receive_expr/3</a>, <a href="#record_access-3" class="seealso">record_access/3</a>, <a href="#record_expr-2" class="seealso">record_expr/2</a>, <a href="#record_field-2" class="seealso">record_field/2</a>, <a href="#record_index_expr-2" class="seealso">record_index_expr/2</a>, <a href="#rule-2" class="seealso">rule/2</a>, <a href="#size_qualifier-2" class="seealso">size_qualifier/2</a>, <a href="#string-1" class="seealso">string/1</a>, <a href="#text-1" class="seealso">text/1</a>, <a href="#tree-2" class="seealso">tree/2</a>, <a href="#try_expr-3" class="seealso">try_expr/3</a>, <a href="#tuple-1" class="seealso">tuple/1</a>, <a href="#underscore-0" class="seealso">underscore/0</a>, <a href="#variable-1" class="seealso">variable/1</a>, <a href="#warning_marker-1" class="seealso">warning_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_leaf/1">is_leaf(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_leaf-1"> </span>

<p>Returns <code>true</code> if <code>Node</code> is a leaf node,
  otherwise <code>false</code>. The currently recognised leaf node
  types are:
  </p><p>
   
    <code>atom</code>
    <code>char</code>
    <code>comment</code>
    <code>eof_marker</code>
    <code>error_marker</code>
   <br  />
    <code>float</code>
    <code>integer</code>
    <code>nil</code>
    <code>operator</code>
    <code>string</code>
   <br  />
    <code>text</code>
    <code>underscore</code>
    <code>variable</code>
    <code>warning_marker</code>
   <br  />
  </p>
  <p>A node of type <code>tuple</code> is a leaf node if and only if
  its arity is zero.</p>
 
  <p>Note: not all literals are leaf nodes, and vice versa. E.g.,
  tuples with nonzero arity and nonempty lists may be literals, but are
  not leaf nodes. Variables, on the other hand, are leaf nodes but not
  literals.</p>
 
<p><em>See also:</em> <a href="#is_literal-1" class="seealso">is_literal/1</a>, <a href="#type-1" class="seealso">type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_form/1">is_form(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_form-1"> </span>

<p>Returns <code>true</code> if <code>Node</code> is a syntax tree
  representing a so-called "source code form", otherwise
  <code>false</code>. Forms are the Erlang source code units which,
  placed in sequence, constitute an Erlang program. Current form types
  are:
  </p><p>
   
    <code>attribute</code>
    <code>comment</code>
    <code>error_marker</code>
    <code>eof_marker</code>
    <code>form_list</code>
   <br  />
    <code>function</code>
    <code>rule</code>
    <code>warning_marker</code>
    <code>text</code>
   <br  />
  </p>
<p><em>See also:</em> <a href="#attribute-2" class="seealso">attribute/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#eof_marker-0" class="seealso">eof_marker/0</a>, <a href="#error_marker-1" class="seealso">error_marker/1</a>, <a href="#form_list-1" class="seealso">form_list/1</a>, <a href="#function-2" class="seealso">function/2</a>, <a href="#rule-2" class="seealso">rule/2</a>, <a href="#type-1" class="seealso">type/1</a>, <a href="#warning_marker-1" class="seealso">warning_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="get_pos/1">get_pos(Node::syntaxTree()) -&gt; term()</h3>


<div class="description"><span id="get_pos-1"> </span>

<p>Returns the position information associated with
  <code>Node</code>. This is usually a nonnegative integer (indicating
  the source code line number), but may be any term. By default, all
  new tree nodes have their associated position information set to the
  integer zero.
 </p>
<p><em>See also:</em> <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#set_pos-2" class="seealso">set_pos/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_pos/1">set_pos(Node::syntaxTree(), Pos::term()) -&gt; syntaxTree()</h3>


<div class="description"><span id="set_pos-2"> </span>

<p>Sets the position information of <code>Node</code> to
  <code>Pos</code>.
 </p>
<p><em>See also:</em> <a href="#copy_pos-2" class="seealso">copy_pos/2</a>, <a href="#get_pos-1" class="seealso">get_pos/1</a>.</p>
</div></div>
<div class="function">
<h3 id="copy_pos/1">copy_pos(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="copy_pos-2"> </span>

<p>Copies the position information from <code>Source</code> to
  <code>Target</code>.</p>
 
  <p>This is equivalent to <code>set_pos(Target,
  get_pos(Source))</code>, but potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#get_pos-1" class="seealso">get_pos/1</a>, <a href="#set_pos-2" class="seealso">set_pos/2</a>.</p>
</div></div>
<div class="function">
<h3 id="get_precomments/1">get_precomments(Tree::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="get_precomments-1"> </span>

<p>Returns the associated pre-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, pre-comments are typically displayed
  directly above the node. For example:
  </p><pre class="sh_erlang">
          % Pre-comment of function
          foo(X) -&gt; {bar, X}.</pre><p>
 
  </p><p>If possible, the comment should be moved before any preceding
  separator characters on the same line. E.g.:
  </p><pre class="sh_erlang">
          foo([X | Xs]) -&gt;
              % Pre-comment of 'bar(X)' node
              [bar(X) | foo(Xs)];
          ...</pre><p>
  (where the comment is moved before the "<code>[</code>").</p>
 
<p><em>See also:</em> <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#set_precomments-2" class="seealso">set_precomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_precomments/1">set_precomments(Node::syntaxTree(), Comments::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="set_precomments-2"> </span>

<p>Sets the pre-comments of <code>Node</code> to
  <code>Comments</code>. <code>Comments</code> should be a possibly
  empty list of abstract comments, in top-down textual order.
 </p>
<p><em>See also:</em> <a href="#add_precomments-2" class="seealso">add_precomments/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#copy_comments-2" class="seealso">copy_comments/2</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#join_comments-2" class="seealso">join_comments/2</a>, <a href="#remove_comments-1" class="seealso">remove_comments/1</a>, <a href="#set_postcomments-2" class="seealso">set_postcomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="add_precomments/1">add_precomments(Comments::[syntaxTree()], Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="add_precomments-2"> </span>

<p>Appends <code>Comments</code> to the pre-comments of
  <code>Node</code>.</p>
 
  <p>Note: This is equivalent to <code>set_precomments(Node,
  get_precomments(Node) ++ Comments)</code>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <a href="#add_postcomments-2" class="seealso">add_postcomments/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#join_comments-2" class="seealso">join_comments/2</a>, <a href="#set_precomments-2" class="seealso">set_precomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="get_postcomments/1">get_postcomments(Tree::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="get_postcomments-1"> </span>

<p>Returns the associated post-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, post-comments are typically displayed to
  the right of and/or below the node. For example:
  </p><pre class="sh_erlang">
          {foo, X, Y}     % Post-comment of tuple</pre><p>
 
  </p><p>If possible, the comment should be moved past any following
  separator characters on the same line, rather than placing the
  separators on the following line. E.g.:
  </p><pre class="sh_erlang">
          foo([X | Xs], Y) -&gt;
              foo(Xs, bar(X));     % Post-comment of 'bar(X)' node
           ...</pre><p>
  (where the comment is moved past the rightmost "<code>)</code>" and
  the "<code>;</code>").</p>
 
<p><em>See also:</em> <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#set_postcomments-2" class="seealso">set_postcomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_postcomments/1">set_postcomments(Node::syntaxTree(), Comments::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="set_postcomments-2"> </span>

<p>Sets the post-comments of <code>Node</code> to
  <code>Comments</code>. <code>Comments</code> should be a possibly
  empty list of abstract comments, in top-down textual order
 </p>
<p><em>See also:</em> <a href="#add_postcomments-2" class="seealso">add_postcomments/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#copy_comments-2" class="seealso">copy_comments/2</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#join_comments-2" class="seealso">join_comments/2</a>, <a href="#remove_comments-1" class="seealso">remove_comments/1</a>, <a href="#set_precomments-2" class="seealso">set_precomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="add_postcomments/1">add_postcomments(Comments::[syntaxTree()], Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="add_postcomments-2"> </span>

<p>Appends <code>Comments</code> to the post-comments of
  <code>Node</code>.</p>
 
  <p>Note: This is equivalent to <code>set_postcomments(Node,
  get_postcomments(Node) ++ Comments)</code>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <a href="#add_precomments-2" class="seealso">add_precomments/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#join_comments-2" class="seealso">join_comments/2</a>, <a href="#set_postcomments-2" class="seealso">set_postcomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="has_comments/1">has_comments(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="has_comments-1"> </span>

<p>Yields <code>false</code> if the node has no associated
  comments, and <code>true</code> otherwise.</p>
 
  <p>Note: This is equivalent to <code>(get_precomments(Node) == [])
  and (get_postcomments(Node) == [])</code>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#remove_comments-1" class="seealso">remove_comments/1</a>.</p>
</div></div>
<div class="function">
<h3 id="remove_comments/1">remove_comments(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="remove_comments-1"> </span>

<p>Clears the associated comments of <code>Node</code>.</p>
 
  <p>Note: This is equivalent to
  <code>set_precomments(set_postcomments(Node, []), [])</code>, but
  potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#set_postcomments-2" class="seealso">set_postcomments/2</a>, <a href="#set_precomments-2" class="seealso">set_precomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="copy_comments/1">copy_comments(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="copy_comments-2"> </span>

<p>Copies the pre- and postcomments from <code>Source</code> to
  <code>Target</code>.</p>
 
  <p>Note: This is equivalent to
  <code>set_postcomments(set_precomments(Target,
  get_precomments(Source)), get_postcomments(Source))</code>, but
  potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#set_postcomments-2" class="seealso">set_postcomments/2</a>, <a href="#set_precomments-2" class="seealso">set_precomments/2</a>.</p>
</div></div>
<div class="function">
<h3 id="join_comments/1">join_comments(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="join_comments-2"> </span>

<p>Appends the comments of <code>Source</code> to the current
  comments of <code>Target</code>.</p>
 
  <p>Note: This is equivalent to
  <code>add_postcomments(get_postcomments(Source),
  add_precomments(get_precomments(Source), Target))</code>, but
  potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#add_postcomments-2" class="seealso">add_postcomments/2</a>, <a href="#add_precomments-2" class="seealso">add_precomments/2</a>, <a href="#comment-2" class="seealso">comment/2</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>.</p>
</div></div>
<div class="function">
<h3 id="get_ann/1">get_ann(Tree::syntaxTree()) -&gt; [term()]</h3>


<div class="description"><span id="get_ann-1"> </span>

<p>Returns the list of user annotations associated with a syntax
  tree node. For a newly created node, this is the empty list. The
  annotations may be any terms.
 </p>
<p><em>See also:</em> <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#set_ann-2" class="seealso">set_ann/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_ann/1">set_ann(Node::syntaxTree(), Annotations::[term()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="set_ann-2"> </span>

<p>Sets the list of user annotations of <code>Node</code> to
  <code>Annotations</code>.
 </p>
<p><em>See also:</em> <a href="#add_ann-2" class="seealso">add_ann/2</a>, <a href="#copy_ann-2" class="seealso">copy_ann/2</a>, <a href="#get_ann-1" class="seealso">get_ann/1</a>.</p>
</div></div>
<div class="function">
<h3 id="add_ann/1">add_ann(Annotation::term(), Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="add_ann-2"> </span>

<p>Appends the term <code>Annotation</code> to the list of user
  annotations of <code>Node</code>.</p>
 
  <p>Note: this is equivalent to <code>set_ann(Node, [Annotation |
  get_ann(Node)])</code>, but potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#get_ann-1" class="seealso">get_ann/1</a>, <a href="#set_ann-2" class="seealso">set_ann/2</a>.</p>
</div></div>
<div class="function">
<h3 id="copy_ann/1">copy_ann(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="copy_ann-2"> </span>

<p>Copies the list of user annotations from <code>Source</code> to
  <code>Target</code>.</p>
 
  <p>Note: this is equivalent to <code>set_ann(Target,
  get_ann(Source))</code>, but potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#get_ann-1" class="seealso">get_ann/1</a>, <a href="#set_ann-2" class="seealso">set_ann/2</a>.</p>
</div></div>
<div class="function">
<h3 id="get_attrs/1">get_attrs(Tree::syntaxTree()) -&gt; syntaxTreeAttributes()</h3>


<div class="description"><span id="get_attrs-1"> </span>

<p>Returns a representation of the attributes associated with a
  syntax tree node. The attributes are all the extra information that
  can be attached to a node. Currently, this includes position
  information, source code comments, and user annotations. The result
  of this function cannot be inspected directly; only attached to
  another node (cf. <code>set_attrs/2</code>).</p>
 
  <p>For accessing individual attributes, see <code>get_pos/1</code>,
  <code>get_ann/1</code>, <code>get_precomments/1</code> and
  <code>get_postcomments/1</code>.</p>
 
<p><em>See also:</em> <a href="#get_ann-1" class="seealso">get_ann/1</a>, <a href="#get_pos-1" class="seealso">get_pos/1</a>, <a href="#get_postcomments-1" class="seealso">get_postcomments/1</a>, <a href="#get_precomments-1" class="seealso">get_precomments/1</a>, <a href="#set_attrs-2" class="seealso">set_attrs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="set_attrs/1">set_attrs(Node::syntaxTree(), Attributes::syntaxTreeAttributes()) -&gt; syntaxTree()</h3>


<div class="description"><span id="set_attrs-2"> </span>

<p>Sets the attributes of <code>Node</code> to
  <code>Attributes</code>.
 </p>
<p><em>See also:</em> <a href="#copy_attrs-2" class="seealso">copy_attrs/2</a>, <a href="#get_attrs-1" class="seealso">get_attrs/1</a>.</p>
</div></div>
<div class="function">
<h3 id="copy_attrs/1">copy_attrs(Source::syntaxTree(), Target::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="copy_attrs-2"> </span>

<p>Copies the attributes from <code>Source</code> to
  <code>Target</code>.</p>
 
  <p>Note: this is equivalent to <code>set_attrs(Target,
  get_attrs(Source))</code>, but potentially more efficient.</p>
 
<p><em>See also:</em> <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#set_attrs-2" class="seealso">set_attrs/2</a>.</p>
</div></div>
<div class="function">
<h3 id="comment/1">comment(Strings) -&gt; syntaxTree()</h3>


<div class="description"><span id="comment-1"> </span>
<p>Equivalent to <a href="#comment-2" class="seealso">comment(none, Strings)</a>.</p>
</div></div>
<div class="function">
<h3 id="comment/2">comment(Pad::Padding, Strings::[string()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Padding = none | integer()</code></li></ul>
<div class="description"><span id="comment-2"> </span>

<p>Creates an abstract comment with the given padding and text. If
  <code>Strings</code> is a (possibly empty) list
  <code>["Txt1", ..., "TxtN"]</code>, the result
  represents the source code text
  </p><pre class="sh_erlang">
      %Txt1
      ...
      %TxtN</pre><p>
  <code>Padding</code> states the number of empty character positions
  to the left of the comment separating it horizontally from
  source code on the same line (if any). If <code>Padding</code> is
  <code>none</code>, a default positive number is used. If
  <code>Padding</code> is an integer less than 1, there should be no
  separating space. Comments are in themselves regarded as source
  program forms.
 </p>
<p><em>See also:</em> <a href="#comment-1" class="seealso">comment/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>.</p>
</div></div>
<div class="function">
<h3 id="comment_text/1">comment_text(Node::syntaxTree()) -&gt; [string()]</h3>


<div class="description"><span id="comment_text-1"> </span>

<p>Returns the lines of text of the abstract comment.
 </p>
<p><em>See also:</em> <a href="#comment-2" class="seealso">comment/2</a>.</p>
</div></div>
<div class="function">
<h3 id="comment_padding/1">comment_padding(Node::syntaxTree()) -&gt; none | integer()</h3>


<div class="description"><span id="comment_padding-1"> </span>

<p>Returns the amount of padding before the comment, or
  <code>none</code>. The latter means that a default padding may be
  used.
 </p>
<p><em>See also:</em> <a href="#comment-2" class="seealso">comment/2</a>.</p>
</div></div>
<div class="function">
<h3 id="form_list/1">form_list(Forms::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="form_list-1"> </span>

<p>Creates an abstract sequence of "source code forms". If
  <code>Forms</code> is <code>[F1, ..., Fn]</code>, where each
  <code>Fi</code> is a form (cf. <code>is_form/1</code>, the result
  represents
  </p><pre class="sh_erlang">
      F1
      ...
      Fn</pre><p>
  where the <code>Fi</code> are separated by one or more line breaks. A
  node of type <code>form_list</code> is itself regarded as a source
  code form; cf. <code>flatten_form_list/1</code>.</p>
 
  <p>Note: this is simply a way of grouping source code forms as a
  single syntax tree, usually in order to form an Erlang module
  definition.</p>
 
<p><em>See also:</em> <a href="#flatten_form_list-1" class="seealso">flatten_form_list/1</a>, <a href="#form_list_elements-1" class="seealso">form_list_elements/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>.</p>
</div></div>
<div class="function">
<h3 id="form_list_elements/1">form_list_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="form_list_elements-1"> </span>

<p>Returns the list of subnodes of a <code>form_list</code> node.
 </p>
<p><em>See also:</em> <a href="#form_list-1" class="seealso">form_list/1</a>.</p>
</div></div>
<div class="function">
<h3 id="flatten_form_list/1">flatten_form_list(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="flatten_form_list-1"> </span>

<p>Flattens sublists of a <code>form_list</code> node. Returns
  <code>Node</code> with all subtrees of type <code>form_list</code>
  recursively expanded, yielding a single "flat" abstract form
  sequence.
 </p>
<p><em>See also:</em> <a href="#form_list-1" class="seealso">form_list/1</a>.</p>
</div></div>
<div class="function">
<h3 id="text/1">text(String::string()) -&gt; syntaxTree()</h3>


<div class="description"><span id="text-1"> </span>

<p>Creates an abstract piece of source code text. The result
  represents exactly the sequence of characters in <code>String</code>.
  This is useful in cases when one wants full control of the resulting
  output, e.g., for the appearance of floating-point numbers or macro
  definitions.
 </p>
<p><em>See also:</em> <a href="#text_string-1" class="seealso">text_string/1</a>.</p>
</div></div>
<div class="function">
<h3 id="text_string/1">text_string(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="text_string-1"> </span>

<p>Returns the character sequence represented by a
  <code>text</code> node.
 </p>
<p><em>See also:</em> <a href="#text-1" class="seealso">text/1</a>.</p>
</div></div>
<div class="function">
<h3 id="variable/1">variable(Name) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Name = atom() | string()</code></li></ul>
<div class="description"><span id="variable-1"> </span>

<p>Creates an abstract variable with the given name.
  <code>Name</code> may be any atom or string that represents a
  lexically valid variable name, but <em>not</em> a single underscore
  character; cf. <code>underscore/0</code>.</p>
 
  <p>Note: no checking is done whether the character sequence
  represents a proper variable name, i.e., whether or not its first
  character is an uppercase Erlang character, or whether it does not
  contain control characters, whitespace, etc.</p>
 
<p><em>See also:</em> <a href="#underscore-0" class="seealso">underscore/0</a>, <a href="#variable_literal-1" class="seealso">variable_literal/1</a>, <a href="#variable_name-1" class="seealso">variable_name/1</a>.</p>
</div></div>
<div class="function">
<h3 id="variable_name/1">variable_name(Node::syntaxTree()) -&gt; atom()</h3>


<div class="description"><span id="variable_name-1"> </span>

<p>Returns the name of a <code>variable</code> node as an atom.
 </p>
<p><em>See also:</em> <a href="#variable-1" class="seealso">variable/1</a>.</p>
</div></div>
<div class="function">
<h3 id="variable_literal/1">variable_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="variable_literal-1"> </span>

<p>Returns the name of a <code>variable</code> node as a string.
 </p>
<p><em>See also:</em> <a href="#variable-1" class="seealso">variable/1</a>.</p>
</div></div>
<div class="function">
<h3 id="underscore/0">underscore() -&gt; syntaxTree()</h3>


<div class="description"><span id="underscore-0"> </span>

<p>Creates an abstract universal pattern ("<code>_</code>"). The
  lexical representation is a single underscore character. Note that
  this is <em>not</em> a variable, lexically speaking.
 </p>
<p><em>See also:</em> <a href="#variable-1" class="seealso">variable/1</a>.</p>
</div></div>
<div class="function">
<h3 id="integer/1">integer(Value::integer()) -&gt; syntaxTree()</h3>


<div class="description"><span id="integer-1"> </span>

<p>Creates an abstract integer literal. The lexical representation
  is the canonical decimal numeral of <code>Value</code>.
 </p>
<p><em>See also:</em> <a href="#integer_literal-1" class="seealso">integer_literal/1</a>, <a href="#integer_value-1" class="seealso">integer_value/1</a>, <a href="#is_integer-2" class="seealso">is_integer/2</a>.</p>
</div></div>
<div class="function">
<h3 id="is_integer/1">is_integer(Node::syntaxTree(), Value::integer()) -&gt; boolean()</h3>


<div class="description"><span id="is_integer-2"> </span>

<p>Returns <code>true</code> if <code>Node</code> has type
  <code>integer</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p><em>See also:</em> <a href="#integer-1" class="seealso">integer/1</a>.</p>
</div></div>
<div class="function">
<h3 id="integer_value/1">integer_value(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="integer_value-1"> </span>

<p>Returns the value represented by an <code>integer</code> node.
 </p>
<p><em>See also:</em> <a href="#integer-1" class="seealso">integer/1</a>.</p>
</div></div>
<div class="function">
<h3 id="integer_literal/1">integer_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="integer_literal-1"> </span>

<p>Returns the numeral string represented by an
  <code>integer</code> node.
 </p>
<p><em>See also:</em> <a href="#integer-1" class="seealso">integer/1</a>.</p>
</div></div>
<div class="function">
<h3 id="float/1">float(Value::float()) -&gt; syntaxTree()</h3>


<div class="description"><span id="float-1"> </span>

<p>Creates an abstract floating-point literal. The lexical
  representation is the decimal floating-point numeral of
  <code>Value</code>.
 </p>
<p><em>See also:</em> <a href="#float_literal-1" class="seealso">float_literal/1</a>, <a href="#float_value-1" class="seealso">float_value/1</a>.</p>
</div></div>
<div class="function">
<h3 id="float_value/1">float_value(Node::syntaxTree()) -&gt; float()</h3>


<div class="description"><span id="float_value-1"> </span>

<p>Returns the value represented by a <code>float</code> node. Note
  that floating-point values should usually not be compared for
  equality.
 </p>
<p><em>See also:</em> <a href="#float-1" class="seealso">float/1</a>.</p>
</div></div>
<div class="function">
<h3 id="float_literal/1">float_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="float_literal-1"> </span>

<p>Returns the numeral string represented by a <code>float</code>
  node.
 </p>
<p><em>See also:</em> <a href="#float-1" class="seealso">float/1</a>.</p>
</div></div>
<div class="function">
<h3 id="char/1">char(Value::char()) -&gt; syntaxTree()</h3>


<div class="description"><span id="char-1"> </span>

<p>Creates an abstract character literal. The result represents
  "<code>$Name</code>", where <code>Name</code> corresponds to
  <code>Value</code>.</p>
 
  <p>Note: the literal corresponding to a particular character value is
  not uniquely defined. E.g., the character "<code>a</code>" can be
  written both as "<code>$a</code>" and "<code>$\141</code>", and a Tab
  character can be written as "<code>$\11</code>", "<code>$\011</code>"
  or "<code>$\t</code>".</p>
 
<p><em>See also:</em> <a href="#char_literal-1" class="seealso">char_literal/1</a>, <a href="#char_value-1" class="seealso">char_value/1</a>, <a href="#is_char-2" class="seealso">is_char/2</a>.</p>
</div></div>
<div class="function">
<h3 id="is_char/1">is_char(Node::syntaxTree(), Value::char()) -&gt; boolean()</h3>


<div class="description"><span id="is_char-2"> </span>

<p>Returns <code>true</code> if <code>Node</code> has type
  <code>char</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p><em>See also:</em> <a href="#char-1" class="seealso">char/1</a>.</p>
</div></div>
<div class="function">
<h3 id="char_value/1">char_value(Node::syntaxTree()) -&gt; char()</h3>


<div class="description"><span id="char_value-1"> </span>

<p>Returns the value represented by a <code>char</code> node.
 </p>
<p><em>See also:</em> <a href="#char-1" class="seealso">char/1</a>.</p>
</div></div>
<div class="function">
<h3 id="char_literal/1">char_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="char_literal-1"> </span>

<p>Returns the literal string represented by a <code>char</code>
  node. This includes the leading "<code>$</code>" character.
 </p>
<p><em>See also:</em> <a href="#char-1" class="seealso">char/1</a>.</p>
</div></div>
<div class="function">
<h3 id="string/1">string(Value::string()) -&gt; syntaxTree()</h3>


<div class="description"><span id="string-1"> </span>

<p>Creates an abstract string literal. The result represents
  <code>"Text"</code> (including the surrounding
  double-quotes), where <code>Text</code> corresponds to the sequence
  of characters in <code>Value</code>, but not representing a
  <em>specific</em> string literal. E.g., the result of
  <code>string("x\ny")</code> represents any and all of
  <code>"x\ny"</code>, <code>"x\12y"</code>, <code>"x\012y"</code> and
  <code>"x\^Jy"</code>; cf. <code>char/1</code>.
 </p>
<p><em>See also:</em> <a href="#char-1" class="seealso">char/1</a>, <a href="#is_string-2" class="seealso">is_string/2</a>, <a href="#string_literal-1" class="seealso">string_literal/1</a>, <a href="#string_value-1" class="seealso">string_value/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_string/1">is_string(Node::syntaxTree(), Value::string()) -&gt; boolean()</h3>


<div class="description"><span id="is_string-2"> </span>

<p>Returns <code>true</code> if <code>Node</code> has type
  <code>string</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p><em>See also:</em> <a href="#string-1" class="seealso">string/1</a>.</p>
</div></div>
<div class="function">
<h3 id="string_value/1">string_value(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="string_value-1"> </span>

<p>Returns the value represented by a <code>string</code> node.
 </p>
<p><em>See also:</em> <a href="#string-1" class="seealso">string/1</a>.</p>
</div></div>
<div class="function">
<h3 id="string_literal/1">string_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="string_literal-1"> </span>

<p>Returns the literal string represented by a <code>string</code>
  node. This includes surrounding double-quote characters.
 </p>
<p><em>See also:</em> <a href="#string-1" class="seealso">string/1</a>.</p>
</div></div>
<div class="function">
<h3 id="atom/1">atom(Name) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Name = atom() | string()</code></li></ul>
<div class="description"><span id="atom-1"> </span>

<p>Creates an abstract atom literal. The print name of the atom is
  the character sequence represented by <code>Name</code>.
 </p>
<p><em>See also:</em> <a href="#atom_literal-1" class="seealso">atom_literal/1</a>, <a href="#atom_name-1" class="seealso">atom_name/1</a>, <a href="#atom_value-1" class="seealso">atom_value/1</a>, <a href="#is_atom-2" class="seealso">is_atom/2</a>.</p>
</div></div>
<div class="function">
<h3 id="is_atom/1">is_atom(Node::syntaxTree(), Value::atom()) -&gt; boolean()</h3>


<div class="description"><span id="is_atom-2"> </span>

<p>Returns <code>true</code> if <code>Node</code> has type
  <code>atom</code> and represents <code>Value</code>, otherwise
  <code>false</code>.
 </p>
<p><em>See also:</em> <a href="#atom-1" class="seealso">atom/1</a>.</p>
</div></div>
<div class="function">
<h3 id="atom_value/1">atom_value(Node::syntaxTree()) -&gt; atom()</h3>


<div class="description"><span id="atom_value-1"> </span>

<p>Returns the value represented by an <code>atom</code> node.
 </p>
<p><em>See also:</em> <a href="#atom-1" class="seealso">atom/1</a>.</p>
</div></div>
<div class="function">
<h3 id="atom_name/1">atom_name(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="atom_name-1"> </span>

<p>Returns the printname of an <code>atom</code> node.
 </p>
<p><em>See also:</em> <a href="#atom-1" class="seealso">atom/1</a>.</p>
</div></div>
<div class="function">
<h3 id="atom_literal/1">atom_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="atom_literal-1"> </span>

<p>Returns the literal string represented by an <code>atom</code>  
node. This includes surrounding single-quote characters if necessary.</p>
 
  <p>Note that e.g. the result of <code>atom("x\ny")</code> represents
  any and all of <code>'x\ny'</code>, <code>'x\12y'</code>,
  <code>'x\012y'</code> and <code>'x\^Jy\'</code>; cf.
  <code>string/1</code>.</p>
 
<p><em>See also:</em> <a href="#atom-1" class="seealso">atom/1</a>, <a href="#string-1" class="seealso">string/1</a>.</p>
</div></div>
<div class="function">
<h3 id="tuple/1">tuple(Elements::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="tuple-1"> </span>

<p>Creates an abstract tuple. If <code>Elements</code> is
  <code>[X1, ..., Xn]</code>, the result represents
  "<code>{X1, ..., Xn}</code>".</p>
 
  <p>Note: The Erlang language has distinct 1-tuples, i.e.,
  <code>{X}</code> is always distinct from <code>X</code> itself.</p>
 
<p><em>See also:</em> <a href="#tuple_elements-1" class="seealso">tuple_elements/1</a>, <a href="#tuple_size-1" class="seealso">tuple_size/1</a>.</p>
</div></div>
<div class="function">
<h3 id="tuple_elements/1">tuple_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="tuple_elements-1"> </span>

<p>Returns the list of element subtrees of a <code>tuple</code>
  node.
 </p>
<p><em>See also:</em> <a href="#tuple-1" class="seealso">tuple/1</a>.</p>
</div></div>
<div class="function">
<h3 id="tuple_size/1">tuple_size(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="tuple_size-1"> </span>

<p>Returns the number of elements of a <code>tuple</code> node.</p>
 
  <p>Note: this is equivalent to
  <code>length(tuple_elements(Node))</code>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <a href="#tuple-1" class="seealso">tuple/1</a>, <a href="#tuple_elements-1" class="seealso">tuple_elements/1</a>.</p>
</div></div>
<div class="function">
<h3 id="list/1">list(List) -&gt; syntaxTree()</h3>


<div class="description"><span id="list-1"> </span>
<p>Equivalent to <a href="#list-2" class="seealso">list(List, none)</a>.</p>
</div></div>
<div class="function">
<h3 id="list/2">list(Elements::List, Tail) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>List = [syntaxTree()]</code></li><li><code>Tail = none | syntaxTree()</code></li></ul>
<div class="description"><span id="list-2"> </span>

<p>Constructs an abstract list skeleton. The result has type
  <code>list</code> or <code>nil</code>. If <code>List</code> is a
  nonempty list <code>[E1, ..., En]</code>, the result has type
  <code>list</code> and represents either "<code>[E1, ...,
  En]</code>", if <code>Tail</code> is <code>none</code>, or
  otherwise "<code>[E1, ..., En |
  Tail]</code>". If <code>List</code> is the empty list,
  <code>Tail</code> <em>must</em> be <code>none</code>, and in that
  case the result has type <code>nil</code> and represents
  "<code>[]</code>" (cf. <code>nil/0</code>).</p>
 
  <p>The difference between lists as semantic objects (built up of
  individual "cons" and "nil" terms) and the various syntactic forms
  for denoting lists may be bewildering at first. This module provides
  functions both for exact control of the syntactic representation as
  well as for the simple composition and deconstruction in terms of
  cons and head/tail operations.</p>
 
  <p>Note: in <code>list(Elements, none)</code>, the "nil" list
  terminator is implicit and has no associated information (cf.
  <code>get_attrs/1</code>), while in the seemingly equivalent
  <code>list(Elements, Tail)</code> when <code>Tail</code> has type
  <code>nil</code>, the list terminator subtree <code>Tail</code> may
  have attached attributes such as position, comments, and annotations,
  which will be preserved in the result.</p>
 
<p><em>See also:</em> <a href="#compact_list-1" class="seealso">compact_list/1</a>, <a href="#cons-2" class="seealso">cons/2</a>, <a href="#get_attrs-1" class="seealso">get_attrs/1</a>, <a href="#is_list_skeleton-1" class="seealso">is_list_skeleton/1</a>, <a href="#is_proper_list-1" class="seealso">is_proper_list/1</a>, <a href="#list-1" class="seealso">list/1</a>, <a href="#list_elements-1" class="seealso">list_elements/1</a>, <a href="#list_head-1" class="seealso">list_head/1</a>, <a href="#list_length-1" class="seealso">list_length/1</a>, <a href="#list_prefix-1" class="seealso">list_prefix/1</a>, <a href="#list_suffix-1" class="seealso">list_suffix/1</a>, <a href="#list_tail-1" class="seealso">list_tail/1</a>, <a href="#nil-0" class="seealso">nil/0</a>, <a href="#normalize_list-1" class="seealso">normalize_list/1</a>.</p>
</div></div>
<div class="function">
<h3 id="nil/0">nil() -&gt; syntaxTree()</h3>


<div class="description"><span id="nil-0"> </span>

<p>Creates an abstract empty list. The result represents
  "<code>[]</code>". The empty list is traditionally called "nil".
 </p>
<p><em>See also:</em> <a href="#is_list_skeleton-1" class="seealso">is_list_skeleton/1</a>, <a href="#list-2" class="seealso">list/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_prefix/1">list_prefix(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="list_prefix-1"> </span>

<p>Returns the prefix element subtrees of a <code>list</code> node.
  If <code>Node</code> represents "<code>[E1, ...,
  En]</code>" or "<code>[E1, ..., En |
  Tail]</code>", the returned value is <code>[E1, ...,
  En]</code>.
 </p>
<p><em>See also:</em> <a href="#list-2" class="seealso">list/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_suffix/1">list_suffix(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="list_suffix-1"> </span>

<p>Returns the suffix subtree of a <code>list</code> node, if one
  exists. If <code>Node</code> represents "<code>[E1, ...,
  En | Tail]</code>", the returned value is
  <code>Tail</code>, otherwise, i.e., if <code>Node</code> represents
  "<code>[E1, ..., En]</code>", <code>none</code> is  
returned.</p>
 
  <p>Note that even if this function returns some <code>Tail</code>
  that is not <code>none</code>, the type of <code>Tail</code> can be
  <code>nil</code>, if the tail has been given explicitly, and the list
  skeleton has not been compacted (cf.
  <code>compact_list/1</code>).</p>
 
<p><em>See also:</em> <a href="#compact_list-1" class="seealso">compact_list/1</a>, <a href="#list-2" class="seealso">list/2</a>, <a href="#nil-0" class="seealso">nil/0</a>.</p>
</div></div>
<div class="function">
<h3 id="cons/1">cons(Head::syntaxTree(), Tail::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="cons-2"> </span>

<p>"Optimising" list skeleton cons operation. Creates an abstract
  list skeleton whose first element is <code>Head</code> and whose tail
  corresponds to <code>Tail</code>. This is similar to
  <code>list([Head], Tail)</code>, except that <code>Tail</code> may
  not be <code>none</code>, and that the result does not necessarily
  represent exactly "<code>[Head | Tail]</code>", but
  may depend on the <code>Tail</code> subtree. E.g., if
  <code>Tail</code> represents <code>[X, Y]</code>, the result may
  represent "<code>[Head, X, Y]</code>", rather than
  "<code>[Head | [X, Y]]</code>". Annotations on
  <code>Tail</code> itself may be lost if <code>Tail</code> represents
  a list skeleton, but comments on <code>Tail</code> are propagated to
  the result.
 </p>
<p><em>See also:</em> <a href="#list-2" class="seealso">list/2</a>, <a href="#list_head-1" class="seealso">list_head/1</a>, <a href="#list_tail-1" class="seealso">list_tail/1</a>.</p>
</div></div>
<div class="function">
<h3 id="list_head/1">list_head(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="list_head-1"> </span>

<p>Returns the head element subtree of a <code>list</code> node. If
  <code>Node</code> represents "<code>[Head ...]</code>", the
  result will represent "<code>Head</code>".
 </p>
<p><em>See also:</em> <a href="#cons-2" class="seealso">cons/2</a>, <a href="#list-2" class="seealso">list/2</a>, <a href="#list_tail-1" class="seealso">list_tail/1</a>.</p>
</div></div>
<div class="function">
<h3 id="list_tail/1">list_tail(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="list_tail-1"> </span>

<p>Returns the tail of a <code>list</code> node. If
  <code>Node</code> represents a single-element list
  "<code>[E]</code>", then the result has type
  <code>nil</code>, representing "<code>[]</code>". If
  <code>Node</code> represents "<code>[E1, E2
  ...]</code>", the result will represent "<code>[E2
  ...]</code>", and if <code>Node</code> represents
  "<code>[Head | Tail]</code>", the result will
  represent "<code>Tail</code>".
 </p>
<p><em>See also:</em> <a href="#cons-2" class="seealso">cons/2</a>, <a href="#list-2" class="seealso">list/2</a>, <a href="#list_head-1" class="seealso">list_head/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_list_skeleton/1">is_list_skeleton(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_list_skeleton-1"> </span>

<p>Returns <code>true</code> if <code>Node</code> has type
  <code>list</code> or <code>nil</code>, otherwise <code>false</code>.
 </p>
<p><em>See also:</em> <a href="#list-2" class="seealso">list/2</a>, <a href="#nil-0" class="seealso">nil/0</a>.</p>
</div></div>
<div class="function">
<h3 id="is_proper_list/1">is_proper_list(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_proper_list-1"> </span>

<p>Returns <code>true</code> if <code>Node</code> represents a
  proper list, and <code>false</code> otherwise. A proper list is a
  list skeleton either on the form "<code>[]</code>" or
  "<code>[E1, ..., En]</code>", or "<code>[... |
  Tail]</code>" where recursively <code>Tail</code> also  
represents a proper list.</p>
 
  <p>Note: Since <code>Node</code> is a syntax tree, the actual
  run-time values corresponding to its subtrees may often be partially
  or completely unknown. Thus, if <code>Node</code> represents e.g.
  "<code>[... | Ns]</code>" (where <code>Ns</code> is a variable), then
  the function will return <code>false</code>, because it is not known
  whether <code>Ns</code> will be bound to a list at run-time. If
  <code>Node</code> instead represents e.g. "<code>[1, 2, 3]</code>" or
  "<code>[A | []]</code>", then the function will return
  <code>true</code>.</p>
 
<p><em>See also:</em> <a href="#list-2" class="seealso">list/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_elements/1">list_elements(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="list_elements-1"> </span>

<p>Returns the list of element subtrees of a list skeleton.
  <code>Node</code> must represent a proper list. E.g., if
  <code>Node</code> represents "<code>[X1, X2 |
  [X3, X4 | []]</code>", then
  <code>list_elements(Node)</code> yields the list <code>[X1, X2, X3,
  X4]</code>.
 </p>
<p><em>See also:</em> <a href="#is_proper_list-1" class="seealso">is_proper_list/1</a>, <a href="#list-2" class="seealso">list/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_length/1">list_length(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="list_length-1"> </span>

<p>Returns the number of element subtrees of a list skeleton.
  <code>Node</code> must represent a proper list. E.g., if
  <code>Node</code> represents "<code>[X1 | [X2, X3 | [X4, X5,
  X6]]]</code>", then <code>list_length(Node)</code> returns the  
integer 6.</p>
 
  <p>Note: this is equivalent to
  <code>length(list_elements(Node))</code>, but potentially more
  efficient.</p>
 
<p><em>See also:</em> <a href="#is_proper_list-1" class="seealso">is_proper_list/1</a>, <a href="#list-2" class="seealso">list/2</a>, <a href="#list_elements-1" class="seealso">list_elements/1</a>.</p>
</div></div>
<div class="function">
<h3 id="normalize_list/1">normalize_list(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="normalize_list-1"> </span>

<p>Expands an abstract list skeleton to its most explicit form. If
  <code>Node</code> represents "<code>[E1, ..., En |
  Tail]</code>", the result represents "<code>[E1 |
  ... [En | Tail1] ... ]</code>", where
  <code>Tail1</code> is the result of
  <code>normalize_list(Tail)</code>. If <code>Node</code> represents
  "<code>[E1, ..., En]</code>", the result simply
  represents "<code>[E1 | ... [En | []] ...
  ]</code>". If <code>Node</code> does not represent a list skeleton,
  <code>Node</code> itself is returned.
 </p>
<p><em>See also:</em> <a href="#compact_list-1" class="seealso">compact_list/1</a>, <a href="#list-2" class="seealso">list/2</a>.</p>
</div></div>
<div class="function">
<h3 id="compact_list/1">compact_list(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="compact_list-1"> </span>

<p>Yields the most compact form for an abstract list skeleton. The
  result either represents "<code>[E1, ..., En |
  Tail]</code>", where <code>Tail</code> is not a list
  skeleton, or otherwise simply "<code>[E1, ...,
  En]</code>". Annotations on subtrees of <code>Node</code>
  that represent list skeletons may be lost, but comments will be
  propagated to the result. Returns <code>Node</code> itself if
  <code>Node</code> does not represent a list skeleton.
 </p>
<p><em>See also:</em> <a href="#list-2" class="seealso">list/2</a>, <a href="#normalize_list-1" class="seealso">normalize_list/1</a>.</p>
</div></div>
<div class="function">
<h3 id="binary/1">binary(Fields::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary-1"> </span>

<p>Creates an abstract binary-object template. If
  <code>Fields</code> is <code>[F1, ..., Fn]</code>, the result
  represents "<code>&lt;&lt;F1, ...,
  Fn&gt;&gt;</code>".
 </p>
<p><em>See also:</em> <a href="#binary_field-2" class="seealso">binary_field/2</a>, <a href="#binary_fields-1" class="seealso">binary_fields/1</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_fields/1">binary_fields(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="binary_fields-1"> </span>

<p>Returns the list of field subtrees of a <code>binary</code>
  node.
 </p>
<p><em>See also:</em> <a href="#binary-1" class="seealso">binary/1</a>, <a href="#binary_field-2" class="seealso">binary_field/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field/1">binary_field(Body) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_field-1"> </span>
<p>Equivalent to <a href="#binary_field-2" class="seealso">binary_field(Body, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field/1-1">binary_field(Body::syntaxTree(), Size, Types::[syntaxTree()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Size = none | syntaxTree()</code></li></ul>
<div class="description"><span id="binary_field-3"> </span>

<p>Creates an abstract binary template field.
  If <code>Size</code> is <code>none</code>, this is equivalent to
  "<code>binary_field(Body, Types)</code>", otherwise it is
  equivalent to "<code>binary_field(size_qualifier(Body, Size),
  Types)</code>".</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <a href="#binary-1" class="seealso">binary/1</a>, <a href="#binary_field-2" class="seealso">binary_field/2</a>, <a href="#size_qualifier-2" class="seealso">size_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field/1-2">binary_field(Body::syntaxTree(), Types::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_field-2"> </span>

<p>Creates an abstract binary template field. If
  <code>Types</code> is the empty list, the result simply represents
  "<code>Body</code>", otherwise, if <code>Types</code> is
  <code>[T1, ..., Tn]</code>, the result represents
  "<code>Body/T1-...-Tn</code>".
 </p>
<p><em>See also:</em> <a href="#binary-1" class="seealso">binary/1</a>, <a href="#binary_field-1" class="seealso">binary_field/1</a>, <a href="#binary_field-3" class="seealso">binary_field/3</a>, <a href="#binary_field_body-1" class="seealso">binary_field_body/1</a>, <a href="#binary_field_size-1" class="seealso">binary_field_size/1</a>, <a href="#binary_field_types-1" class="seealso">binary_field_types/1</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field_body/1">binary_field_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_field_body-1"> </span>

<p>Returns the body subtree of a <code>binary_field</code>.
 </p>
<p><em>See also:</em> <a href="#binary_field-2" class="seealso">binary_field/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field_types/1">binary_field_types(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="binary_field_types-1"> </span>

<p>Returns the list of type-specifier subtrees of a
  <code>binary_field</code> node. If <code>Node</code> represents
  "<code>.../T1, ..., Tn</code>", the result is
  <code>[T1, ..., Tn]</code>, otherwise the result is the empty list.
 </p>
<p><em>See also:</em> <a href="#binary_field-2" class="seealso">binary_field/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_field_size/1">binary_field_size(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="binary_field_size-1"> </span>

<p>Returns the size specifier subtree of a
  <code>binary_field</code> node, if any. If <code>Node</code>
  represents "<code>Body:Size</code>" or
  "<code>Body:Size/T1, ...,
  Tn</code>", the result is <code>Size</code>, otherwise
  <code>none</code> is returned.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <a href="#binary_field-2" class="seealso">binary_field/2</a>, <a href="#binary_field-3" class="seealso">binary_field/3</a>.</p>
</div></div>
<div class="function">
<h3 id="size_qualifier/1">size_qualifier(Body::syntaxTree(), Size::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="size_qualifier-2"> </span>

<p>Creates an abstract size qualifier. The result represents
  "<code>Body:Size</code>".
 </p>
<p><em>See also:</em> <a href="#size_qualifier_argument-1" class="seealso">size_qualifier_argument/1</a>, <a href="#size_qualifier_body-1" class="seealso">size_qualifier_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="size_qualifier_body/1">size_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="size_qualifier_body-1"> </span>

<p>Returns the body subtree of a <code>size_qualifier</code>
  node.
 </p>
<p><em>See also:</em> <a href="#size_qualifier-2" class="seealso">size_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="size_qualifier_argument/1">size_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="size_qualifier_argument-1"> </span>

<p>Returns the argument subtree (the size) of a
  <code>size_qualifier</code> node.
 </p>
<p><em>See also:</em> <a href="#size_qualifier-2" class="seealso">size_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="error_marker/1">error_marker(Error::term()) -&gt; syntaxTree()</h3>


<div class="description"><span id="error_marker-1"> </span>

<p>Creates an abstract error marker. The result represents an
  occurrence of an error in the source code, with an associated Erlang
  I/O ErrorInfo structure given by <code>Error</code> (see module
  <a href="../stdlib/io.html" class="seealso">io(3)</a> for details). Error markers are regarded as source  
code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.</p>
 
<p><em>See also:</em> <a href="#eof_marker-0" class="seealso">eof_marker/0</a>, <a href="#error_marker_info-1" class="seealso">error_marker_info/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#warning_marker-1" class="seealso">warning_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="error_marker_info/1">error_marker_info(Node::syntaxTree()) -&gt; term()</h3>


<div class="description"><span id="error_marker_info-1"> </span>

<p>Returns the ErrorInfo structure of an <code>error_marker</code>
  node.
 </p>
<p><em>See also:</em> <a href="#error_marker-1" class="seealso">error_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="warning_marker/1">warning_marker(Error::term()) -&gt; syntaxTree()</h3>


<div class="description"><span id="warning_marker-1"> </span>

<p>Creates an abstract warning marker. The result represents an
  occurrence of a possible problem in the source code, with an
  associated Erlang I/O ErrorInfo structure given by <code>Error</code>
  (see module <a href="../stdlib/io.html" class="seealso">io(3)</a> for details). Warning markers are  
regarded as source code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.</p>
 
<p><em>See also:</em> <a href="#eof_marker-0" class="seealso">eof_marker/0</a>, <a href="#error_marker-1" class="seealso">error_marker/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#warning_marker_info-1" class="seealso">warning_marker_info/1</a>.</p>
</div></div>
<div class="function">
<h3 id="warning_marker_info/1">warning_marker_info(Node::syntaxTree()) -&gt; term()</h3>


<div class="description"><span id="warning_marker_info-1"> </span>

<p>Returns the ErrorInfo structure of a <code>warning_marker</code>
  node.
 </p>
<p><em>See also:</em> <a href="#warning_marker-1" class="seealso">warning_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="eof_marker/0">eof_marker() -&gt; syntaxTree()</h3>


<div class="description"><span id="eof_marker-0"> </span>

<p>Creates an abstract end-of-file marker. This represents the  
end of input when reading a sequence of source code forms. An  
end-of-file marker is itself regarded as a source code form  
(namely, the last in any sequence in which it occurs). It has no  
defined lexical form.</p>
 
  <p>Note: this is retained only for backwards compatibility with
  existing parsers and tools.</p>
 
<p><em>See also:</em> <a href="#error_marker-1" class="seealso">error_marker/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#warning_marker-1" class="seealso">warning_marker/1</a>.</p>
</div></div>
<div class="function">
<h3 id="attribute/1">attribute(Name) -&gt; syntaxTree()</h3>


<div class="description"><span id="attribute-1"> </span>
<p>Equivalent to <a href="#attribute-2" class="seealso">attribute(Name, none)</a>.</p>
</div></div>
<div class="function">
<h3 id="attribute/1-1">attribute(Name::syntaxTree(), Args::Arguments) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Arguments = none | [syntaxTree()]</code></li></ul>
<div class="description"><span id="attribute-2"> </span>

<p>Creates an abstract program attribute. If
  <code>Arguments</code> is <code>[A1, ..., An]</code>, the result
  represents "<code>-Name(A1, ...,
  An).</code>". Otherwise, if <code>Arguments</code> is
  <code>none</code>, the result represents
  "<code>-Name.</code>". The latter form makes it possible
  to represent preprocessor directives such as
  "<code>-endif.</code>". Attributes are source code forms.</p>
 
  <p>Note: The preprocessor macro definition directive
  "<code>-define(Name, Body).</code>" has relatively
  few requirements on the syntactical form of <code>Body</code> (viewed
  as a sequence of tokens). The <code>text</code> node type can be used
  for a <code>Body</code> that is not a normal Erlang construct.</p>
 
<p><em>See also:</em> <a href="#attribute-1" class="seealso">attribute/1</a>, <a href="#attribute_arguments-1" class="seealso">attribute_arguments/1</a>, <a href="#attribute_name-1" class="seealso">attribute_name/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#text-1" class="seealso">text/1</a>.</p>
</div></div>
<div class="function">
<h3 id="attribute_name/1">attribute_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="attribute_name-1"> </span>

<p>Returns the name subtree of an <code>attribute</code> node.
 </p>
<p><em>See also:</em> <a href="#attribute-1" class="seealso">attribute/1</a>.</p>
</div></div>
<div class="function">
<h3 id="attribute_arguments/1">attribute_arguments(Node::syntaxTree()) -&gt; none | [syntaxTree()]</h3>


<div class="description"><span id="attribute_arguments-1"> </span>

<p>Returns the list of argument subtrees of an
  <code>attribute</code> node, if any. If <code>Node</code>
  represents "<code>-Name.</code>", the result is
  <code>none</code>. Otherwise, if <code>Node</code> represents
  "<code>-Name(E1, ..., En).</code>",
  <code>[E1, ..., E1]</code> is returned.
 </p>
<p><em>See also:</em> <a href="#attribute-1" class="seealso">attribute/1</a>.</p>
</div></div>
<div class="function">
<h3 id="arity_qualifier/1">arity_qualifier(Body::syntaxTree(), Arity::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="arity_qualifier-2"> </span>

<p>Creates an abstract arity qualifier. The result represents
  "<code>Body/Arity</code>".
 </p>
<p><em>See also:</em> <a href="#arity_qualifier_argument-1" class="seealso">arity_qualifier_argument/1</a>, <a href="#arity_qualifier_body-1" class="seealso">arity_qualifier_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="arity_qualifier_body/1">arity_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="arity_qualifier_body-1"> </span>

<p>Returns the body subtree of an <code>arity_qualifier</code>
  node.
 </p>
<p><em>See also:</em> <a href="#arity_qualifier-2" class="seealso">arity_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="arity_qualifier_argument/1">arity_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="arity_qualifier_argument-1"> </span>

<p>Returns the argument (the arity) subtree of an
  <code>arity_qualifier</code> node.
 </p>
<p><em>See also:</em> <a href="#arity_qualifier-2" class="seealso">arity_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="module_qualifier/1">module_qualifier(Module::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="module_qualifier-2"> </span>

<p>Creates an abstract module qualifier. The result represents
  "<code>Module:Body</code>".
 </p>
<p><em>See also:</em> <a href="#module_qualifier_argument-1" class="seealso">module_qualifier_argument/1</a>, <a href="#module_qualifier_body-1" class="seealso">module_qualifier_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="module_qualifier_argument/1">module_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="module_qualifier_argument-1"> </span>

<p>Returns the argument (the module) subtree of a
  <code>module_qualifier</code> node.
 </p>
<p><em>See also:</em> <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="module_qualifier_body/1">module_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="module_qualifier_body-1"> </span>

<p>Returns the body subtree of a <code>module_qualifier</code>
  node.
 </p>
<p><em>See also:</em> <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="qualified_name/1">qualified_name(Segments::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="qualified_name-1"> </span>

<p>Creates an abstract qualified name. The result represents
  "<code>S1.S2. ... .Sn</code>", if
  <code>Segments</code> is <code>[S1, S2, ..., Sn]</code>.
 </p>
<p><em>See also:</em> <a href="#qualified_name_segments-1" class="seealso">qualified_name_segments/1</a>.</p>
</div></div>
<div class="function">
<h3 id="qualified_name_segments/1">qualified_name_segments(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="qualified_name_segments-1"> </span>

<p>Returns the list of name segments of a
  <code>qualified_name</code> node.
 </p>
<p><em>See also:</em> <a href="#qualified_name-1" class="seealso">qualified_name/1</a>.</p>
</div></div>
<div class="function">
<h3 id="function/1">function(Name::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="function-2"> </span>

<p>Creates an abstract function definition. If <code>Clauses</code>
  is <code>[C1, ..., Cn]</code>, the result represents
  "<code>Name C1; ...; Name
  Cn.</code>". More exactly, if each <code>Ci</code>
  represents "<code>(Pi1, ..., Pim) Gi -&gt;
  Bi</code>", then the result represents
  "<code>Name(P11, ..., P1m) G1 -&gt;
  B1; ...; Name(Pn1, ..., Pnm)
  Gn -&gt; Bn.</code>". Function definitions are source
  code forms.
 </p>
<p><em>See also:</em> <a href="#function_arity-1" class="seealso">function_arity/1</a>, <a href="#function_clauses-1" class="seealso">function_clauses/1</a>, <a href="#function_name-1" class="seealso">function_name/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#rule-2" class="seealso">rule/2</a>.</p>
</div></div>
<div class="function">
<h3 id="function_name/1">function_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="function_name-1"> </span>

<p>Returns the name subtree of a <code>function</code> node.
 </p>
<p><em>See also:</em> <a href="#function-2" class="seealso">function/2</a>.</p>
</div></div>
<div class="function">
<h3 id="function_clauses/1">function_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="function_clauses-1"> </span>

<p>Returns the list of clause subtrees of a <code>function</code>
  node.
 </p>
<p><em>See also:</em> <a href="#function-2" class="seealso">function/2</a>.</p>
</div></div>
<div class="function">
<h3 id="function_arity/1">function_arity(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="function_arity-1"> </span>

<p>Returns the arity of a <code>function</code> node. The result  
is the number of parameter patterns in the first clause of the  
function; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <code>function_clauses(Node)</code>
  returns an empty list, or if the first element of that list is not
  a syntax tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>, <a href="#clause_patterns-1" class="seealso">clause_patterns/1</a>, <a href="#function-2" class="seealso">function/2</a>, <a href="#function_clauses-1" class="seealso">function_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="clause/2">clause(Guard, Body) -&gt; syntaxTree()</h3>


<div class="description"><span id="clause-2"> </span>
<p>Equivalent to <a href="#clause-3" class="seealso">clause([], Guard, Body)</a>.</p>
</div></div>
<div class="function">
<h3 id="clause/1">clause(Patterns::[syntaxTree()], Guard, Body::[syntaxTree()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Guard = none | syntaxTree() | [syntaxTree()] | [[syntaxTree()]]</code></li></ul>
<div class="description"><span id="clause-3"> </span>

<p>Creates an abstract clause. If <code>Patterns</code> is
  <code>[P1, ..., Pn]</code> and <code>Body</code> is <code>[B1, ...,
  Bm]</code>, then if <code>Guard</code> is <code>none</code>, the
  result represents "<code>(P1, ..., Pn) -&gt;
  B1, ..., Bm</code>", otherwise, unless
  <code>Guard</code> is a list, the result represents
  "<code>(P1, ..., Pn) when Guard -&gt;
  B1, ..., Bm</code>".</p>
 
  <p>For simplicity, the <code>Guard</code> argument may also be any
  of the following:
  </p><list>
    <item><p>An empty list <code>[]</code>. This is equivalent to passing
        <code>none</code>.</p></item>
    <item><p>A nonempty list <code>[E1, ..., Ej]</code> of syntax trees.
        This is equivalent to passing <code>conjunction([E1, ...,
        Ej])</code>.</p></item>
    <item><p>A nonempty list of lists of syntax trees <code>[[E1_1, ...,
        E1_k1], ..., [Ej_1, ..., Ej_kj]]</code>, which is equivalent
        to passing <code>disjunction([conjunction([E1_1, ...,
        E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</code>.</p></item>
  </list><p>
  </p>
 
<p><em>See also:</em> <a href="#clause-2" class="seealso">clause/2</a>, <a href="#clause_body-1" class="seealso">clause_body/1</a>, <a href="#clause_guard-1" class="seealso">clause_guard/1</a>, <a href="#clause_patterns-1" class="seealso">clause_patterns/1</a>.</p>
</div></div>
<div class="function">
<h3 id="clause_patterns/1">clause_patterns(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="clause_patterns-1"> </span>

<p>Returns the list of pattern subtrees of a <code>clause</code>
  node.
 </p>
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>.</p>
</div></div>
<div class="function">
<h3 id="clause_guard/1">clause_guard(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="clause_guard-1"> </span>

<p>Returns the guard subtree of a <code>clause</code> node, if
  any. If <code>Node</code> represents "<code>(P1, ...,
  Pn) when Guard -&gt; B1, ...,
  Bm</code>", <code>Guard</code> is returned. Otherwise, the
  result is <code>none</code>.
 </p>
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>.</p>
</div></div>
<div class="function">
<h3 id="clause_body/1">clause_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="clause_body-1"> </span>

<p>Return the list of body subtrees of a <code>clause</code>
  node.
 </p>
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>.</p>
</div></div>
<div class="function">
<h3 id="disjunction/1">disjunction(List::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="disjunction-1"> </span>

<p>Creates an abstract disjunction. If <code>List</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code>E1; ...; En</code>".
 </p>
<p><em>See also:</em> <a href="#conjunction-1" class="seealso">conjunction/1</a>, <a href="#disjunction_body-1" class="seealso">disjunction_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="disjunction_body/1">disjunction_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="disjunction_body-1"> </span>

<p>Returns the list of body subtrees of a
  <code>disjunction</code> node.
 </p>
<p><em>See also:</em> <a href="#disjunction-1" class="seealso">disjunction/1</a>.</p>
</div></div>
<div class="function">
<h3 id="conjunction/1">conjunction(List::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="conjunction-1"> </span>

<p>Creates an abstract conjunction. If <code>List</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code>E1, ..., En</code>".
 </p>
<p><em>See also:</em> <a href="#conjunction_body-1" class="seealso">conjunction_body/1</a>, <a href="#disjunction-1" class="seealso">disjunction/1</a>.</p>
</div></div>
<div class="function">
<h3 id="conjunction_body/1">conjunction_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="conjunction_body-1"> </span>

<p>Returns the list of body subtrees of a
  <code>conjunction</code> node.
 </p>
<p><em>See also:</em> <a href="#conjunction-1" class="seealso">conjunction/1</a>.</p>
</div></div>
<div class="function">
<h3 id="catch_expr/1">catch_expr(Expr::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="catch_expr-1"> </span>

<p>Creates an abstract catch-expression. The result represents
  "<code>catch Expr</code>".
 </p>
<p><em>See also:</em> <a href="#catch_expr_body-1" class="seealso">catch_expr_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="catch_expr_body/1">catch_expr_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="catch_expr_body-1"> </span>

<p>Returns the body subtree of a <code>catch_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#catch_expr-1" class="seealso">catch_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="match_expr/1">match_expr(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="match_expr-2"> </span>

<p>Creates an abstract match-expression. The result represents
  "<code>Pattern = Body</code>".
 </p>
<p><em>See also:</em> <a href="#match_expr_body-1" class="seealso">match_expr_body/1</a>, <a href="#match_expr_pattern-1" class="seealso">match_expr_pattern/1</a>.</p>
</div></div>
<div class="function">
<h3 id="match_expr_pattern/1">match_expr_pattern(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="match_expr_pattern-1"> </span>

<p>Returns the pattern subtree of a <code>match_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#match_expr-2" class="seealso">match_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="match_expr_body/1">match_expr_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="match_expr_body-1"> </span>

<p>Returns the body subtree of a <code>match_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#match_expr-2" class="seealso">match_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="operator/1">operator(Name) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Name = atom() | string()</code></li></ul>
<div class="description"><span id="operator-1"> </span>

<p>Creates an abstract operator. The name of the operator is the
  character sequence represented by <code>Name</code>. This is
  analogous to the print name of an atom, but an operator is never
  written within single-quotes; e.g., the result of
  <code>operator('++')</code> represents "<code>++</code>" rather
  than "<code>'++'</code>".
 </p>
<p><em>See also:</em> <a href="#atom-1" class="seealso">atom/1</a>, <a href="#operator_literal-1" class="seealso">operator_literal/1</a>, <a href="#operator_name-1" class="seealso">operator_name/1</a>.</p>
</div></div>
<div class="function">
<h3 id="operator_name/1">operator_name(Node::syntaxTree()) -&gt; atom()</h3>


<div class="description"><span id="operator_name-1"> </span>

<p>Returns the name of an <code>operator</code> node. Note that
  the name is returned as an atom.
 </p>
<p><em>See also:</em> <a href="#operator-1" class="seealso">operator/1</a>.</p>
</div></div>
<div class="function">
<h3 id="operator_literal/1">operator_literal(Node::syntaxTree()) -&gt; string()</h3>


<div class="description"><span id="operator_literal-1"> </span>

<p>Returns the literal string represented by an
  <code>operator</code> node. This is simply the operator name as a
  string.
 </p>
<p><em>See also:</em> <a href="#operator-1" class="seealso">operator/1</a>.</p>
</div></div>
<div class="function">
<h3 id="infix_expr/1">infix_expr(Left::syntaxTree(), Operator::syntaxTree(), Right::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="infix_expr-3"> </span>

<p>Creates an abstract infix operator expression. The result
  represents "<code>Left Operator
  Right</code>".
 </p>
<p><em>See also:</em> <a href="#infix_expr_left-1" class="seealso">infix_expr_left/1</a>, <a href="#infix_expr_operator-1" class="seealso">infix_expr_operator/1</a>, <a href="#infix_expr_right-1" class="seealso">infix_expr_right/1</a>, <a href="#prefix_expr-2" class="seealso">prefix_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="infix_expr_left/1">infix_expr_left(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="infix_expr_left-1"> </span>

<p>Returns the left argument subtree of an
  <code>infix_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#infix_expr-3" class="seealso">infix_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="infix_expr_operator/1">infix_expr_operator(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="infix_expr_operator-1"> </span>

<p>Returns the operator subtree of an <code>infix_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#infix_expr-3" class="seealso">infix_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="infix_expr_right/1">infix_expr_right(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="infix_expr_right-1"> </span>

<p>Returns the right argument subtree of an
  <code>infix_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#infix_expr-3" class="seealso">infix_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="prefix_expr/1">prefix_expr(Operator::syntaxTree(), Argument::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="prefix_expr-2"> </span>

<p>Creates an abstract prefix operator expression. The result
  represents "<code>Operator Argument</code>".
 </p>
<p><em>See also:</em> <a href="#infix_expr-3" class="seealso">infix_expr/3</a>, <a href="#prefix_expr_argument-1" class="seealso">prefix_expr_argument/1</a>, <a href="#prefix_expr_operator-1" class="seealso">prefix_expr_operator/1</a>.</p>
</div></div>
<div class="function">
<h3 id="prefix_expr_operator/1">prefix_expr_operator(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="prefix_expr_operator-1"> </span>

<p>Returns the operator subtree of a <code>prefix_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#prefix_expr-2" class="seealso">prefix_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="prefix_expr_argument/1">prefix_expr_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="prefix_expr_argument-1"> </span>

<p>Returns the argument subtree of a <code>prefix_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#prefix_expr-2" class="seealso">prefix_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_field/1">record_field(Name) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_field-1"> </span>
<p>Equivalent to <a href="#record_field-2" class="seealso">record_field(Name, none)</a>.</p>
</div></div>
<div class="function">
<h3 id="record_field/1-1">record_field(Name::syntaxTree(), Value) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Value = none | syntaxTree()</code></li></ul>
<div class="description"><span id="record_field-2"> </span>

<p>Creates an abstract record field specification. If
  <code>Value</code> is <code>none</code>, the result represents
  simply "<code>Name</code>", otherwise it represents
  "<code>Name = Value</code>".
 </p>
<p><em>See also:</em> <a href="#record_expr-3" class="seealso">record_expr/3</a>, <a href="#record_field_name-1" class="seealso">record_field_name/1</a>, <a href="#record_field_value-1" class="seealso">record_field_value/1</a>.</p>
</div></div>
<div class="function">
<h3 id="record_field_name/1">record_field_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_field_name-1"> </span>

<p>Returns the name subtree of a <code>record_field</code> node.
 </p>
<p><em>See also:</em> <a href="#record_field-2" class="seealso">record_field/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_field_value/1">record_field_value(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="record_field_value-1"> </span>

<p>Returns the value subtree of a <code>record_field</code> node,
  if any. If <code>Node</code> represents
  "<code>Name</code>", <code>none</code> is
  returned. Otherwise, if <code>Node</code> represents
  "<code>Name = Value</code>", <code>Value</code>
  is returned.
 </p>
<p><em>See also:</em> <a href="#record_field-2" class="seealso">record_field/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_index_expr/1">record_index_expr(Type::syntaxTree(), Field::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_index_expr-2"> </span>

<p>Creates an abstract record field index expression. The result
  represents "<code>#Type.Field</code>".</p>
 
  <p>(Note: the function name <code>record_index/2</code> is reserved
  by the Erlang compiler, which is why that name could not be used
  for this constructor.)</p>
 
<p><em>See also:</em> <a href="#record_expr-3" class="seealso">record_expr/3</a>, <a href="#record_index_expr_field-1" class="seealso">record_index_expr_field/1</a>, <a href="#record_index_expr_type-1" class="seealso">record_index_expr_type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="record_index_expr_type/1">record_index_expr_type(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_index_expr_type-1"> </span>

<p>Returns the type subtree of a <code>record_index_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#record_index_expr-2" class="seealso">record_index_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_index_expr_field/1">record_index_expr_field(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_index_expr_field-1"> </span>

<p>Returns the field subtree of a <code>record_index_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#record_index_expr-2" class="seealso">record_index_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_access/2">record_access(Argument, Field) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_access-2"> </span>
<p>Equivalent to <a href="#record_access-3" class="seealso">record_access(Argument, none, Field)</a>.</p>
</div></div>
<div class="function">
<h3 id="record_access/1">record_access(Argument::syntaxTree(), Type, Field::syntaxTree()) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Type = none | syntaxTree()</code></li></ul>
<div class="description"><span id="record_access-3"> </span>

<p>Creates an abstract record field access expression. If
  <code>Type</code> is not <code>none</code>, the result represents
  "<code>Argument#Type.Field</code>".</p>
 
  <p>If <code>Type</code> is <code>none</code>, the result represents
  "<code>Argument.Field</code>". This is a special
  form only allowed within Mnemosyne queries.</p>
 
<p><em>See also:</em> <a href="#query_expr-1" class="seealso">query_expr/1</a>, <a href="#record_access-2" class="seealso">record_access/2</a>, <a href="#record_access_argument-1" class="seealso">record_access_argument/1</a>, <a href="#record_access_field-1" class="seealso">record_access_field/1</a>, <a href="#record_access_type-1" class="seealso">record_access_type/1</a>, <a href="#record_expr-3" class="seealso">record_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_access_argument/1">record_access_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_access_argument-1"> </span>

<p>Returns the argument subtree of a <code>record_access</code>
  node.
 </p>
<p><em>See also:</em> <a href="#record_access-3" class="seealso">record_access/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_access_type/1">record_access_type(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="record_access_type-1"> </span>

<p>Returns the type subtree of a <code>record_access</code> node,
  if any. If <code>Node</code> represents
  "<code>Argument.Field</code>", <code>none</code>
  is returned, otherwise if <code>Node</code> represents
  "<code>Argument#Type.Field</code>",
  <code>Type</code> is returned.
 </p>
<p><em>See also:</em> <a href="#record_access-3" class="seealso">record_access/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_access_field/1">record_access_field(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_access_field-1"> </span>

<p>Returns the field subtree of a <code>record_access</code>
  node.
 </p>
<p><em>See also:</em> <a href="#record_access-3" class="seealso">record_access/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_expr/2">record_expr(Type, Fields) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_expr-2"> </span>
<p>Equivalent to <a href="#record_expr-3" class="seealso">record_expr(none, Type, Fields)</a>.</p>
</div></div>
<div class="function">
<h3 id="record_expr/2-1">record_expr(Argument, Type::syntaxTree(), Fields::[syntaxTree()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Argument = none | syntaxTree()</code></li></ul>
<div class="description"><span id="record_expr-3"> </span>

<p>Creates an abstract record expression. If <code>Fields</code> is
  <code>[F1, ..., Fn]</code>, then if <code>Argument</code> is
  <code>none</code>, the result represents
  "<code>#Type{F1, ..., Fn}</code>",
  otherwise it represents
  "<code>Argument#Type{F1, ...,
  Fn}</code>".
 </p>
<p><em>See also:</em> <a href="#record_access-3" class="seealso">record_access/3</a>, <a href="#record_expr-2" class="seealso">record_expr/2</a>, <a href="#record_expr_argument-1" class="seealso">record_expr_argument/1</a>, <a href="#record_expr_fields-1" class="seealso">record_expr_fields/1</a>, <a href="#record_expr_type-1" class="seealso">record_expr_type/1</a>, <a href="#record_field-2" class="seealso">record_field/2</a>, <a href="#record_index_expr-2" class="seealso">record_index_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="record_expr_argument/1">record_expr_argument(Node::syntaxTree()) -&gt; none | syntaxTree()</h3>


<div class="description"><span id="record_expr_argument-1"> </span>

<p>Returns the argument subtree of a <code>record_expr</code> node,
  if any. If <code>Node</code> represents
  "<code>#Type{...}</code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents
  "<code>Argument#Type{...}</code>",
  <code>Argument</code> is returned.
 </p>
<p><em>See also:</em> <a href="#record_expr-3" class="seealso">record_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_expr_type/1">record_expr_type(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="record_expr_type-1"> </span>

<p>Returns the type subtree of a <code>record_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#record_expr-3" class="seealso">record_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="record_expr_fields/1">record_expr_fields(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="record_expr_fields-1"> </span>

<p>Returns the list of field subtrees of a
  <code>record_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#record_expr-3" class="seealso">record_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="application/2">application(Module, Function::syntaxTree(), Arguments::[syntaxTree()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Module = none | syntaxTree()</code></li></ul>
<div class="description"><span id="application-3"> </span>

<p>Creates an abstract function application expression. If
  <code>Module</code> is <code>none</code>, this is call is equivalent
  to <code>application(Function, Arguments)</code>, otherwise it is
  equivalent to <code>application(module_qualifier(Module, Function),
  Arguments)</code>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <a href="#application-2" class="seealso">application/2</a>, <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="application/1">application(Operator::syntaxTree(), Arguments::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="application-2"> </span>

<p>Creates an abstract function application expression. If
  <code>Arguments</code> is <code>[A1, ..., An]</code>, the result
  represents "<code>Operator(A1, ...,
  An)</code>".
 </p>
<p><em>See also:</em> <a href="#application-3" class="seealso">application/3</a>, <a href="#application_arguments-1" class="seealso">application_arguments/1</a>, <a href="#application_operator-1" class="seealso">application_operator/1</a>.</p>
</div></div>
<div class="function">
<h3 id="application_operator/1">application_operator(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="application_operator-1"> </span>

<p>Returns the operator subtree of an <code>application</code>  
node.</p>
 
  <p>Note: if <code>Node</code> represents
  "<code>M:F(...)</code>", then the result is the
  subtree representing "<code>M:F</code>".</p>
 
<p><em>See also:</em> <a href="#application-2" class="seealso">application/2</a>, <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="application_arguments/1">application_arguments(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="application_arguments-1"> </span>

<p>Returns the list of argument subtrees of an
  <code>application</code> node.
 </p>
<p><em>See also:</em> <a href="#application-2" class="seealso">application/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_comp/1">list_comp(Template::syntaxTree(), Body::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="list_comp-2"> </span>

<p>Creates an abstract list comprehension. If <code>Body</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code>[Template || E1, ..., En]</code>".
 </p>
<p><em>See also:</em> <a href="#generator-2" class="seealso">generator/2</a>, <a href="#list_comp_body-1" class="seealso">list_comp_body/1</a>, <a href="#list_comp_template-1" class="seealso">list_comp_template/1</a>.</p>
</div></div>
<div class="function">
<h3 id="list_comp_template/1">list_comp_template(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="list_comp_template-1"> </span>

<p>Returns the template subtree of a <code>list_comp</code> node.
 </p>
<p><em>See also:</em> <a href="#list_comp-2" class="seealso">list_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="list_comp_body/1">list_comp_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="list_comp_body-1"> </span>

<p>Returns the list of body subtrees of a <code>list_comp</code>
  node.
 </p>
<p><em>See also:</em> <a href="#list_comp-2" class="seealso">list_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_comp/1">binary_comp(Template::syntaxTree(), Body::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_comp-2"> </span>

<p>Creates an abstract binary comprehension. If <code>Body</code> is
  <code>[E1, ..., En]</code>, the result represents
  "<code>&lt;&lt;Template || E1, ..., En&gt;&gt;</code>".
 </p>
<p><em>See also:</em> <a href="#binary_comp_body-1" class="seealso">binary_comp_body/1</a>, <a href="#binary_comp_template-1" class="seealso">binary_comp_template/1</a>, <a href="#generator-2" class="seealso">generator/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_comp_template/1">binary_comp_template(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_comp_template-1"> </span>

<p>Returns the template subtree of a <code>binary_comp</code> node.
 </p>
<p><em>See also:</em> <a href="#binary_comp-2" class="seealso">binary_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_comp_body/1">binary_comp_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="binary_comp_body-1"> </span>

<p>Returns the list of body subtrees of a <code>binary_comp</code>
  node.
 </p>
<p><em>See also:</em> <a href="#binary_comp-2" class="seealso">binary_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="query_expr/1">query_expr(Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="query_expr-1"> </span>

<p>Creates an abstract Mnemosyne query expression. The result
  represents "<code>query Body end</code>".
 </p>
<p><em>See also:</em> <a href="#query_expr_body-1" class="seealso">query_expr_body/1</a>, <a href="#record_access-2" class="seealso">record_access/2</a>, <a href="#rule-2" class="seealso">rule/2</a>.</p>
</div></div>
<div class="function">
<h3 id="query_expr_body/1">query_expr_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="query_expr_body-1"> </span>

<p>Returns the body subtree of a <code>query_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#query_expr-1" class="seealso">query_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="rule/1">rule(Name::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="rule-2"> </span>

<p>Creates an abstract Mnemosyne rule. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the results represents
  "<code>Name C1; ...; Name
  Cn.</code>". More exactly, if each <code>Ci</code>
  represents "<code>(Pi1, ..., Pim) Gi -&gt;
  Bi</code>", then the result represents
  "<code>Name(P11, ..., P1m) G1 :-
  B1; ...; Name(Pn1, ..., Pnm)
  Gn :- Bn.</code>". Rules are source code forms.
 </p>
<p><em>See also:</em> <a href="#function-2" class="seealso">function/2</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#rule_arity-1" class="seealso">rule_arity/1</a>, <a href="#rule_clauses-1" class="seealso">rule_clauses/1</a>, <a href="#rule_name-1" class="seealso">rule_name/1</a>.</p>
</div></div>
<div class="function">
<h3 id="rule_name/1">rule_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="rule_name-1"> </span>

<p>Returns the name subtree of a <code>rule</code> node.
 </p>
<p><em>See also:</em> <a href="#rule-2" class="seealso">rule/2</a>.</p>
</div></div>
<div class="function">
<h3 id="rule_clauses/1">rule_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="rule_clauses-1"> </span>

<p>Returns the list of clause subtrees of a <code>rule</code> node.
 </p>
<p><em>See also:</em> <a href="#rule-2" class="seealso">rule/2</a>.</p>
</div></div>
<div class="function">
<h3 id="rule_arity/1">rule_arity(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="rule_arity-1"> </span>

<p>Returns the arity of a <code>rule</code> node. The result is the  
number of parameter patterns in the first clause of the rule;  
subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <code>rule_clauses(Node)</code> returns
  an empty list, or if the first element of that list is not a syntax
  tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>, <a href="#clause_patterns-1" class="seealso">clause_patterns/1</a>, <a href="#rule-2" class="seealso">rule/2</a>, <a href="#rule_clauses-1" class="seealso">rule_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="generator/1">generator(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="generator-2"> </span>

<p>Creates an abstract generator. The result represents
  "<code>Pattern &lt;- Body</code>".
 </p>
<p><em>See also:</em> <a href="#binary_comp-2" class="seealso">binary_comp/2</a>, <a href="#generator_body-1" class="seealso">generator_body/1</a>, <a href="#generator_pattern-1" class="seealso">generator_pattern/1</a>, <a href="#list_comp-2" class="seealso">list_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="generator_pattern/1">generator_pattern(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="generator_pattern-1"> </span>

<p>Returns the pattern subtree of a <code>generator</code> node.
 </p>
<p><em>See also:</em> <a href="#generator-2" class="seealso">generator/2</a>.</p>
</div></div>
<div class="function">
<h3 id="generator_body/1">generator_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="generator_body-1"> </span>

<p>Returns the body subtree of a <code>generator</code> node.
 </p>
<p><em>See also:</em> <a href="#generator-2" class="seealso">generator/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_generator/1">binary_generator(Pattern::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_generator-2"> </span>

<p>Creates an abstract binary_generator. The result represents
  "<code>Pattern &lt;- Body</code>".
 </p>
<p><em>See also:</em> <a href="#binary_comp-2" class="seealso">binary_comp/2</a>, <a href="#binary_generator_body-1" class="seealso">binary_generator_body/1</a>, <a href="#binary_generator_pattern-1" class="seealso">binary_generator_pattern/1</a>, <a href="#list_comp-2" class="seealso">list_comp/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_generator_pattern/1">binary_generator_pattern(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_generator_pattern-1"> </span>

<p>Returns the pattern subtree of a <code>generator</code> node.
 </p>
<p><em>See also:</em> <a href="#binary_generator-2" class="seealso">binary_generator/2</a>.</p>
</div></div>
<div class="function">
<h3 id="binary_generator_body/1">binary_generator_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="binary_generator_body-1"> </span>

<p>Returns the body subtree of a <code>generator</code> node.
 </p>
<p><em>See also:</em> <a href="#binary_generator-2" class="seealso">binary_generator/2</a>.</p>
</div></div>
<div class="function">
<h3 id="block_expr/1">block_expr(Body::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="block_expr-1"> </span>

<p>Creates an abstract block expression. If <code>Body</code> is
  <code>[B1, ..., Bn]</code>, the result represents "<code>begin
  B1, ..., Bn end</code>".
 </p>
<p><em>See also:</em> <a href="#block_expr_body-1" class="seealso">block_expr_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="block_expr_body/1">block_expr_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="block_expr_body-1"> </span>

<p>Returns the list of body subtrees of a <code>block_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#block_expr-1" class="seealso">block_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="if_expr/1">if_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="if_expr-1"> </span>

<p>Creates an abstract if-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>if
  C1; ...; Cn end</code>". More exactly, if each
  <code>Ci</code> represents "<code>() Gi -&gt;
  Bi</code>", then the result represents "<code>if
  G1 -&gt; B1; ...; Gn -&gt; Bn
  end</code>".
 </p>
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#if_expr_clauses-1" class="seealso">if_expr_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="if_expr_clauses/1">if_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="if_expr_clauses-1"> </span>

<p>Returns the list of clause subtrees of an <code>if_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#if_expr-1" class="seealso">if_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="case_expr/1">case_expr(Argument::syntaxTree(), Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="case_expr-2"> </span>

<p>Creates an abstract case-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>case
  Argument of C1; ...; Cn end</code>". More
  exactly, if each <code>Ci</code> represents "<code>(Pi)
  Gi -&gt; Bi</code>", then the result represents
  "<code>case Argument of P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn end</code>".
 </p>
<p><em>See also:</em> <a href="#case_expr_argument-1" class="seealso">case_expr_argument/1</a>, <a href="#case_expr_clauses-1" class="seealso">case_expr_clauses/1</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#cond_expr-1" class="seealso">cond_expr/1</a>, <a href="#if_expr-1" class="seealso">if_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="case_expr_argument/1">case_expr_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="case_expr_argument-1"> </span>

<p>Returns the argument subtree of a <code>case_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="case_expr_clauses/1">case_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="case_expr_clauses-1"> </span>

<p>Returns the list of clause subtrees of a <code>case_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>.</p>
</div></div>
<div class="function">
<h3 id="cond_expr/1">cond_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="cond_expr-1"> </span>

<p>Creates an abstract cond-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>cond
  C1; ...; Cn end</code>". More exactly, if each
  <code>Ci</code> represents "<code>() Ei -&gt;
  Bi</code>", then the result represents "<code>cond
  E1 -&gt; B1; ...; En -&gt; Bn
  end</code>".
 </p>
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#cond_expr_clauses-1" class="seealso">cond_expr_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="cond_expr_clauses/1">cond_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="cond_expr_clauses-1"> </span>

<p>Returns the list of clause subtrees of a <code>cond_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#cond_expr-1" class="seealso">cond_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="receive_expr/1">receive_expr(Clauses) -&gt; syntaxTree()</h3>


<div class="description"><span id="receive_expr-1"> </span>
<p>Equivalent to <a href="#receive_expr-3" class="seealso">receive_expr(Clauses, none, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="receive_expr/1-1">receive_expr(Clauses::[syntaxTree()], Timeout, Action::[syntaxTree()]) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Timeout = none | syntaxTree()</code></li></ul>
<div class="description"><span id="receive_expr-3"> </span>

<p>Creates an abstract receive-expression. If <code>Timeout</code>
  is <code>none</code>, the result represents "<code>receive
  C1; ...; Cn end</code>" (the <code>Action</code>
  argument is ignored). Otherwise, if <code>Clauses</code> is
  <code>[C1, ..., Cn]</code> and <code>Action</code> is <code>[A1, ...,
  Am]</code>, the result represents "<code>receive C1; ...;
  Cn after Timeout -&gt; A1, ..., Am
  end</code>". More exactly, if each <code>Ci</code> represents
  "<code>(Pi) Gi -&gt; Bi</code>", then the
  result represents "<code>receive P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn ...
  end</code>".</p>
 
  <p>Note that in Erlang, a receive-expression must have at least one
  clause if no timeout part is specified.</p>
 
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#receive_expr-1" class="seealso">receive_expr/1</a>, <a href="#receive_expr_action-1" class="seealso">receive_expr_action/1</a>, <a href="#receive_expr_clauses-1" class="seealso">receive_expr_clauses/1</a>, <a href="#receive_expr_timeout-1" class="seealso">receive_expr_timeout/1</a>.</p>
</div></div>
<div class="function">
<h3 id="receive_expr_clauses/1">receive_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>

<ul class="type">
<li><code>receive_expr</code></li></ul>
<div class="description"><span id="receive_expr_clauses-1"> </span>

<p>Returns the list of clause subtrees of a
  <code>receive_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#receive_expr-3" class="seealso">receive_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="receive_expr_timeout/1">receive_expr_timeout(Node::syntaxTree()) -&gt; Timeout</h3>

<ul class="type">
<li><code>Timeout = none | syntaxTree()</code></li></ul>
<div class="description"><span id="receive_expr_timeout-1"> </span>

<p>Returns the timeout subtree of a <code>receive_expr</code> node,
  if any. If <code>Node</code> represents "<code>receive C1;
  ...; Cn end</code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents "<code>receive
  C1; ...; Cn after Timeout -&gt; ... end</code>",
  <code>Timeout</code> is returned.
 </p>
<p><em>See also:</em> <a href="#receive_expr-3" class="seealso">receive_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="receive_expr_action/1">receive_expr_action(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="receive_expr_action-1"> </span>

<p>Returns the list of action body subtrees of a
  <code>receive_expr</code> node. If <code>Node</code> represents
  "<code>receive C1; ...; Cn end</code>", this is the
  empty list.
 </p>
<p><em>See also:</em> <a href="#receive_expr-3" class="seealso">receive_expr/3</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr/1">try_expr(Body::syntaxTree(), Handlers::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="try_expr-2"> </span>
<p>Equivalent to <a href="#try_expr-3" class="seealso">try_expr(Body, [], Handlers)</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr/1-1">try_expr(Body::syntaxTree(), Clauses::[syntaxTree()], Handlers::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="try_expr-3"> </span>
<p>Equivalent to <a href="#try_expr-4" class="seealso">try_expr(Body, Clauses, Handlers, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="try_after_expr/1">try_after_expr(Body::syntaxTree(), After::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="try_after_expr-2"> </span>
<p>Equivalent to <a href="#try_expr-4" class="seealso">try_expr(Body, [], [], After)</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr/1-2">try_expr(Body::[syntaxTree()], Clauses::[syntaxTree()], Handlers::[syntaxTree()], After::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="try_expr-4"> </span>

<p>Creates an abstract try-expression. If <code>Body</code> is
  <code>[B1, ..., Bn]</code>, <code>Clauses</code> is <code>[C1, ...,
  Cj]</code>, <code>Handlers</code> is <code>[H1, ..., Hk]</code>, and
  <code>After</code> is <code>[A1, ..., Am]</code>, the result
  represents "<code>try B1, ..., Bn of C1;
  ...; Cj catch H1; ...; Hk after
  A1, ..., Am end</code>". More exactly, if each
  <code>Ci</code> represents "<code>(CPi) CGi -&gt;
  CBi</code>", and each <code>Hi</code> represents
  "<code>(HPi) HGi -&gt; HBi</code>", then the
  result represents "<code>try B1, ..., Bn of
  CP1 CG1 -&gt; CB1; ...; CPj
  CGj -&gt; CBj catch HP1 HG1 -&gt;
  HB1; ...; HPk HGk -&gt; HBk after
  A1, ..., Am end</code>"; cf.
  <code>case_expr/2</code>. If <code>Clauses</code> is the empty list,
  the <code>of ...</code> section is left out. If <code>After</code> is
  the empty list, the <code>after ...</code> section is left out. If
  <code>Handlers</code> is the empty list, and <code>After</code> is
  nonempty, the <code>catch ...</code> section is left out.
 </p>
<p><em>See also:</em> <a href="#case_expr-2" class="seealso">case_expr/2</a>, <a href="#class_qualifier-2" class="seealso">class_qualifier/2</a>, <a href="#clause-3" class="seealso">clause/3</a>, <a href="#try_after_expr-2" class="seealso">try_after_expr/2</a>, <a href="#try_expr-2" class="seealso">try_expr/2</a>, <a href="#try_expr-3" class="seealso">try_expr/3</a>, <a href="#try_expr_after-1" class="seealso">try_expr_after/1</a>, <a href="#try_expr_body-1" class="seealso">try_expr_body/1</a>, <a href="#try_expr_clauses-1" class="seealso">try_expr_clauses/1</a>, <a href="#try_expr_handlers-1" class="seealso">try_expr_handlers/1</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr_body/1">try_expr_body(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="try_expr_body-1"> </span>

<p>Returns the list of body subtrees of a <code>try_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#try_expr-4" class="seealso">try_expr/4</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr_clauses/1">try_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="try_expr_clauses-1"> </span>

<p>Returns the list of case-clause subtrees of a
  <code>try_expr</code> node. If <code>Node</code> represents
  "<code>try Body catch H1; ...; Hn
  end</code>", the result is the empty list.
 </p>
<p><em>See also:</em> <a href="#try_expr-4" class="seealso">try_expr/4</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr_handlers/1">try_expr_handlers(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="try_expr_handlers-1"> </span>

<p>Returns the list of handler-clause subtrees of a
  <code>try_expr</code> node.
 </p>
<p><em>See also:</em> <a href="#try_expr-4" class="seealso">try_expr/4</a>.</p>
</div></div>
<div class="function">
<h3 id="try_expr_after/1">try_expr_after(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="try_expr_after-1"> </span>

<p>Returns the list of "after" subtrees of a <code>try_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#try_expr-4" class="seealso">try_expr/4</a>.</p>
</div></div>
<div class="function">
<h3 id="class_qualifier/1">class_qualifier(Class::syntaxTree(), Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="class_qualifier-2"> </span>

<p>Creates an abstract class qualifier. The result represents
  "<code>Class:Body</code>".
 </p>
<p><em>See also:</em> <a href="#class_qualifier_argument-1" class="seealso">class_qualifier_argument/1</a>, <a href="#class_qualifier_body-1" class="seealso">class_qualifier_body/1</a>, <a href="#try_expr-4" class="seealso">try_expr/4</a>.</p>
</div></div>
<div class="function">
<h3 id="class_qualifier_argument/1">class_qualifier_argument(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="class_qualifier_argument-1"> </span>

<p>Returns the argument (the class) subtree of a
  <code>class_qualifier</code> node.
 </p>
<p><em>See also:</em> <a href="#class_qualifier-2" class="seealso">class_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="class_qualifier_body/1">class_qualifier_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="class_qualifier_body-1"> </span>

<p>Returns the body subtree of a <code>class_qualifier</code> node.
 </p>
<p><em>See also:</em> <a href="#class_qualifier-2" class="seealso">class_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="implicit_fun/1">implicit_fun(Name::syntaxTree(), Arity::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="implicit_fun-2"> </span>

<p>Creates an abstract "implicit fun" expression. If
  <code>Arity</code> is <code>none</code>, this is equivalent to
  <code>implicit_fun(Name)</code>, otherwise it is equivalent to
  <code>implicit_fun(arity_qualifier(Name, Arity))</code>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <a href="#implicit_fun-1" class="seealso">implicit_fun/1</a>, <a href="#implicit_fun-3" class="seealso">implicit_fun/3</a>.</p>
</div></div>
<div class="function">
<h3 id="implicit_fun/1-1">implicit_fun(Module::syntaxTree(), Name::syntaxTree(), Arity::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="implicit_fun-3"> </span>

<p>Creates an abstract module-qualified "implicit fun" expression.
  If <code>Module</code> is <code>none</code>, this is equivalent to
  <code>implicit_fun(Name, Arity)</code>, otherwise it is equivalent to
  <code>implicit_fun(module_qualifier(Module, arity_qualifier(Name,
  Arity))</code>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <a href="#implicit_fun-1" class="seealso">implicit_fun/1</a>, <a href="#implicit_fun-2" class="seealso">implicit_fun/2</a>.</p>
</div></div>
<div class="function">
<h3 id="implicit_fun/1-2">implicit_fun(Name::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="implicit_fun-1"> </span>

<p>Creates an abstract "implicit fun" expression. The result
  represents "<code>fun Name</code>". <code>Name</code> should
  represent either <code>F/A</code> or
  <code>M:F/A</code>
 </p>
<p><em>See also:</em> <a href="#arity_qualifier-2" class="seealso">arity_qualifier/2</a>, <a href="#implicit_fun-2" class="seealso">implicit_fun/2</a>, <a href="#implicit_fun-3" class="seealso">implicit_fun/3</a>, <a href="#implicit_fun_name-1" class="seealso">implicit_fun_name/1</a>, <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="implicit_fun_name/1">implicit_fun_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="implicit_fun_name-1"> </span>

<p>Returns the name subtree of an <code>implicit_fun</code> node.</p>
 
  <p>Note: if <code>Node</code> represents "<code>fun
  N/A</code>" or "<code>fun
  M:N/A</code>", then the result is the
  subtree representing "<code>N/A</code>" or
  "<code>M:N/A</code>", respectively.</p>
 
<p><em>See also:</em> <a href="#arity_qualifier-2" class="seealso">arity_qualifier/2</a>, <a href="#implicit_fun-1" class="seealso">implicit_fun/1</a>, <a href="#module_qualifier-2" class="seealso">module_qualifier/2</a>.</p>
</div></div>
<div class="function">
<h3 id="fun_expr/1">fun_expr(Clauses::[syntaxTree()]) -&gt; syntaxTree()</h3>


<div class="description"><span id="fun_expr-1"> </span>

<p>Creates an abstract fun-expression. If <code>Clauses</code> is
  <code>[C1, ..., Cn]</code>, the result represents "<code>fun
  C1; ...; Cn end</code>". More exactly, if each
  <code>Ci</code> represents "<code>(Pi1, ..., Pim)
  Gi -&gt; Bi</code>", then the result represents
  "<code>fun (P11, ..., P1m) G1 -&gt;
  B1; ...; (Pn1, ..., Pnm) Gn -&gt;
  Bn end</code>".
 </p>
<p><em>See also:</em> <a href="#fun_expr_arity-1" class="seealso">fun_expr_arity/1</a>, <a href="#fun_expr_clauses-1" class="seealso">fun_expr_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="fun_expr_clauses/1">fun_expr_clauses(Node::syntaxTree()) -&gt; [syntaxTree()]</h3>


<div class="description"><span id="fun_expr_clauses-1"> </span>

<p>Returns the list of clause subtrees of a <code>fun_expr</code>
  node.
 </p>
<p><em>See also:</em> <a href="#fun_expr-1" class="seealso">fun_expr/1</a>.</p>
</div></div>
<div class="function">
<h3 id="fun_expr_arity/1">fun_expr_arity(Node::syntaxTree()) -&gt; integer()</h3>


<div class="description"><span id="fun_expr_arity-1"> </span>

<p>Returns the arity of a <code>fun_expr</code> node. The result is  
the number of parameter patterns in the first clause of the  
fun-expression; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <code>fun_expr_clauses(Node)</code>
  returns an empty list, or if the first element of that list is not a
  syntax tree <code>C</code> of type <code>clause</code> such that
  <code>clause_patterns(C)</code> is a nonempty list.</p>
 
<p><em>See also:</em> <a href="#clause-3" class="seealso">clause/3</a>, <a href="#clause_patterns-1" class="seealso">clause_patterns/1</a>, <a href="#fun_expr-1" class="seealso">fun_expr/1</a>, <a href="#fun_expr_clauses-1" class="seealso">fun_expr_clauses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="parentheses/1">parentheses(Body::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="parentheses-1"> </span>

<p>Creates an abstract parenthesised expression. The result
  represents "<code>(Body)</code>", independently of the
  context.
 </p>
<p><em>See also:</em> <a href="#parentheses_body-1" class="seealso">parentheses_body/1</a>.</p>
</div></div>
<div class="function">
<h3 id="parentheses_body/1">parentheses_body(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="parentheses_body-1"> </span>

<p>Returns the body subtree of a <code>parentheses</code> node.
 </p>
<p><em>See also:</em> <a href="#parentheses-1" class="seealso">parentheses/1</a>.</p>
</div></div>
<div class="function">
<h3 id="macro/1">macro(Name) -&gt; syntaxTree()</h3>


<div class="description"><span id="macro-1"> </span>
<p>Equivalent to <a href="#macro-2" class="seealso">macro(Name, none)</a>.</p>
</div></div>
<div class="function">
<h3 id="macro/1-1">macro(Name::syntaxTree(), Arguments) -&gt; syntaxTree()</h3>

<ul class="type">
<li><code>Arguments = none | [syntaxTree()]</code></li></ul>
<div class="description"><span id="macro-2"> </span>

<p>Creates an abstract macro application. If <code>Arguments</code>
  is <code>none</code>, the result represents
  "<code>?Name</code>", otherwise, if <code>Arguments</code>
  is <code>[A1, ..., An]</code>, the result represents
  "<code>?Name(A1, ..., An)</code>".</p>
 
  <p>Notes: if <code>Arguments</code> is the empty list, the result
  will thus represent "<code>?Name()</code>", including a pair
  of matching parentheses.</p>
 
  <p>The only syntactical limitation imposed by the preprocessor on the
  arguments to a macro application (viewed as sequences of tokens) is
  that they must be balanced with respect to parentheses, brackets,
  <code>begin ... end</code>, <code>case ... end</code>, etc. The
  <code>text</code> node type can be used to represent arguments which
  are not regular Erlang constructs.</p>
 
<p><em>See also:</em> <a href="#macro-1" class="seealso">macro/1</a>, <a href="#macro_arguments-1" class="seealso">macro_arguments/1</a>, <a href="#macro_name-1" class="seealso">macro_name/1</a>, <a href="#text-1" class="seealso">text/1</a>.</p>
</div></div>
<div class="function">
<h3 id="macro_name/1">macro_name(Node::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="macro_name-1"> </span>

<p>Returns the name subtree of a <code>macro</code> node.
 </p>
<p><em>See also:</em> <a href="#macro-2" class="seealso">macro/2</a>.</p>
</div></div>
<div class="function">
<h3 id="macro_arguments/1">macro_arguments(Node::syntaxTree()) -&gt; none | [syntaxTree()]</h3>


<div class="description"><span id="macro_arguments-1"> </span>

<p>Returns the list of argument subtrees of a <code>macro</code>
  node, if any. If <code>Node</code> represents
  "<code>?Name</code>", <code>none</code> is returned.
  Otherwise, if <code>Node</code> represents
  "<code>?Name(A1, ..., An)</code>",
  <code>[A1, ..., An]</code> is returned.
 </p>
<p><em>See also:</em> <a href="#macro-2" class="seealso">macro/2</a>.</p>
</div></div>
<div class="function">
<h3 id="abstract/1">abstract(Term::term()) -&gt; syntaxTree()</h3>


<div class="description"><span id="abstract-1"> </span>

<p>Returns the syntax tree corresponding to an Erlang term.
  <code>Term</code> must be a literal term, i.e., one that can be
  represented as a source code literal. Thus, it may not contain a
  process identifier, port, reference, binary or function value as a
  subterm. The function recognises printable strings, in order to get a
  compact and readable representation. Evaluation fails with reason
  <code>badarg</code> if <code>Term</code> is not a literal term.
 </p>
<p><em>See also:</em> <a href="#concrete-1" class="seealso">concrete/1</a>, <a href="#is_literal-1" class="seealso">is_literal/1</a>.</p>
</div></div>
<div class="function">
<h3 id="concrete/1">concrete(Node::syntaxTree()) -&gt; term()</h3>


<div class="description"><span id="concrete-1"> </span>

<p>Returns the Erlang term represented by a syntax tree. Evaluation
  fails with reason <code>badarg</code> if <code>Node</code> does not  
represent a literal term.</p>
 
  <p>Note: Currently, the set of syntax trees which have a concrete
  representation is larger than the set of trees which can be built
  using the function <code>abstract/1</code>. An abstract character
  will be concretised as an integer, while <code>abstract/1</code> does
  not at present yield an abstract character for any input. (Use the
  <code>char/1</code> function to explicitly create an abstract
  character.)</p>
 
<p><em>See also:</em> <a href="#abstract-1" class="seealso">abstract/1</a>, <a href="#char-1" class="seealso">char/1</a>, <a href="#is_literal-1" class="seealso">is_literal/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_literal/1">is_literal(Node::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_literal-1"> </span>

<p>Returns <code>true</code> if <code>Node</code> represents a
  literal term, otherwise <code>false</code>. This function returns
  <code>true</code> if and only if the value of
  <code>concrete(Node)</code> is defined.
 </p>
<p><em>See also:</em> <a href="#abstract-1" class="seealso">abstract/1</a>, <a href="#concrete-1" class="seealso">concrete/1</a>.</p>
</div></div>
<div class="function">
<h3 id="revert/1">revert(Tree::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="revert-1"> </span>

<p>Returns an <code>erl_parse</code>-compatible representation of a
  syntax tree, if possible. If <code>Tree</code> represents a
  well-formed Erlang program or expression, the conversion should work
  without problems. Typically, <code>is_tree/1</code> yields
  <code>true</code> if conversion failed (i.e., the result is still an
  abstract syntax tree), and <code>false</code> otherwise.</p>
 
  <p>The <code>is_tree/1</code> test is not completely foolproof. For a
  few special node types (e.g. <code>arity_qualifier</code>), if such a
  node occurs in a context where it is not expected, it will be left
  unchanged as a non-reverted subtree of the result. This can only
  happen if <code>Tree</code> does not actually represent legal Erlang
  code.</p>
 
<p><em>See also:</em> <a href="../stdlib/erl_parse.html" class="seealso">erl_parse(3)</a>, <a href="#revert_forms-1" class="seealso">revert_forms/1</a>.</p>
</div></div>
<div class="function">
<h3 id="revert_forms/1">revert_forms(L::Forms) -&gt; [erl_parse()]</h3>

<ul class="type">
<li><code>Forms = syntaxTree() | [syntaxTree()]</code></li></ul>
<div class="description"><span id="revert_forms-1"> </span>

<p>Reverts a sequence of Erlang source code forms. The sequence can
  be given either as a <code>form_list</code> syntax tree (possibly
  nested), or as a list of "program form" syntax trees. If successful,
  the corresponding flat list of <code>erl_parse</code>-compatible
  syntax trees is returned (cf. <code>revert/1</code>). If some program
  form could not be reverted, <code>{error, Form}</code> is thrown.
  Standalone comments in the form sequence are discarded.
 </p>
<p><em>See also:</em> <a href="#form_list-1" class="seealso">form_list/1</a>, <a href="#is_form-1" class="seealso">is_form/1</a>, <a href="#revert-1" class="seealso">revert/1</a>.</p>
</div></div>
<div class="function">
<h3 id="subtrees/1">subtrees(Node::syntaxTree()) -&gt; [[syntaxTree()]]</h3>


<div class="description"><span id="subtrees-1"> </span>

<p>Returns the grouped list of all subtrees of a syntax tree. If
  <code>Node</code> is a leaf node (cf. <code>is_leaf/1</code>), this
  is the empty list, otherwise the result is always a nonempty list,
  containing the lists of subtrees of <code>Node</code>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p>
 
  <p>Depending on the type of <code>Node</code>, the size of some
  groups may be variable (e.g., the group consisting of all the
  elements of a tuple), while others always contain the same number of
  elements - usually exactly one (e.g., the group containing the
  argument expression of a case-expression). Note, however, that the
  exact structure of the returned list (for a given node type) should
  in general not be depended upon, since it might be subject to change
  without notice.</p>
 
  <p>The function <code>subtrees/1</code> and the constructor functions
  <code>make_tree/2</code> and <code>update_tree/2</code> can be a
  great help if one wants to traverse a syntax tree, visiting all its
  subtrees, but treat nodes of the tree in a uniform way in most or all
  cases. Using these functions makes this simple, and also assures that
  your code is not overly sensitive to extensions of the syntax tree
  data type, because any node types not explicitly handled by your code
  can be left to a default case.</p>
 
  <p>For example:
  </p><pre class="sh_erlang">
    postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &lt;- Group]
                                 || Group &lt;- List])
          end).
  </pre><p>
  maps the function <code>F</code> on <code>Tree</code> and all its
  subtrees, doing a post-order traversal of the syntax tree. (Note the
  use of <code>update_tree/2</code> to preserve node attributes.) For a
  simple function like:
  </p><pre class="sh_erlang">
    f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.
  </pre><p>
  the call <code>postorder(fun f/1, Tree)</code> will yield a new
  representation of <code>Tree</code> in which all atom names have been
  extended with the prefix "a_", but nothing else (including comments,
  annotations and line numbers) has been changed.</p>
 
<p><em>See also:</em> <a href="#copy_attrs-2" class="seealso">copy_attrs/2</a>, <a href="#is_leaf-1" class="seealso">is_leaf/1</a>, <a href="#make_tree-2" class="seealso">make_tree/2</a>, <a href="#type-1" class="seealso">type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="update_tree/1">update_tree(Node::syntaxTree(), Groups::[[syntaxTree()]]) -&gt; syntaxTree()</h3>


<div class="description"><span id="update_tree-2"> </span>

<p>Creates a syntax tree with the same type and attributes as the
  given tree. This is equivalent to <code>copy_attrs(Node,
  make_tree(type(Node), Groups))</code>.
 </p>
<p><em>See also:</em> <a href="#copy_attrs-2" class="seealso">copy_attrs/2</a>, <a href="#make_tree-2" class="seealso">make_tree/2</a>, <a href="#type-1" class="seealso">type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="make_tree/1">make_tree(Type::atom(), Groups::[[syntaxTree()]]) -&gt; syntaxTree()</h3>


<div class="description"><span id="make_tree-2"> </span>

<p>Creates a syntax tree with the given type and subtrees.
  <code>Type</code> must be a node type name (cf. <code>type/1</code>)
  that does not denote a leaf node type (cf. <code>is_leaf/1</code>).
  <code>Groups</code> must be a <em>nonempty</em> list of groups of
  syntax trees, representing the subtrees of a node of the given type,
  in left-to-right order as they would occur in the printed program
  text, grouped by category as done by <code>subtrees/1</code>.</p>
 
  <p>The result of <code>copy_attrs(Node, make_tree(type(Node),
  subtrees(Node)))</code> (cf. <code>update_tree/2</code>) represents
  the same source code text as the original <code>Node</code>, assuming
  that <code>subtrees(Node)</code> yields a nonempty list. However, it
  does not necessarily have the same data representation as
  <code>Node</code>.</p>
 
<p><em>See also:</em> <a href="#copy_attrs-2" class="seealso">copy_attrs/2</a>, <a href="#is_leaf-1" class="seealso">is_leaf/1</a>, <a href="#subtrees-1" class="seealso">subtrees/1</a>, <a href="#type-1" class="seealso">type/1</a>, <a href="#update_tree-2" class="seealso">update_tree/2</a>.</p>
</div></div>
<div class="function">
<h3 id="meta/1">meta(Tree::syntaxTree()) -&gt; syntaxTree()</h3>


<div class="description"><span id="meta-1"> </span>

<p>Creates a meta-representation of a syntax tree. The result
  represents an Erlang expression "<code>MetaTree</code>"
  which, if evaluated, will yield a new syntax tree representing the
  same source code text as <code>Tree</code> (although the actual data
  representation may be different). The expression represented by
  <code>MetaTree</code> is <em>implementation independent</em> with
  regard to the data structures used by the abstract syntax tree
  implementation. Comments attached to nodes of <code>Tree</code> will  
be preserved, but other attributes are lost.</p>
 
  <p>Any node in <code>Tree</code> whose node type is
  <code>variable</code> (cf. <code>type/1</code>), and whose list of
  annotations (cf. <code>get_ann/1</code>) contains the atom
  <code>meta_var</code>, will remain unchanged in the resulting tree,
  except that exactly one occurrence of <code>meta_var</code> is
  removed from its annotation list.</p>
 
  <p>The main use of the function <code>meta/1</code> is to transform a
  data structure <code>Tree</code>, which represents a piece of program
  code, into a form that is <em>representation independent when
  printed</em>. E.g., suppose <code>Tree</code> represents a variable
  named "V". Then (assuming a function <code>print/1</code> for
  printing syntax trees), evaluating <code>print(abstract(Tree))</code>
  - simply using <code>abstract/1</code> to map the actual data
  structure onto a syntax tree representation - would output a string
  that might look something like "<code>{tree, variable, ..., "V",
  ...}</code>", which is obviously dependent on the implementation of
  the abstract syntax trees. This could e.g. be useful for caching a
  syntax tree in a file. However, in some situations like in a program
  generator generator (with two "generator"), it may be unacceptable.
  Using <code>print(meta(Tree))</code> instead would output a
  <em>representation independent</em> syntax tree generating
  expression; in the above case, something like
  "<code>erl_syntax:variable("V")</code>".</p>
 
<p><em>See also:</em> <a href="#abstract-1" class="seealso">abstract/1</a>, <a href="#get_ann-1" class="seealso">get_ann/1</a>, <a href="#type-1" class="seealso">type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="tree/1">tree(Type) -&gt; syntaxTree()</h3>


<div class="description"><span id="tree-1"> </span>
<p>Equivalent to <a href="#tree-2" class="seealso">tree(Type, [])</a>.</p>
</div></div>
<div class="function">
<h3 id="tree/1-1">tree(Type::atom(), Data::term()) -&gt; syntaxTree()</h3>


<div class="description"><span id="tree-2"> </span>

<p><em>For special purposes only</em>. Creates an abstract syntax
  tree node with type tag <code>Type</code> and associated data
  <code>Data</code>.</p>
 
  <p>This function and the related <code>is_tree/1</code> and
  <code>data/1</code> provide a uniform way to extend the set of
  <code>erl_parse</code> node types. The associated data is any term,
  whose format may depend on the type tag.</p>
 
  <p><em>Notes:</em>
  </p><list>
   <item><p>Any nodes created outside of this module must have type tags
       distinct from those currently defined by this module; see
       <code>type/1</code> for a complete list.</p></item>
   <item><p>The type tag of a syntax tree node may also be used
       as a primary tag by the <code>erl_parse</code> representation;
       in that case, the selector functions for that node type
       <em>must</em> handle both the abstract syntax tree and the
       <code>erl_parse</code> form. The function <code>type(T)</code>
       should return the correct type tag regardless of the
       representation of <code>T</code>, so that the user sees no
       difference between <code>erl_syntax</code> and
       <code>erl_parse</code> nodes.</p></item>
  </list>
<p><em>See also:</em> <a href="#data-1" class="seealso">data/1</a>, <a href="#is_tree-1" class="seealso">is_tree/1</a>, <a href="#type-1" class="seealso">type/1</a>.</p>
</div></div>
<div class="function">
<h3 id="is_tree/1">is_tree(Tree::syntaxTree()) -&gt; boolean()</h3>


<div class="description"><span id="is_tree-1"> </span>

<p><em>For special purposes only</em>. Returns <code>true</code> if
  <code>Tree</code> is an abstract syntax tree and <code>false</code>  
otherwise.</p>
 
  <p><em>Note</em>: this function yields <code>false</code> for all
  "old-style" <code>erl_parse</code>-compatible "parse trees".</p>
 
<p><em>See also:</em> <a href="#tree-2" class="seealso">tree/2</a>.</p>
</div></div>
<div class="function">
<h3 id="data/1">data(Tree::syntaxTree()) -&gt; term()</h3>


<div class="description"><span id="data-1"> </span>

<p><em>For special purposes only</em>. Returns the associated data
  of a syntax tree node. Evaluation fails with reason
  <code>badarg</code> if <code>is_tree(Node)</code> does not yield
  <code>true</code>.
 </p>
<p><em>See also:</em> <a href="#tree-2" class="seealso">tree/2</a>.</p>
</div></div></div>

<authors>

<aname>Richard Carlsson</aname>
<email>richardc@it.uu.se</email></authors>
      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        <ul id="funs"><li><a href="#type/1">type/1</a></li><li><a href="#is_leaf/1">is_leaf/1</a></li><li><a href="#is_form/1">is_form/1</a></li><li><a href="#get_pos/1">get_pos/1</a></li><li><a href="#set_pos/1">set_pos/1</a></li><li><a href="#copy_pos/1">copy_pos/1</a></li><li><a href="#get_precomments/1">get_precomments/1</a></li><li><a href="#set_precomments/1">set_precomments/1</a></li><li><a href="#add_precomments/1">add_precomments/1</a></li><li><a href="#get_postcomments/1">get_postcomments/1</a></li><li><a href="#set_postcomments/1">set_postcomments/1</a></li><li><a href="#add_postcomments/1">add_postcomments/1</a></li><li><a href="#has_comments/1">has_comments/1</a></li><li><a href="#remove_comments/1">remove_comments/1</a></li><li><a href="#copy_comments/1">copy_comments/1</a></li><li><a href="#join_comments/1">join_comments/1</a></li><li><a href="#get_ann/1">get_ann/1</a></li><li><a href="#set_ann/1">set_ann/1</a></li><li><a href="#add_ann/1">add_ann/1</a></li><li><a href="#copy_ann/1">copy_ann/1</a></li><li><a href="#get_attrs/1">get_attrs/1</a></li><li><a href="#set_attrs/1">set_attrs/1</a></li><li><a href="#copy_attrs/1">copy_attrs/1</a></li><li><a href="#comment/1">comment/1</a></li><li><a href="#comment/2">comment/2</a></li><li><a href="#comment_text/1">comment_text/1</a></li><li><a href="#comment_padding/1">comment_padding/1</a></li><li><a href="#form_list/1">form_list/1</a></li><li><a href="#form_list_elements/1">form_list_elements/1</a></li><li><a href="#flatten_form_list/1">flatten_form_list/1</a></li><li><a href="#text/1">text/1</a></li><li><a href="#text_string/1">text_string/1</a></li><li><a href="#variable/1">variable/1</a></li><li><a href="#variable_name/1">variable_name/1</a></li><li><a href="#variable_literal/1">variable_literal/1</a></li><li><a href="#underscore/0">underscore/0</a></li><li><a href="#integer/1">integer/1</a></li><li><a href="#is_integer/1">is_integer/1</a></li><li><a href="#integer_value/1">integer_value/1</a></li><li><a href="#integer_literal/1">integer_literal/1</a></li><li><a href="#float/1">float/1</a></li><li><a href="#float_value/1">float_value/1</a></li><li><a href="#float_literal/1">float_literal/1</a></li><li><a href="#char/1">char/1</a></li><li><a href="#is_char/1">is_char/1</a></li><li><a href="#char_value/1">char_value/1</a></li><li><a href="#char_literal/1">char_literal/1</a></li><li><a href="#string/1">string/1</a></li><li><a href="#is_string/1">is_string/1</a></li><li><a href="#string_value/1">string_value/1</a></li><li><a href="#string_literal/1">string_literal/1</a></li><li><a href="#atom/1">atom/1</a></li><li><a href="#is_atom/1">is_atom/1</a></li><li><a href="#atom_value/1">atom_value/1</a></li><li><a href="#atom_name/1">atom_name/1</a></li><li><a href="#atom_literal/1">atom_literal/1</a></li><li><a href="#tuple/1">tuple/1</a></li><li><a href="#tuple_elements/1">tuple_elements/1</a></li><li><a href="#tuple_size/1">tuple_size/1</a></li><li><a href="#list/1">list/1</a></li><li><a href="#list/2">list/2</a></li><li><a href="#nil/0">nil/0</a></li><li><a href="#list_prefix/1">list_prefix/1</a></li><li><a href="#list_suffix/1">list_suffix/1</a></li><li><a href="#cons/1">cons/1</a></li><li><a href="#list_head/1">list_head/1</a></li><li><a href="#list_tail/1">list_tail/1</a></li><li><a href="#is_list_skeleton/1">is_list_skeleton/1</a></li><li><a href="#is_proper_list/1">is_proper_list/1</a></li><li><a href="#list_elements/1">list_elements/1</a></li><li><a href="#list_length/1">list_length/1</a></li><li><a href="#normalize_list/1">normalize_list/1</a></li><li><a href="#compact_list/1">compact_list/1</a></li><li><a href="#binary/1">binary/1</a></li><li><a href="#binary_fields/1">binary_fields/1</a></li><li><a href="#binary_field/1">binary_field/1</a></li><li><a href="#binary_field/1-1">binary_field/1-1</a></li><li><a href="#binary_field/1-2">binary_field/1-2</a></li><li><a href="#binary_field_body/1">binary_field_body/1</a></li><li><a href="#binary_field_types/1">binary_field_types/1</a></li><li><a href="#binary_field_size/1">binary_field_size/1</a></li><li><a href="#size_qualifier/1">size_qualifier/1</a></li><li><a href="#size_qualifier_body/1">size_qualifier_body/1</a></li><li><a href="#size_qualifier_argument/1">size_qualifier_argument/1</a></li><li><a href="#error_marker/1">error_marker/1</a></li><li><a href="#error_marker_info/1">error_marker_info/1</a></li><li><a href="#warning_marker/1">warning_marker/1</a></li><li><a href="#warning_marker_info/1">warning_marker_info/1</a></li><li><a href="#eof_marker/0">eof_marker/0</a></li><li><a href="#attribute/1">attribute/1</a></li><li><a href="#attribute/1-1">attribute/1-1</a></li><li><a href="#attribute_name/1">attribute_name/1</a></li><li><a href="#attribute_arguments/1">attribute_arguments/1</a></li><li><a href="#arity_qualifier/1">arity_qualifier/1</a></li><li><a href="#arity_qualifier_body/1">arity_qualifier_body/1</a></li><li><a href="#arity_qualifier_argument/1">arity_qualifier_argument/1</a></li><li><a href="#module_qualifier/1">module_qualifier/1</a></li><li><a href="#module_qualifier_argument/1">module_qualifier_argument/1</a></li><li><a href="#module_qualifier_body/1">module_qualifier_body/1</a></li><li><a href="#qualified_name/1">qualified_name/1</a></li><li><a href="#qualified_name_segments/1">qualified_name_segments/1</a></li><li><a href="#function/1">function/1</a></li><li><a href="#function_name/1">function_name/1</a></li><li><a href="#function_clauses/1">function_clauses/1</a></li><li><a href="#function_arity/1">function_arity/1</a></li><li><a href="#clause/2">clause/2</a></li><li><a href="#clause/1">clause/1</a></li><li><a href="#clause_patterns/1">clause_patterns/1</a></li><li><a href="#clause_guard/1">clause_guard/1</a></li><li><a href="#clause_body/1">clause_body/1</a></li><li><a href="#disjunction/1">disjunction/1</a></li><li><a href="#disjunction_body/1">disjunction_body/1</a></li><li><a href="#conjunction/1">conjunction/1</a></li><li><a href="#conjunction_body/1">conjunction_body/1</a></li><li><a href="#catch_expr/1">catch_expr/1</a></li><li><a href="#catch_expr_body/1">catch_expr_body/1</a></li><li><a href="#match_expr/1">match_expr/1</a></li><li><a href="#match_expr_pattern/1">match_expr_pattern/1</a></li><li><a href="#match_expr_body/1">match_expr_body/1</a></li><li><a href="#operator/1">operator/1</a></li><li><a href="#operator_name/1">operator_name/1</a></li><li><a href="#operator_literal/1">operator_literal/1</a></li><li><a href="#infix_expr/1">infix_expr/1</a></li><li><a href="#infix_expr_left/1">infix_expr_left/1</a></li><li><a href="#infix_expr_operator/1">infix_expr_operator/1</a></li><li><a href="#infix_expr_right/1">infix_expr_right/1</a></li><li><a href="#prefix_expr/1">prefix_expr/1</a></li><li><a href="#prefix_expr_operator/1">prefix_expr_operator/1</a></li><li><a href="#prefix_expr_argument/1">prefix_expr_argument/1</a></li><li><a href="#record_field/1">record_field/1</a></li><li><a href="#record_field/1-1">record_field/1-1</a></li><li><a href="#record_field_name/1">record_field_name/1</a></li><li><a href="#record_field_value/1">record_field_value/1</a></li><li><a href="#record_index_expr/1">record_index_expr/1</a></li><li><a href="#record_index_expr_type/1">record_index_expr_type/1</a></li><li><a href="#record_index_expr_field/1">record_index_expr_field/1</a></li><li><a href="#record_access/2">record_access/2</a></li><li><a href="#record_access/1">record_access/1</a></li><li><a href="#record_access_argument/1">record_access_argument/1</a></li><li><a href="#record_access_type/1">record_access_type/1</a></li><li><a href="#record_access_field/1">record_access_field/1</a></li><li><a href="#record_expr/2">record_expr/2</a></li><li><a href="#record_expr/2-1">record_expr/2-1</a></li><li><a href="#record_expr_argument/1">record_expr_argument/1</a></li><li><a href="#record_expr_type/1">record_expr_type/1</a></li><li><a href="#record_expr_fields/1">record_expr_fields/1</a></li><li><a href="#application/2">application/2</a></li><li><a href="#application/1">application/1</a></li><li><a href="#application_operator/1">application_operator/1</a></li><li><a href="#application_arguments/1">application_arguments/1</a></li><li><a href="#list_comp/1">list_comp/1</a></li><li><a href="#list_comp_template/1">list_comp_template/1</a></li><li><a href="#list_comp_body/1">list_comp_body/1</a></li><li><a href="#binary_comp/1">binary_comp/1</a></li><li><a href="#binary_comp_template/1">binary_comp_template/1</a></li><li><a href="#binary_comp_body/1">binary_comp_body/1</a></li><li><a href="#query_expr/1">query_expr/1</a></li><li><a href="#query_expr_body/1">query_expr_body/1</a></li><li><a href="#rule/1">rule/1</a></li><li><a href="#rule_name/1">rule_name/1</a></li><li><a href="#rule_clauses/1">rule_clauses/1</a></li><li><a href="#rule_arity/1">rule_arity/1</a></li><li><a href="#generator/1">generator/1</a></li><li><a href="#generator_pattern/1">generator_pattern/1</a></li><li><a href="#generator_body/1">generator_body/1</a></li><li><a href="#binary_generator/1">binary_generator/1</a></li><li><a href="#binary_generator_pattern/1">binary_generator_pattern/1</a></li><li><a href="#binary_generator_body/1">binary_generator_body/1</a></li><li><a href="#block_expr/1">block_expr/1</a></li><li><a href="#block_expr_body/1">block_expr_body/1</a></li><li><a href="#if_expr/1">if_expr/1</a></li><li><a href="#if_expr_clauses/1">if_expr_clauses/1</a></li><li><a href="#case_expr/1">case_expr/1</a></li><li><a href="#case_expr_argument/1">case_expr_argument/1</a></li><li><a href="#case_expr_clauses/1">case_expr_clauses/1</a></li><li><a href="#cond_expr/1">cond_expr/1</a></li><li><a href="#cond_expr_clauses/1">cond_expr_clauses/1</a></li><li><a href="#receive_expr/1">receive_expr/1</a></li><li><a href="#receive_expr/1-1">receive_expr/1-1</a></li><li><a href="#receive_expr_clauses/1">receive_expr_clauses/1</a></li><li><a href="#receive_expr_timeout/1">receive_expr_timeout/1</a></li><li><a href="#receive_expr_action/1">receive_expr_action/1</a></li><li><a href="#try_expr/1">try_expr/1</a></li><li><a href="#try_expr/1-1">try_expr/1-1</a></li><li><a href="#try_after_expr/1">try_after_expr/1</a></li><li><a href="#try_expr/1-2">try_expr/1-2</a></li><li><a href="#try_expr_body/1">try_expr_body/1</a></li><li><a href="#try_expr_clauses/1">try_expr_clauses/1</a></li><li><a href="#try_expr_handlers/1">try_expr_handlers/1</a></li><li><a href="#try_expr_after/1">try_expr_after/1</a></li><li><a href="#class_qualifier/1">class_qualifier/1</a></li><li><a href="#class_qualifier_argument/1">class_qualifier_argument/1</a></li><li><a href="#class_qualifier_body/1">class_qualifier_body/1</a></li><li><a href="#implicit_fun/1">implicit_fun/1</a></li><li><a href="#implicit_fun/1-1">implicit_fun/1-1</a></li><li><a href="#implicit_fun/1-2">implicit_fun/1-2</a></li><li><a href="#implicit_fun_name/1">implicit_fun_name/1</a></li><li><a href="#fun_expr/1">fun_expr/1</a></li><li><a href="#fun_expr_clauses/1">fun_expr_clauses/1</a></li><li><a href="#fun_expr_arity/1">fun_expr_arity/1</a></li><li><a href="#parentheses/1">parentheses/1</a></li><li><a href="#parentheses_body/1">parentheses_body/1</a></li><li><a href="#macro/1">macro/1</a></li><li><a href="#macro/1-1">macro/1-1</a></li><li><a href="#macro_name/1">macro_name/1</a></li><li><a href="#macro_arguments/1">macro_arguments/1</a></li><li><a href="#abstract/1">abstract/1</a></li><li><a href="#concrete/1">concrete/1</a></li><li><a href="#is_literal/1">is_literal/1</a></li><li><a href="#revert/1">revert/1</a></li><li><a href="#revert_forms/1">revert_forms/1</a></li><li><a href="#subtrees/1">subtrees/1</a></li><li><a href="#update_tree/1">update_tree/1</a></li><li><a href="#make_tree/1">make_tree/1</a></li><li><a href="#meta/1">meta/1</a></li><li><a href="#tree/1">tree/1</a></li><li><a href="#tree/1-1">tree/1-1</a></li><li><a href="#is_tree/1">is_tree/1</a></li><li><a href="#data/1">data/1</a></li></ul>
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59760-14']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script');
        ga.src = ('https:' == document.location.protocol ?
          'https://ssl' : 'http://www') +
          '.google-analytics.com/ga.js';
        ga.setAttribute('async', 'true');
        document.documentElement.firstChild.appendChild(ga);
      })();
    </script>
  </body>
</html>

