<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="latin1" />
    <title>erl_ddll (kernel) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml"
          title="erldocs" href="/search.xml">
    <link type="text/css" rel="stylesheet" href="../erldocs.css" />
  </head>
  <body>

    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off"
             placeholder="press TAB to search" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>erl_ddll</h1>
  <h2 class="modsummary">Dynamic Driver Loader and Linker</h2>
  <div class="description">
    <p>The <code>erl_ddll</code> module provides an interface for loading
      and unloading <em>erlang linked in drivers</em> in runtime.</p>
    <div class="note"><h2>Note!</h2>
      <p>This is a large reference document. For casual use of the
        module, as well as for most real world applications, the
        descriptions of the functions <a href="#load/2" class="seealso">load/2</a> and <a href="#unload/1" class="seealso">unload/1</a> are enough to get
        going. </p>
    </div>
    <p>The driver should be provided as a dynamically linked library
      in a object code format specific for the platform in use,
      i. e. <code>.so</code> files on most Unix systems and <code>.ddl</code>
      files on windows. An erlang linked in driver has to provide
      specific interfaces to the emulator, so this module is not
      designed for loading arbitrary dynamic libraries. For further
      information about erlang drivers, refer to the ERTS reference
      manual section <a href="../erts/erl_driver.html" class="seealso">erl_driver</a>.</p>
    <span id="users"> </span>
    <p>When describing a set of functions, (i.e. a module, a part of a
      module or an application) executing in a process and wanting to
      use a ddll-driver, we use the term <em>user</em>. There can be
      several users in one process (different modules needing the same
      driver) and several processes running the same code, making up
      several <em>users</em> of a driver. In the basic scenario, each
      user loads the driver before starting to use it and unloads the
      driver when done. The reference counting keeps track of
      processes as well as the number of loads by each process, so that
      the driver will only be unloaded when no one wants it
      (it has no user). The driver also keeps track of ports that are
      opened towards it, so that one can delay unloading until all
      ports are closed or kill all ports using the driver when it is
      unloaded.  </p>
    <span id="scenarios"> </span>
    <p>The interface supports two basic scenarios of loading and
      unloading. Each scenario can also have the option of either
      killing ports when the driver is unloading, or waiting for the
      ports to close themselves. The scenarios are:</p>
    <taglist>
      <dt><em>Load and unload on a "when needed basis"</em></dt>
      <item>
        <p>This (most common) scenario simply supports that each
          <a href="#users" class="seealso">user</a> of the driver loads
          it when it is needed and unloads it when the <a href="#users" class="seealso">user</a> no longer have any use for
          it. The driver is always reference counted and as long as a
          process keeping the driver loaded is still alive, the driver
          is present in the system.</p>
        <p>Each <a href="#users" class="seealso">user</a> of the driver
          use <em>literally</em> the same pathname for the driver when
          demanding load, but the <a href="#users" class="seealso">users</a> are not really concerned
          with if the driver is already loaded from the filesystem or
          if the object code has to be loaded from filesystem.</p>
        <p>Two pairs of functions support this scenario:</p>
        <taglist>
          <dt><em>load/2 and unload/1</em></dt>
          <item>
            <p>When using the <code>load/unload</code> interfaces, the
              driver will not <em>actually</em> get unloaded until the
              <em>last port</em> using the driver is closed. The function
              <code>unload/1</code> can return immediately, as the <a href="#users" class="seealso">users</a> are not really concerned
              with when the actual unloading occurs. The
              driver will actually get unloaded when no one needs it any longer.</p>
            <p>If a process having the driver loaded dies, it will have
              the same effect as if unloading was done. </p>
            <p>When loading, the function <code>load/2</code> returns
              <code>ok</code> as soon as there is any instance of the driver
              present, so that if a driver is waiting to get unloaded
              (due to open ports), it will simply change state to no
              longer need unloading.</p>
          </item>
          <dt><em>load_driver/2 and unload_driver/1</em></dt>
          <item>
            <p>These interfaces is intended to be used when it is considered an
              error that ports are open towards a driver that no <a href="#users" class="seealso">user</a>
              has loaded. The ports still open when the
              last <a href="#users" class="seealso">user</a> calls
              <code>unload_driver/1</code> or when the last process having the
              driver loaded dies, will get killed with reason
              <code>driver_unloaded</code>.</p>
            <p>The function names <code>load_driver</code> and
              <code>unload_driver</code> are kept for backward
              compatibility.</p>
          </item>
        </taglist>
      </item>
      <dt><em>Loading and reloading for code replacement</em></dt>
      <item>
        <p>This scenario occurs when the driver code might need
          replacement during operation of the Erlang
          emulator. Implementing driver code replacement is somewhat
          more tedious than beam code replacement, as one driver
          cannot be loaded as both "old" and "new" code. All <a href="#users" class="seealso">users</a> of a driver must have it
          closed (no open ports) before the old code can be unloaded
          and the new code can be loaded.</p>
        <p>The actual unloading/loading is done as one atomic
          operation, blocking all processes in the system from using
          the driver concerned while in progress.</p>
        <p>The preferred way to do driver code replacement is to let
          <em>one single process</em> keep track of the driver. When
          the process start, the driver is loaded. When replacement
          is required, the driver is reloaded. Unload is probably never
          done, or done when the process exits. If more than one <a href="#users" class="seealso">user</a> has a driver loaded when code
          replacement is demanded, the replacement cannot occur until
          the last "other" <a href="#users" class="seealso">user</a> has
          unloaded the driver.</p>
        <p>Demanding reload when a reload is already in progress is
          always an error. Using the high level functions, it is also
          an error to demand reloading when more than one <a href="#users" class="seealso">user</a> has the driver loaded. To
          simplify driver replacement, avoid designing your system so
          that more than than one <a href="#users" class="seealso">user</a> has the driver loaded.</p>
        <p>The two functions for reloading drivers should be used
          together with corresponding load functions, to support the two
          different behaviors concerning open ports:</p>
        <taglist>
          <dt><em>load/2 and reload/2</em></dt>
          <item>
            <p>This pair of functions is used when reloading should be
              done after the last open port towards the driver is
              closed.</p>
            <p>As <code>reload/2</code> actually waits for the reloading to
              occur, a misbehaving process keeping open ports towards
              the driver (or keeping the driver loaded) might cause
              infinite waiting for reload. Timeouts has to be provided
              outside of the process demanding the reload or by using
              the low-level interface <a href="#try_load/3" class="seealso">try_load/3</a> in combination
              with driver monitors (see below).</p>
          </item>
          <dt><em>load_driver/2 and reload_driver/2</em></dt>
          <item>
            <p>This pair of functions are used when open ports towards
              the driver should be killed with reason
              <code>driver_unloaded</code> to allow for new driver code to
              get loaded.</p>
            <p>If, however, another process has the driver loaded,
              calling <code>reload_driver</code> returns the error code
              <code>pending_process</code>. As stated earlier,
              the recommended design is to not allow other <a href="#users" class="seealso">users</a> than the "driver
              reloader" to actually demand loading of the concerned
              driver.</p>
          </item>
        </taglist>
      </item>
    </taglist>
  </div>
  <datatypes>
    <datatype>
      <name name="driver" />
    </datatype>
    <datatype>
      <name name="path" />
    </datatype>
  </datatypes>
  <div class="functions"><h4>Functions</h4><hr  />
    <div class="function">
      <h3 id="demonitor/1">demonitor(MonitorRef) -&gt; ok</h3>
      
      <ul class="type">
        <li><code>MonitorRef = reference()</code></li>
      </ul>
      <div class="description">
        <p>Removes a driver monitor in much the same way as 
          <a href="../erts/erlang.html#erlangdemonitor/1" class="seealso">erlang:demonitor/1</a> does with process
          monitors. See <a href="#monitor/2" class="seealso">monitor/2</a>, <a href="#try_load/3" class="seealso">try_load/3</a> and <a href="#try_unload/2" class="seealso">try_unload/2</a> for details
          about how to create driver monitors.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameter is not a reference().  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="info/0">info() -&gt; AllInfoList</h3>
      
      <div class="description">
        <p>Returns a list of tuples <code>{<anno>DriverName</anno>, <anno>InfoList</anno>}</code>, where
          <code><anno>InfoList</anno></code> is the result of calling <a href="#info/1" class="seealso">info/1</a> for that
          <code><anno>DriverName</anno></code>. Only dynamically linked in drivers are
          included in the list.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="info/1">info(Name) -&gt; InfoList</h3>
      
      <div class="description">
        <p>Returns a list of tuples <code>{<anno>Tag</anno>, <anno>Value</anno>}</code>, where
          <code><anno>Tag</anno></code> is the information item and <code><anno>Value</anno></code> is the result
          of calling <a href="#info/2" class="seealso">info/2</a> with this driver name and
          this tag. The result being a tuple list containing all
          information available about a driver. </p>
        <p>The different tags that will appear in the list are:</p>
        <list type="bulleted">
          <item>processes</item>
          <item>driver_options</item>
          <item>port_count</item>
          <item>linked_in_driver</item>
          <item>permanent</item>
          <item>awaiting_load</item>
          <item>awaiting_unload</item>
        </list>
        <p>For a detailed description of each value, please read the
          description of <a href="#info/2" class="seealso">info/2</a> below.</p>
        <p>The function throws a <code>badarg</code> exception if the driver
          is not present in the system.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="info/2">info(Name, Tag) -&gt; Value</h3>
      
      <ul class="type">
        <li><code>Name = string() | atom()</code></li>
        <li><code>Tag = processes | driver_options | port_count | linked_in_driver | permanent | awaiting_load | awaiting_unload</code></li>
        <li><code>Value = term()</code></li>
      </ul>
      <div class="description">
        <p>This function returns specific information about one aspect
          of a driver. The <code>Tag</code> parameter specifies which aspect
          to get information about. The <code>Value</code> return differs
          between different tags:</p>
        <taglist>
          <dt><em>processes</em></dt>
          <item>
            <p>Return all processes containing <a href="#users" class="seealso">users</a> of the specific drivers
              as a list of tuples <code>{pid(),int()}</code>, where the
              <code>int()</code> denotes the number of users in the process
              <code>pid()</code>.</p>
          </item>
          <dt><em>driver_options</em></dt>
          <item>
            <p>Return a list of the driver options provided when
              loading, as well as any options set by the driver itself
              during initialization. The currently only valid option
              being <code>kill_ports</code>.</p>
          </item>
          <dt><em>port_count</em></dt>
          <item>
            <p>Return the number of ports (an <code>int()</code>) using the driver.</p>
          </item>
          <dt><em>linked_in_driver</em></dt>
          <item>
            <p>Return a <code>bool()</code>, being <code>true</code> if the driver is a
              statically linked in one and <code>false</code> otherwise.</p>
          </item>
          <dt><em>permanent</em></dt>
          <item>
            <p>Return a <code>bool()</code>, being <code>true</code> if the driver has made
              itself permanent (and is <em>not</em> a statically
              linked in driver). <code>false</code> otherwise.</p>
          </item>
          <dt><em>awaiting_load</em></dt>
          <item>
            <p>Return a list of all processes having monitors for
              <code>loading</code> active, each process returned as
              <code>{pid(),int()}</code>, where the <code>int()</code> is the
              number of monitors held by the process <code>pid()</code>.</p>
          </item>
          <dt><em>awaiting_unload</em></dt>
          <item>
            <p>Return a list of all processes having monitors for
              <code>unloading</code> active, each process returned as
              <code>{pid(),int()}</code>, where the <code>int()</code> is the
              number of monitors held by the process <code>pid()</code>.</p>
          </item>
        </taglist>
        <p>If the options <code>linked_in_driver</code> or <code>permanent</code>
          return true, all other options will return the value
          <code>linked_in_driver</code> or <code>permanent</code> respectively.</p>
        <p>The function throws a <code>badarg</code> exception if the driver
          is not present in the system or the tag is not supported.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="load/2">load(Path, Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Loads and links the dynamic driver <code><anno>Name</anno></code>. <code><anno>Path</anno></code>
          is a file path to the directory containing the driver.
          <code><anno>Name</anno></code> must be a sharable object/dynamic library. Two
          drivers with different <code><anno>Path</anno></code> parameters cannot be
          loaded under the same name. The <code><anno>Name</anno></code> is a string or
          atom containing at least one character.</p>
        <p>The <code><anno>Name</anno></code> given should correspond to the filename
          of the actual dynamically loadable object file residing in
          the directory given as <code><anno>Path</anno></code>, but <em>without</em> the
          extension (i.e. <code>.so</code>). The driver name provided in
          the driver initialization routine must correspond with the
          filename, in much the same way as erlang module names
          correspond to the names of the <code>.beam</code> files.</p>
        <p>If the driver has been previously unloaded, but is still
          present due to open ports against it, a call to
          <code>load/2</code> will stop the unloading and keep the driver
          (as long as the <code><anno>Path</anno></code> is the same) and <code>ok</code> is
          returned. If one actually wants the object code to be
          reloaded, one uses <a href="#reload/2" class="seealso">reload/2</a> or the low-level
          interface <a href="#try_load/3" class="seealso">try_load/3</a>
          instead. Please refer to the description of <a href="#scenarios" class="seealso">different scenarios</a> for
          loading/unloading in the introduction.</p>
        <p>If more than one process tries to load an already loaded
          driver withe the same <code><anno>Path</anno></code>, or if the same process
          tries to load it several times, the function will return
          <code>ok</code>.  The emulator will keep track of the
          <code>load/2</code> calls, so that a corresponding number of
          <code>unload/2</code> calls will have to be done from the same
          process before the driver will actually get unloaded. It is
          therefore safe for an application to load a driver that is
          shared between processes or applications when needed. It can
          safely be unloaded without causing trouble for other
          parts of the system. </p>
        <p>It is not allowed to load
          several drivers with the same name but with different
          <code>Path</code> parameters.</p>
        <div class="note"><h2>Note!</h2>
          <p>Note especially that the <code><anno>Path</anno></code> is interpreted
            literally, so that all loaders of the same driver needs to
            give the same <em>literal</em><code><anno>Path</anno></code> string, even
            though different paths might point out the same directory
            in the filesystem (due to use of relative paths and
            links).</p>
        </div>
        <p>On success, the function returns <code>ok</code>. On
          failure, the return value is <code>{error,<anno>ErrorDesc</anno>}</code>,
          where <code><anno>ErrorDesc</anno></code> is an opaque term to be
          translated into human readable form by the <a href="#format_error/1" class="seealso">format_error/1</a>
          function.</p>
        <p>For more control over the error handling, again use the
          <a href="#try_load/3" class="seealso">try_load/3</a>
          interface instead.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="load_driver/2">load_driver(Path, Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Works essentially as <code>load/2</code>, but will load the driver
          with other options.  All ports that are using the
          driver will get killed with the reason
          <code>driver_unloaded</code> when the driver is to be unloaded.</p>
        <p>The number of loads and unloads by different <a href="#users" class="seealso">users</a> influence the actual loading
          and unloading of a driver file. The port killing will
          therefore only happen when the <em>last</em> <a href="#users" class="seealso">user</a> unloads the driver, or the
          last process having loaded the driver exits.</p>
        <p>This interface (or at least the name of the functions) is
          kept for backward compatibility.  Using <a href="#try_load/3" class="seealso">try_load/3</a> with
          <code>{driver_options,[kill_ports]} </code> in the option list will
          give the same effect regarding the port killing.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="monitor/2">monitor(Tag, Item) -&gt; MonitorRef</h3>
      
      <ul class="type">
        <li><code>Tag = driver </code></li>
        <li><code>Item = {Name, When}</code></li>
        <li><code>Name = atom() | string()</code></li>
        <li><code>When = loaded | unloaded | unloaded_only</code></li>
        <li><code>MonitorRef = reference()</code></li>
      </ul>
      <div class="description">
        <p>This function creates a driver monitor and works in many
          ways as the function <a href="../erts/erlang.html#erlangmonitor/2" class="seealso">erlang:monitor/2</a>,
          does for processes. When a driver changes state, the monitor
          results in a monitor-message being sent to the calling
          process. The <code>MonitorRef</code> returned by this function is
          included in the message sent.</p>
        <p>As with process monitors, each driver monitor set will only
          generate <em>one single message</em>. The monitor is
          "destroyed" after the message is sent and there is then no
          need to call <a href="#demonitor/1" class="seealso">demonitor/1</a>.</p>
        <p>The <code>MonitorRef</code> can also be used in subsequent calls
          to <a href="#demonitor/1" class="seealso">demonitor/1</a> to
          remove a monitor.</p>
        <p>The function accepts the following parameters:</p>
        <taglist>
          <dt><em>Tag</em></dt>
          <item>
            <p>The monitor tag is always <code>driver</code> as this function
              can only be used to create driver monitors. In the future,
              driver monitors will be integrated with process monitors,
              why this parameter has to be given for consistence.</p>
          </item>
          <dt><em>Item</em></dt>
          <item>
            <p>The <code>Item</code> parameter specifies which driver one
              wants to monitor (the name of the driver) as well as
              which state change one wants to monitor. The parameter
              is a tuple of arity two whose first element is the
              driver name and second element is either of:</p>
            <taglist>
              <dt><em>loaded</em></dt>
              <item>
                <p>Notify me when the driver is reloaded (or loaded if
                  loading is underway). It only makes sense to monitor
                  drivers that are in the process of being loaded or
                  reloaded. One cannot monitor a future-to-be driver
                  name for loading, that will only result in a
                  <code>'DOWN'</code> message being immediately sent.
                  Monitoring for loading is therefore most useful when
                  triggered by the <a href="#try_load/3" class="seealso">try_load/3</a> function,
                  where the monitor is created <em>because</em> the
                  driver is in such a pending state.</p>
                <p>Setting a driver monitor for <code>loading</code> will
                  eventually lead to one of the following messages
                  being sent:</p>
                <taglist>
                  <dt><em>{'UP', reference(), driver, Name, loaded}</em></dt>
                  <item>
                    <p>This message is sent, either immediately if the
                      driver is already loaded and no reloading is
                      pending, or when reloading is executed if
                      reloading is pending. </p>
                    <p>The <a href="#users" class="seealso">user</a> is
                      expected to know if reloading is demanded prior
                      to creating a monitor for loading.</p>
                  </item>
                  <dt><em>{'UP', reference(), driver, Name, permanent}</em></dt>
                  <item>
                    <p>This message will be sent if reloading was
                      expected, but the (old) driver made itself
                      permanent prior to reloading. It will also be
                      sent if the driver was permanent or statically
                      linked in when trying to create the monitor.</p>
                  </item>
                  <dt><em>{'DOWN', reference(), driver, Name, load_cancelled}</em></dt>
                  <item>
                    <p>This message will arrive if reloading was
                      underway, but the <a href="#users" class="seealso">user</a> having requested
                      reload cancelled it by either dying or calling
                      <a href="#try_unload/2" class="seealso">try_unload/2</a>
                      (or <code>unload/1</code>/<code>unload_driver/1</code>)
                      again before it was reloaded.</p>
                  </item>
                  <dt><em>{'DOWN', reference(), driver, Name, {load_failure, Failure}}</em></dt>
                  <item>
                    <p>This message will arrive if reloading was
                      underway but the loading for some reason
                      failed. The <code>Failure</code> term is one of the
                      errors that can be returned from <a href="#try_load/3" class="seealso">try_load/3</a>. The
                      error term can be passed to <a href="#format_error/1" class="seealso">format_error/1</a>
                      for translation into human readable form. Note
                      that the translation has to be done in the same
                      running erlang virtual machine as the error
                      was detected in.</p>
                  </item>
                </taglist>
              </item>
              <dt><em>unloaded</em></dt>
              <item>
                <p>Monitor when a driver gets unloaded. If one
                  monitors a driver that is not present in the system,
                  one will immediately get notified that the driver got
                  unloaded. There is no guarantee that the driver was
                  actually ever loaded.</p>
                <p>A driver monitor for unload will eventually result
                  in one of the following messages being sent:</p>
                <taglist>
                  <dt><em>{'DOWN', reference(), driver, Name, unloaded}</em></dt>
                  <item>
                    <p>The driver instance monitored is now
                      unloaded. As the unload might have been due to a
                      <code>reload/2</code> request, the driver might once
                      again have been loaded when this message
                      arrives.</p>
                  </item>
                  <dt><em>{'UP', reference(), driver, Name, unload_cancelled}</em></dt>
                  <item>
                    <p>This message will be sent if unloading was
                      expected, but while the driver was waiting for
                      all ports to get closed, a new <a href="#users" class="seealso">user</a> of the driver
                      appeared and the unloading was cancelled.</p>
                    <p>This message appears when an <code>{ok, pending_driver}</code>) was returned from <a href="#try_unload/2" class="seealso">try_unload/2</a>)
                      for the last <a href="#users" class="seealso">user</a> of the driver and
                      then a <code>{ok, already_loaded}</code> is returned
                      from a call to <a href="#try_load/3" class="seealso">try_load/3</a>.</p>
                    <p>If one wants to <em>really</em> monitor when the
                      driver gets unloaded, this message will distort
                      the picture, no unloading was really done. 
                      The <code>unloaded_only</code> option creates a monitor
                      similar to an <code>unloaded</code> monitor, but does
                      never result in this message.</p>
                  </item>
                  <dt><em>{'UP', reference(), driver, Name, permanent}</em></dt>
                  <item>
                    <p>This message will be sent if unloading was
                      expected, but the driver made itself
                      permanent prior to unloading. It will also be
                      sent if trying to monitor a permanent or
                      statically linked in driver.</p>
                  </item>
                </taglist>
              </item>
              <dt><em>unloaded_only</em></dt>
              <item>
                <p>A monitor created as <code>unloaded_only</code> behaves
                  exactly as one created as <code>unloaded</code> with the
                  exception that the <code>{'UP', reference(), driver, Name, unload_cancelled}</code> message will never be
                  sent, but the monitor instead persists until the
                  driver <em>really</em> gets unloaded.</p>
              </item>
            </taglist>
          </item>
        </taglist>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="reload/2">reload(Path, Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Reloads the driver named <code><anno>Name</anno></code> from a possibly
          different <code><anno>Path</anno></code> than was previously used. This
          function is used in the code change <a href="#scenarios" class="seealso">scenario</a> described in the
          introduction.</p>
        <p>If there are other <a href="#users" class="seealso">users</a>
          of this driver, the function will return <code>{error, pending_process}</code>, but if there are no more users, the
          function call will hang until all open ports are closed.</p>
        <div class="note"><h2>Note!</h2>
          <p>Avoid mixing
            several <a href="#users" class="seealso">users</a> 
            with driver reload requests.</p>
        </div>
        <p>If one wants to avoid hanging on open ports, one should use
          the <a href="#try_load/3" class="seealso">try_load/3</a>
          function instead.</p>
        <p>The <code><anno>Name</anno></code> and <code><anno>Path</anno></code> parameters have exactly the
          same meaning as when calling the plain <a href="#load/2" class="seealso">load/2</a> function.</p>
        <div class="note"><h2>Note!</h2>
          <p>Avoid mixing
            several <a href="#users" class="seealso">users</a> 
            with driver reload requests.</p>
        </div>
        <p>On success, the function returns <code>ok</code>. On
          failure, the function returns an opaque error, with the
          exception of the <code>pending_process</code> error described
          above. The opaque errors are to be translated into human
          readable form by the <a href="#format_error/1" class="seealso">format_error/1</a> function.</p>
        <p>For more control over the error handling, again use the
          <a href="#try_load/3" class="seealso">try_load/3</a>
          interface instead.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="reload_driver/2">reload_driver(Path, Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Works exactly as <a href="#reload/2" class="seealso">reload/2</a>, but for drivers
          loaded with the <a href="#load_driver/2" class="seealso">load_driver/2</a> interface. </p>
        <p>As this interface implies that ports are being killed when
          the last user disappears, the function wont hang waiting for
          ports to get closed.</p>
        <p>For further details, see the <a href="#scenarios" class="seealso">scenarios</a> in the module
          description and refer to the <a href="#reload/2" class="seealso">reload/2</a> function description.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="try_load/3">try_load(Path, Name, OptionList) -&gt; {ok,Status} | {ok, PendingStatus, Ref} | {error, ErrorDesc}</h3>
      
      <ul class="type">
        <li><code>Path = Name = string() | atom()</code></li>
        <li><code>OptionList = [ Option ]</code></li>
        <li><code>Option = {driver_options, DriverOptionList} | {monitor, MonitorOption} | {reload, ReloadOption}</code></li>
        <li><code>DriverOptionList = [ DriverOption ]</code></li>
        <li><code>DriverOption = kill_ports</code></li>
        <li><code>MonitorOption = pending_driver | pending</code></li>
        <li><code>ReloadOption = pending_driver | pending</code></li>
        <li><code>Status = loaded | already_loaded | PendingStatus </code></li>
        <li><code>PendingStatus = pending_driver | pending_process</code></li>
        <li><code>Ref = reference()</code></li>
        <li><code>ErrorDesc = ErrorAtom | OpaqueError</code></li>
        <li><code>ErrorAtom = linked_in_driver | inconsistent | permanent | not_loaded_by_this_process | not_loaded |  pending_reload | pending_process</code></li>
      </ul>
      <div class="description">
        <p>This function provides more control than the
          <code>load/2</code>/<code>reload/2</code> and
          <code>load_driver/2</code>/<code>reload_driver/2</code> interfaces. It
          will never wait for completion of other operations related
          to the driver, but immediately return the status of the
          driver as either:</p>
        <taglist>
          <dt><em>{ok, loaded}</em></dt>
          <item>
            <p>The driver was actually loaded and is immediately
              usable.</p>
          </item>
          <dt><em>{ok, already_loaded}</em></dt>
          <item>
            <p>The driver was already loaded by another process
              and/or is in use by a living port. The load by you is
              registered and a corresponding <code>try_unload</code> is
              expected sometime in the future.</p>
          </item>
          <dt><em>{ok, pending_driver}</em>or <em>{ok, pending_driver, reference()}</em></dt>
          <item>
            <p>The load request is registered, but the loading is
              delayed due to the fact that an earlier instance of the
              driver is still waiting to get unloaded (there are open
              ports using it). Still, unload is expected when you are
              done with the driver. This return value will
              <em>mostly</em> happen when the
              <code>{reload,pending_driver}</code> or
              <code>{reload,pending}</code> options are used, but
              <em>can</em> happen when another <a href="#users" class="seealso">user</a> is unloading a driver in
              parallel and the <code>kill_ports</code> driver option is
              set. In other words, this return value will always need
              to be handled!</p>
          </item>
          <dt><em>{ok, pending_process}</em>or <em>{ok, pending_process, reference()}</em></dt>
          <item>
            <p>The load request is registered, but the loading is
              delayed due to the fact that an earlier instance of the
              driver is still waiting to get unloaded by another
              <a href="#users" class="seealso">user</a> (not only by a
              port, in which case <code>{ok,pending_driver}</code> would
              have been returned). Still, unload is expected when you
              are done with the driver. This return value will
              <em>only</em> happen when the <code>{reload,pending}</code>
              option is used.</p>
          </item>
        </taglist>
        <p>When the function returns <code>{ok, pending_driver}</code> or
          <code>{ok, pending_process}</code>, one might want to get information
          about when the driver is <em>actually</em> loaded. This can
          be achieved by using the <code>{monitor, PendingOption}</code> option.</p>
        <p>When monitoring is requested, and a corresponding <code>{ok, pending_driver}</code> or <code>{ok, pending_process}</code> would be
          returned, the function will instead return a tuple <code>{ok, PendingStatus, reference()}</code> and the process will, at a later
          time when the driver actually gets loaded, get a monitor
          message. The monitor message one can expect is described in
          the <a href="#monitor/2" class="seealso">monitor/2</a>
          function description. </p>
        <div class="note"><h2>Note!</h2>
          <p>Note that in case of loading, monitoring can
            <em>not</em> only get triggered by using the <code>{reload, ReloadOption}</code> option, but also in special cases where
            the load-error is transient, why <code>{monitor, pending_driver}</code> should be used under basically
            <em>all</em> real world circumstances!</p>
        </div>
        <p>The function accepts the following parameters:</p>
        <taglist>
          <dt><em>Path</em></dt>
          <item>
            <p>The filesystem path to the directory where the driver
              object file is situated. The filename of the object file
              (minus extension) must correspond to the driver name
              (used in the name parameter) and the driver must
              identify itself with the very same name. The
              <code>Path</code> might be provided as an <em>io_list</em>,
              meaning it can be a list of other io_lists, characters
              (eight bit integers) or binaries, all to be flattened
              into a sequence of characters.</p>
            <p>The (possibly flattened) <code>Path</code> parameter must be
              consistent throughout the system, a driver should, by
              all <a href="#users" class="seealso">users</a>, be loaded
              using the same <em>literal</em><code>Path</code>. The
              exception is when <em>reloading</em> is requested, in
              which case the <code>Path</code> may be specified
              differently. Note that all <a href="#users" class="seealso">users</a> trying to load the
              driver at a later time will need to use the <em>new</em><code>Path</code> if the <code>Path</code> is changed using a
              <code>reload</code> option. This is yet another reason
              to have <em>only one loader</em> of a driver one wants to
              upgrade in a running system!  </p>
          </item>
          <dt><em>Name</em></dt>
          <item>
            <p>The name parameter is the name of the driver to be used
              in subsequent calls to <a href="../erts/erlang.html#open_port/2" class="seealso">open_port</a>. The
              name can be specified either as an <code>io_list()</code> or
              as an <code>atom()</code>. The name given when loading is used
              to find the actual object file (with the
              help of the <code>Path</code> and the system implied
              extension suffix, i.e. <code>.so</code>). The name by which
              the driver identifies itself must also be consistent
              with this <code>Name</code> parameter, much as a beam-file's
              module name much correspond to its filename.</p>
          </item>
          <dt><em>OptionList</em></dt>
          <item>
            <p>A number of options can be specified to control the
              loading operation. The options are given as a list of
              two-tuples, the tuples having the following values and
              meanings:</p>
            <taglist>
              <dt><em>{driver_options, DriverOptionsList}</em></dt>
              <item>
                <p>This option is to provide options that will change
                  its general behavior and will "stick" to the driver
                  throughout its lifespan.</p>
                <p>The driver options for a given driver name need
                  always to be consistent, <em>even when the driver is reloaded</em>, meaning that they are as much a part
                  of the driver as the actual name.</p>
                <p>Currently the only allowed driver option is
                  <code>kill_ports</code>, which means that all ports opened
                  towards the driver are killed with the exit-reason
                  <code>driver_unloaded</code> when no process any longer
                  has the driver loaded. This situation arises either
                  when the last <a href="#users" class="seealso">user</a> calls <a href="#try_unload/2" class="seealso">try_unload/2</a>, or
                  the last process having loaded the driver exits.</p>
              </item>
              <dt><em>{monitor, MonitorOption}</em></dt>
              <item>
                <p>A <code>MonitorOption</code> tells <code>try_load/3</code> to
                  trigger a driver monitor under certain
                  conditions. When the monitor is triggered, the
                  function will return a three-tuple <code>{ok, PendingStatus, reference()}</code>, where the <code>reference()</code> is
                  the monitor ref for the driver monitor.</p>
                <p>Only one <code>MonitorOption</code> can be specified and
                  it is either the atom <code>pending</code>, which means
                  that a monitor should be created whenever a load
                  operation is delayed, and the atom
                  <code>pending_driver</code>, in which a monitor is
                  created whenever the operation is delayed due to
                  open ports towards an otherwise unused driver. The
                  <code>pending_driver</code> option is of little use, but
                  is present for completeness, it is very well defined
                  which reload-options might give rise to which
                  delays. It might, however, be a good idea to use the
                  same <code>MonitorOption</code> as the <code>ReloadOption</code>
                  if present.</p>
                <p>If reloading is not requested, it might still be
                  useful to specify the <code>monitor</code> option, as
                  forced unloads (<code>kill_ports</code> driver option or
                  the <code>kill_ports</code> option to <a href="#try_unload/2" class="seealso">try_unload/2</a>) will
                  trigger a transient state where driver loading
                  cannot be performed until all closing ports are
                  actually closed. So, as <code>try_unload</code> can, in
                  almost all situations, return <code>{ok, pending_driver}</code>, one should always specify at least
                  <code>{monitor, pending_driver}</code> in production
                  code (see the monitor discussion above). </p>
              </item>
              <dt><em>{reload,RealoadOption}</em></dt>
              <item>
                <p>This option is used when one wants to
                  <em>reload</em> a driver from disk, most often in a
                  code upgrade scenario. Having a <code>reload</code> option
                  also implies that the <code>Path</code> parameter need
                  <em>not</em> be consistent with earlier loads of
                  the driver.</p>
                <p>To reload a driver, the process needs to have previously
                  loaded the driver, i.e there has to be an active <a href="#users" class="seealso">user</a> of the driver in the process. </p>
                <p>The <code>reload</code> option can be either the atom
                  <code>pending</code>, in which reloading is requested for
                  any driver and will be effectuated when <em>all</em>
                  ports opened against the driver are closed.  The
                  replacement of the driver will in this case take
                  place regardless of if there are still
                  pending <a href="#users" class="seealso">users</a>
                  having the driver loaded!
                  The option also triggers port-killing (if the
                  <code>kill_ports</code> driver option is used) even though
                  there are pending users, making it usable for forced
                  driver replacement, but laying a lot of
                  responsibility on the driver <a href="#users" class="seealso">users</a>. The pending option is
                  seldom used as one does not want other <a href="#users" class="seealso">users</a> to have loaded the
                  driver when code change is underway. </p>
                <p>The more useful option is <code>pending_driver</code>,
                  which means that reloading will be queued if the
                  driver is <em>not</em> loaded by any other <a href="#users" class="seealso">users</a>, but the driver has
                  opened ports, in which case <code>{ok, pending_driver}</code> will be returned (a
                  <code>monitor</code> option is of course recommended).</p>
                <p>If the driver is unloaded (not present in the
                  system), the error code
                  <code>not_loaded</code> will be returned. The
                  <code>reload</code> option is intended for when the user
                  has already loaded the driver in advance.</p>
              </item>
            </taglist>
          </item>
        </taglist>
        <p>The function might return numerous errors, of which some
          only can be returned given a certain combination of options.</p>
        <p>A number of errors are opaque and can only be interpreted by
          passing them to the <a href="#format_error/1" class="seealso">format_error/1</a> function,
          but some can be interpreted directly:</p>
        <taglist>
          <dt><em>{error,linked_in_driver}</em></dt>
          <item>
            <p>The driver with the specified name is an erlang
              statically linked in driver, which cannot be manipulated
              with this API.</p>
          </item>
          <dt><em>{error,inconsistent}</em></dt>
          <item>
            <p>The driver has already been loaded with either other
              <code>DriverOptions</code> or a different <em>literal</em><code>Path</code> argument.</p>
            <p>This can happen even if a <code>reload</code> option is given,
              if the <code>DriverOptions</code> differ from the current.</p>
          </item>
          <dt><em>{error, permanent}</em></dt>
          <item>
            <p>The driver has requested itself to be permanent, making
              it behave like an erlang linked in driver and it can no
              longer be manipulated with this API.</p>
          </item>
          <dt><em>{error, pending_process}</em></dt>
          <item>
            <p>The driver is loaded by other <a href="#users" class="seealso">users</a> when the <code>{reload, pending_driver}</code> option was given.</p>
          </item>
          <dt><em>{error, pending_reload}</em></dt>
          <item>
            <p>Driver reload is already requested by another <a href="#users" class="seealso">user</a> when the <code>{reload, ReloadOption}</code> option was given.</p>
          </item>
          <dt><em>{error, not_loaded_by_this_process}</em></dt>
          <item>
            <p>Appears when the <code>reload</code> option is given. The
              driver <code>Name</code> is present in the system, but there is no
              <a href="#users" class="seealso">user</a> of it in this
              process.</p>
          </item>
          <dt><em>{error, not_loaded}</em></dt>
          <item>
            <p>Appears when the <code>reload</code> option is given. The
              driver <code>Name</code> is not in the system. Only drivers
              loaded by this process can be reloaded.</p>
          </item>
        </taglist>
        <p>All other error codes are to be translated by the <a href="#format_error/1" class="seealso">format_error/1</a>
          function. Note that calls to <code>format_error</code> should be
          performed from the same running instance of the erlang
          virtual machine as the error was detected in, due to system
          dependent behavior concerning error values.</p>
        <p>If the arguments or options are malformed, the function will
          throw a <code>badarg</code> exception.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="try_unload/2">try_unload(Name, OptionList) -&gt; {ok,Status} | {ok, PendingStatus, Ref} | {error, ErrorAtom}</h3>
      
      <ul class="type">
        <li><code>Name = string() | atom()</code></li>
        <li><code>OptionList = [ Option ]</code></li>
        <li><code>Option = {monitor, MonitorOption} | kill_ports</code></li>
        <li><code>MonitorOption = pending_driver | pending</code></li>
        <li><code>Status = unloaded | PendingStatus </code></li>
        <li><code>PendingStatus = pending_driver | pending_process</code></li>
        <li><code>Ref = reference()</code></li>
        <li><code>ErrorAtom = linked_in_driver | not_loaded |  not_loaded_by_this_process | permanent</code></li>
      </ul>
      <div class="description">
        <p>This is the low level function to unload (or decrement
          reference counts of) a driver. It can be used to force port
          killing, in much the same way as the driver option
          <code>kill_ports</code> implicitly does, and it can trigger a
          monitor either due to other <a href="#users" class="seealso">users</a> still having the driver
          loaded or that there are open ports using the driver.</p>
        <p>Unloading can be described as the process of telling the
          emulator that this particular part of the code in this
          particular process (i.e. this <a href="#users" class="seealso">user</a>) no longer needs the
          driver. That can, if there are no other users, trigger
          actual unloading of the driver, in which case the driver
          name disappears from the system and (if possible) the memory
          occupied by the driver executable code is reclaimed. If the
          driver has the <code>kill_ports</code> option set, or if
          <code>kill_ports</code> was specified as an option to this
          function, all pending ports using this driver will get
          killed when unloading is done by the last <a href="#users" class="seealso">user</a>. If no port-killing is
          involved and there are open ports, the actual unloading
          is delayed until there are no more open ports using the
          driver. If, in this case, another <a href="#users" class="seealso">user</a> (or even this user) loads the
          driver again before the driver is actually unloaded, the
          unloading will never take place.</p>
        <p>To allow the <a href="#users" class="seealso">user</a> that
          <em>requests unloading</em> to wait for <em>actual unloading</em> to
          take place, <code>monitor</code> triggers can be specified in much
          the same way as when loading. As <a href="#users" class="seealso">users</a> of this function however
          seldom are interested in more than decrementing the
          reference counts, monitoring is more seldom needed. If the
          <code>kill_ports</code> option is used however, monitor trigging is
          crucial, as the ports are not guaranteed to have been killed
          until the driver is unloaded, why a monitor should be
          triggered for at least the <code>pending_driver</code> case.</p>
        <p>The possible monitor messages that can be expected are the
          same as when using the <code>unloaded</code> option to the
          <a href="#monitor/2" class="seealso">monitor/2</a> function.</p>
        <p>The function will return one of the following statuses upon
          success:</p>
        <taglist>
          <dt><em>{ok, unloaded}</em></dt>
          <item>
            <p>The driver was immediately unloaded, meaning that the
              driver name is now free to use by other drivers and, if
              the underlying OS permits it, the memory occupied by the
              driver object code is now reclaimed.</p>
            <p>The driver can only be unloaded when there are no open
              ports using it and there are no more <a href="#users" class="seealso">users</a> requiring it to be
              loaded.</p>
          </item>
          <dt><em>{ok, pending_driver}</em>or <em>{ok, pending_driver, reference()}</em></dt>
          <item>
            <p>This return value indicates that this call removed the
              last <a href="#users" class="seealso">user</a> from the
              driver, but there are still open ports using it.
              When all ports are closed and no new <a href="#users" class="seealso">users</a> have arrived, the driver
              will actually be reloaded and the name and memory
              reclaimed.</p>
            <p>This return value is valid even when the option
              <code>kill_ports</code> was used, as killing ports may not be
              a process that completes immediately. The condition is,
              in that case, however transient. Monitors are as always
              useful to detect when the driver is really unloaded.</p>
          </item>
          <dt><em>{ok, pending_process}</em>or <em>{ok, pending_process, reference()}</em></dt>
          <item>
            <p>The unload request is registered, but there are still
              other <a href="#users" class="seealso">users</a> holding
              the driver. Note that the term <code>pending_process</code>
              might refer to the running process, there might be more
              than one <a href="#users" class="seealso">user</a> in the
              same process.</p>
            <p>This is a normal, healthy return value if the call was
              just placed to inform the emulator that you have no
              further use of the driver. It is actually the most
              common return value in the most common <a href="#scenarios" class="seealso">scenario</a>
              described in the introduction.</p>
          </item>
        </taglist>
        <p>The function accepts the following parameters:</p>
        <taglist>
          <dt><em>Name</em></dt>
          <item>
            <p>The name parameter is the name of the driver to be
              unloaded. The name can be specified either as an
              <code>io_list()</code> or as an <code>atom()</code>. </p>
          </item>
          <dt><em>OptionList</em></dt>
          <item>
            <p>The <code>OptionList</code> argument can be used to specify
              certain behavior regarding ports as well as triggering
              monitors under certain conditions:</p>
            <taglist>
              <dt><em>kill_ports</em></dt>
              <item>
                <p>Force killing of all ports opened using this driver,
                  with the exit reason <code>driver_unloaded</code>, if you are
                  the <em>last</em><a href="#users" class="seealso">user</a> of the driver.</p>
                <p>If there are other <a href="#users" class="seealso">users</a> having the driver
                  loaded, this option will have no effect.</p>
                <p>If one wants the consistent behavior of killing ports
                  when the last <a href="#users" class="seealso">user</a>
                  unloads, one should use the driver option
                  <code>kill_ports</code> when loading the driver instead.</p>
              </item>
              <dt><em>{monitor, MonitorOption}</em></dt>
              <item>
                <p>This option creates a driver monitor if the condition
                  given in <code>MonitorOptions</code> is true. The valid
                  options are:</p>
                <taglist>
                  <dt><em>pending_driver</em></dt>
                  <item>
                    <p>Create a driver monitor if the return value is to
                      be <code>{ok, pending_driver}</code>.</p>
                  </item>
                  <dt><em>pending</em></dt>
                  <item>
                    <p>Create a monitor if the return value will be either 
                      <code>{ok, pending_driver}</code> or <code>{ok, pending_process}</code>.</p>
                  </item>
                </taglist>
                <p>The <code>pending_driver</code> <code>MonitorOption</code> is by far
                  the most useful and it has to be used to ensure that the
                  driver has really been unloaded and the ports closed
                  whenever the <code>kill_ports</code> option is used or the
                  driver may have been loaded with the <code>kill_ports</code>
                  driver option.</p>
                <p>By using the monitor-triggers in the call to
                  <code>try_unload</code> one can be sure that the monitor is
                  actually added before the unloading is executed, meaning
                  that the monitor will always get properly triggered,
                  which would not be the case if one called
                  <code>erl_ddll:monitor/2</code> separately.</p>
              </item>
            </taglist>
          </item>
        </taglist>
        <p>The function may return several error conditions, of which
          all are well specified (no opaque values):</p>
        <taglist>
          <dt><em>{error, linked_in_driver}</em></dt>
          <item>
            <p>You were trying to unload an erlang statically linked in
              driver, which cannot be manipulated with this interface
              (and cannot be unloaded at all).</p>
          </item>
          <dt><em>{error, not_loaded}</em></dt>
          <item>
            <p>The driver <code>Name</code> is not present in the system.</p>
          </item>
          <dt><em>{error, not_loaded_by_this_process}</em></dt>
          <item>
            <p>The driver <code>Name</code> is present in the system, but
              there is no <a href="#users" class="seealso">user</a> of
              it in this process. </p>
            <p>As a special case, drivers can be unloaded from
              processes that has done no corresponding call to
              <code>try_load/3</code> if, and only if, there are <em>no users of the driver at all</em>, which may happen if the
              process containing the last user dies.</p>
          </item>
          <dt><em>{error, permanent}</em></dt>
          <item>
            <p>The driver has made itself permanent, in which case it
              can no longer be manipulated by this interface (much
              like a statically linked in driver).</p>
          </item>
        </taglist>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="unload/1">unload(Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Unloads, or at least dereferences the driver named
          <code><anno>Name</anno></code>. If the caller is the last <a href="#users" class="seealso">user</a> of the driver, and there
          are no more open ports using the driver, the driver will
          actually get unloaded. In all other cases, actual unloading
          will be delayed until all ports are closed and there are no
          remaining <a href="#users" class="seealso">users</a>.</p>
        <p>If there are other <a href="#users" class="seealso">users</a> of the driver, the reference
          counts of the driver is merely decreased, so that the caller
          is no longer considered a user of the driver. For usage
          scenarios, see the <a href="#scenarios" class="seealso">description</a> in the beginning
          of this document. </p>
        <p>The <code><anno>ErrorDesc</anno></code> returned is an opaque value to be
          passed further on to the <a href="#format_error/1" class="seealso">format_error/1</a>
          function. For more control over the operation, use the
          <a href="#try_unload/2" class="seealso">try_unload/2</a>
          interface.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="unload_driver/1">unload_driver(Name) -&gt; ok | {error, ErrorDesc}</h3>
      
      <div class="description">
        <p>Unloads, or at least dereferences the driver named
          <code><anno>Name</anno></code>. If the caller is the last <a href="#users" class="seealso">user</a> of the driver, all
          remaining open ports using the driver will get killed with
          the reason <code>driver_unloaded</code> and the driver will
          eventually get unloaded.</p>
        <p>If there are other <a href="#users" class="seealso">users</a>
          of the driver, the reference counts of the driver is merely
          decreased, so that the caller is no longer considered a
          <a href="#users" class="seealso">user</a>. For
          usage scenarios, see the <a href="#scenarios" class="seealso">description</a> in the beginning
          of this document.</p>
        <p>The <code><anno>ErrorDesc</anno></code> returned is an opaque value to be
          passed further on to the <a href="#format_error/1" class="seealso">format_error/1</a>
          function. For more control over the operation, use the
          <a href="#try_unload/2" class="seealso">try_unload/2</a>
          interface.</p>
        <p>The function throws a <code>badarg</code> exception if the
          parameters are not given as described above.  </p>
      </div>
    </div>
    <div class="function">
      <h3 id="loaded_drivers/0">loaded_drivers() -&gt; {ok, Drivers}</h3>
      
      <ul class="type">
        <li><code>Drivers = [Driver]</code></li>
        <li><code>Driver = string()</code></li>
      </ul>
      <div class="description">
        <p>Returns a list of all the available drivers, both
          (statically) linked-in and dynamically loaded ones.</p>
        <p>The driver names are returned as a list of strings rather
          than a list of atoms for historical reasons.</p>
        <p>More information about drivers can be obtained using one of
          the <a href="#info/0" class="seealso">info</a> functions.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="format_error/1">format_error(ErrorDesc) -&gt; string()</h3>
      
      <div class="description">
        <p>Takes an <code><anno>ErrorDesc</anno></code> returned by load, unload or
          reload functions and returns a string which
          describes the error or warning.</p>
        <div class="note"><h2>Note!</h2>
          <p>Due to peculiarities in the dynamic loading interfaces on
            different platform, the returned string is only guaranteed
            to describe the correct error <em>if format_error/1 is called in the same instance of the erlang virtual machine as the error appeared in</em> (meaning the same operating
            system process)!</p>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <h4>SEE ALSO</h4>
    <p>erl_driver(4), driver_entry(4)</p>
  </div>

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        <ul id="funs"><li><a href="#demonitor/1">demonitor/1</a></li><li><a href="#info">info</a></li><li><a href="#info-1">info-1</a></li><li><a href="#info/2">info/2</a></li><li><a href="#load">load</a></li><li><a href="#load_driver">load_driver</a></li><li><a href="#monitor/2">monitor/2</a></li><li><a href="#reload">reload</a></li><li><a href="#reload_driver">reload_driver</a></li><li><a href="#try_load/3">try_load/3</a></li><li><a href="#try_unload/2">try_unload/2</a></li><li><a href="#unload">unload</a></li><li><a href="#unload_driver">unload_driver</a></li><li><a href="#loaded_drivers/0">loaded_drivers/0</a></li><li><a href="#format_error">format_error</a></li></ul>
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59760-14']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script');
        ga.src = ('https:' == document.location.protocol ?
          'https://ssl' : 'http://www') +
          '.google-analytics.com/ga.js';
        ga.setAttribute('async', 'true');
        document.documentElement.firstChild.appendChild(ga);
      })();
    </script>
  </body>
</html>

