<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>public_key (public_key) -  (Erlang Documentation)</title>
    <link href="../erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44246018-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>public_key</h1>
  <h2 class="modsummary">API module for public-key infrastructure.</h2>
  <div class="description">
    <p>This module provides functions to handle public-key infrastructure. It can
    encode/decode different file formats (PEM, OpenSSH), sign and verify digital signatures, 
    and validate certificate paths and certificate revocation lists.
    </p>
  </div>

  <div class="section">
    <h4>public_key</h4>

    <list type="bulleted">
      <item> Public Key requires the Crypto and ASN1 applications, 
      the latter as OTP R16 (hopefully the runtime dependency on ASN1 will
      be removed again in the future).</item>

      <item>Supports <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </url> -
      Internet X.509 Public-Key Infrastructure Certificate and Certificate Revocation List 
      (CRL) Profile </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS-1 </url> - 
      RSA Cryptography Standard </item>
      <item>Supports <url href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</url> - 
      Digital Signature Standard (DSA - Digital Signature Algorithm)</item>
      <item>Supports 
      <url href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-3-diffie-hellman-key-agreement-standar.htm"> PKCS-3 </url> - 
      Diffie-Hellman Key Agreement Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc2898.txt"> PKCS-5</url> - 
      Password-Based Cryptography Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5208.txt"> PKCS-8</url> - 
      Private-Key Information Syntax Standard</item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5967.txt"> PKCS-10</url> - 
      Certification Request Syntax Standard</item>
    </list>
  </div>

  <div class="section">
    <h4>DATA TYPES</h4> 
    
    <div class="note"><h2>Note!</h2><p>All records used in this Reference Manual 
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <a href="public_key_records.html" class="seealso">Public-key Records</a>.
    </p></div>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide:</p>
    
    <code> -include_lib("public_key/include/public_key.hrl").</code>

    <p>The following data types are used in the functions for <code>public_key</code>:</p>

    <taglist>
      <dt><code>oid()</code></dt>
      <item><p>Object identifier, a tuple of integers as generated by the <code>ASN.1</code> compiler.</p></item>

      <dt><code>boolean() =</code></dt>
      <item><p><code>true | false</code></p></item>
      
      <dt><code>string() =</code></dt>
      <item><p><code>[bytes()]</code></p></item>

      <dt><code>der_encoded() =</code></dt>
      <item><p><code>binary()</code></p></item>

      <dt><code>pki_asn1_type() =</code></dt>
      <item>
	<p><code>'Certificate'</code></p>
	<p><code>| 'RSAPrivateKey'</code></p>
	<p><code>| 'RSAPublicKey'</code></p>
	<p><code>| 'DSAPrivateKey'</code></p>
	<p><code>| 'DSAPublicKey'</code></p>
	<p><code>| 'DHParameter'</code></p>
	<p><code>| 'SubjectPublicKeyInfo'</code></p>
	<p><code>| 'PrivateKeyInfo'</code></p>
	<p><code>| 'CertificationRequest'</code></p>
	<p><code>| 'CertificateList'</code></p>
	<p><code>| 'ECPrivateKey'</code></p>
	<p><code>| 'EcpkParameters'</code></p>
      </item>

      <dt><code>pem_entry () =</code></dt>
      <item><p><code>{pki_asn1_type(), binary(), %% DER or encrypted DER</code></p>
      <p><code> not_encrypted | cipher_info()}</code></p></item>
      
      <dt><code>cipher_info() = </code></dt>
      <item><p><code>{"RC2-CBC" | "DES-CBC" | "DES-EDE3-CBC", crypto:rand_bytes(8)</code></p>
      <p><code>| {#'PBEParameter{}, digest_type()} | #'PBES2-params'{}}</code></p>
      </item>
      
      <dt><code>public_key() =</code></dt>
      <item><p><code>rsa_public_key() | dsa_public_key() | ec_public_key()</code></p></item>
      
      <dt><code>private_key() =</code></dt>
      <item><p><code>rsa_private_key() | dsa_private_key() | ec_private_key()</code></p></item>

      <dt><code>rsa_public_key() =</code></dt>
      <item><p><code>#'RSAPublicKey'{}</code></p></item>

      <dt><code>rsa_private_key() =</code></dt>
      <item><p><code>#'RSAPrivateKey'{}</code></p></item>

      <dt><code>dsa_public_key() =</code></dt>
      <item><p><code>{integer(),  #'Dss-Parms'{}}</code></p></item>

      <dt><code>dsa_private_key() =</code></dt>
      <item><p><code>#'DSAPrivateKey'{}</code></p></item>

      <dt><code>ec_public_key()</code></dt>
      <item><p>= <code>{#'ECPoint'{}, #'EcpkParameters'{} | {namedCurve, oid()}}</code></p></item>

      <dt><code>ec_private_key() =</code></dt>
      <item><p><code>#'ECPrivateKey'{}</code></p></item>

      <dt><code>public_crypt_options() =</code></dt>
      <item><p><code>[{rsa_pad, rsa_padding()}]</code></p></item>

      <dt><code>rsa_padding() =</code></dt>
      <item>
	<p><code>'rsa_pkcs1_padding'</code></p>
	<p><code>| 'rsa_pkcs1_oaep_padding'</code></p>
	<p><code>| 'rsa_no_padding'</code></p>
      </item>

      <dt><code>digest_type() = </code></dt>
      <item><p>Union of <code>rsa_digest_type()</code>, <code>dss_digest_type()</code>, 
      and <code>ecdsa_digest_type()</code>.</p></item>

      <dt><code>rsa_digest_type() = </code></dt>
      <item><p><code>'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p></item>

      <dt><code>dss_digest_type() = </code></dt>
      <item><p><code>'sha'</code></p></item>

      <dt><code>ecdsa_digest_type() = </code></dt>
      <item><p><code>'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p></item>
      
      <dt><code>crl_reason() = </code></dt>
      <item>
	<p><code>unspecified</code></p>
	<p><code>| keyCompromise</code></p>
	<p><code>| cACompromise</code></p>
	<p><code>| affiliationChanged</code></p>
	<p><code>| superseded</code></p>
	<p><code>| cessationOfOperation</code></p>
	<p><code>| certificateHold</code></p>
	<p><code>| privilegeWithdrawn</code></p>
	<p><code>| aACompromise</code></p>
      </item>

      <dt><code>issuer_name() =</code></dt>
      <item><p><code>{rdnSequence,[#'AttributeTypeAndValue'{}]}</code></p>  
      </item>
      
      <dt><code>ssh_file() =</code></dt>
      <item>
	<p><code>openssh_public_key</code></p>
	<p><code>| rfc4716_public_key</code></p>
	<p><code>| known_hosts</code></p>
	<p><code>| auth_keys</code></p>
      </item>
    </taglist>
    
    
</div> 

<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>    

  <div class="function">
    <h3 id="compute_key/2">compute_key(OthersKey, MyKey)-&gt;</h3>
    <h3 id="compute_key/3">compute_key(OthersKey, MyKey, Params)-&gt;</h3>
    
    <ul class="type">
      <li><code>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</code></li>
      <li><code>Params =  #'DHParameter'{}</code></li>
    </ul>
  <div class="description">
    <p>Computes shared secret.</p>
  </div>
  </div>

  <div class="function">
    <h3 id="decrypt_private/2">decrypt_private(CipherText, Key) -&gt; binary()</h3>
    <h3 id="decrypt_private/3">decrypt_private(CipherText, Key, Options) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p>Public-key decryption using the private key. See also <a href="../crypto/crypto.html#private_decrypt/4" class="seealso">crypto:private_decrypt/4</a></p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="decrypt_public/2">decrypt_public(CipherText, Key) - &gt; binary()</h3>
    <h3 id="decrypt_public/3">decrypt_public(CipherText, Key, Options) - &gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p>Public-key decryption using the public key. See also <a href="../crypto/crypto.html#public_decrypt/4" class="seealso">crypto:public_decrypt/4</a></p> 
  </div> 
  </div> 

  <div class="function">
    <h3 id="der_decode/2">der_decode(Asn1type, Der) -&gt; term()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d>ASN.1 type present in the Public Key applications
      ASN.1 specifications.</d>
      <li><code>Der = der_encoded()</code></li>
    </ul> 
    <div class="description"> 
      <p>Decodes a public-key ASN.1 DER encoded entity.</p>
    </div> 
  </div>
    
  <div class="function">
    <h3 id="der_encode/2">der_encode(Asn1Type, Entity) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d>ASN.1 type present in the Public Key applications
	 ASN.1 specifications.</d>
      <li><code>Entity = term()</code></li>
      <d>Erlang representation of <code>Asn1Type</code></d>
  </ul> 
  <div class="description"> 
    <p>Encodes a public-key entity with ASN.1 DER encoding.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="dh_gex_group/4">dh_gex_group(MinSize, SuggestedSize, MaxSize, Groups) -&gt; {ok, {Size,Group}} | {error,Error}</h3>
    
    <ul class="type">
      <li><code>MinSize = positive_integer()</code></li>
      <li><code>SuggestedSize = positive_integer()</code></li>
      <li><code>MaxSize = positive_integer()</code></li>
      <li><code>Groups = undefined | [{Size,[{G,P}]}]</code></li>
      <li><code>Size = positive_integer()</code></li>
      <li><code>Group = {G,P}</code></li>
      <li><code>G = positive_integer()</code></li>
      <li><code>P = positive_integer()</code></li>
    </ul>
    <div class="description">
      <p>Selects a group for Diffie-Hellman key exchange with the key size in the range <code>MinSize...MaxSize</code>
      and as close to <code>SuggestedSize</code> as possible. If <code>Groups == undefined</code> a default set will be
      used, otherwise the group is selected from <code>Groups</code>.</p>
      <p>First a size, as close as possible to SuggestedSize, is selected. Then one group with that key size
      is randomly selected from the specified set of groups. If no size within the limits of <code>MinSize</code>
      and <code>MaxSize</code> is available, <code>{error,no_group_found}</code> is returned.</p>
      <p>The default set of groups is listed in <code>lib/public_key/priv/moduli</code>. This file may be regenerated like this:</p>
      <pre class="sh_erlang">
	$&gt; cd $ERL_TOP/lib/public_key/priv/
	$&gt; generate
         ---- wait until all background jobs has finished. It may take several days !
	$&gt; cat moduli-* &gt; moduli
	$&gt; cd ..; make 
      </pre>
    </div>
  </div>

    <div class="function">
    <h3 id="encrypt_private/2">encrypt_private(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Public-key encryption using the private key.
     See also <a href="../crypto/crypto.html#private_encrypt/4" class="seealso">crypto:private_encrypt/4</a>.</p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="encrypt_public/2">encrypt_public(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Public-key encryption using the public key. See also <a href="../crypto/crypto.html#public_encrypt/4" class="seealso">crypto:public_encrypt/4</a>.</p> 
  </div> 
  </div>   
  
  <div class="function">
    <h3 id="generate_key/1">generate_key(Params) -&gt; {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </h3>
    
    <ul class="type">
      <li><code>Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{}</code></li>
    </ul>
  <div class="description">
    <p>Generates a new keypair.</p>
  </div>
  </div>

  <div class="function">
    <h3 id="pem_decode/1">pem_decode(PemBin) -&gt; [pem_entry()]</h3>
    
    <ul class="type">
      <li><code>PemBin = binary()</code></li>
      <d>Example {ok, PemBin} = file:read_file("cert.pem").</d>
    </ul> 
  <div class="description"> 
    <p>Decodes PEM binary data and returns
    entries as ASN.1 DER encoded entities.</p>
  </div> 
  </div> 
    
   <div class="function">
    <h3 id="pem_encode/1">pem_encode(PemEntries) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code> PemEntries = [pem_entry()] </code></li> 
  </ul> 
  <div class="description"> 
    <p>Creates a PEM binary.</p> 
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_decode/1">pem_entry_decode(PemEntry) -&gt; term()</h3>
    <h3 id="pem_entry_decode/2">pem_entry_decode(PemEntry, Password) -&gt; term()</h3>
    
    <ul class="type">
      <li><code>PemEntry = pem_entry()</code></li> 
      <li><code>Password = string()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes a PEM entry. <code>pem_decode/1</code> returns a list of PEM
    entries. Notice that if the PEM entry is of type
    'SubjectPublickeyInfo', it is further decoded to an
    <code>rsa_public_key()</code> or <code>dsa_public_key()</code>.</p>
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_encode/2">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</h3>
    <h3 id="pem_entry_encode/4">pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = pki_asn1_type()</code></li>
      <li><code>Entity = term()</code></li>
      <d>Erlang representation of
      <code>Asn1Type</code>.  If <code>Asn1Type</code> is 'SubjectPublicKeyInfo',
      <code>Entity</code> must be either an <code>rsa_public_key()</code> or a
      <code>dsa_public_key()</code> and this function creates the appropriate
      'SubjectPublicKeyInfo' entry.
      </d>
      <li><code>CipherInfo = cipher_info()</code></li>
      <li><code>Password = string()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Creates a PEM entry that can be feed to <code>pem_encode/1</code>.</p>
  </div> 
  </div>
  
  <div class="function">
    <h3 id="pkix_decode_cert/2">pkix_decode_cert(Cert, otp|plain) -&gt;  #'Certificate'{} | #'OTPCertificate'{}</h3>
    
    <ul class="type">
      <li><code>Cert = der_encoded()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes an ASN.1 DER-encoded PKIX certificate. Option <code>otp</code>
    uses the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_encode/3">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either.</d>
      <li><code>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</code></li>
  </ul> 
  <div class="description"> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the <code>otp</code> format, whereas for the plain format this
    function directly calls <code>der_encode/2</code>.</p> 
  </div> 
  </div>

 <div class="function">
    <h3 id="pkix_is_issuer/2">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encoded() | #'OTPCertificate'{} | #'CertificateList'{}</code></li>
      <li><code>IssuerCert = der_encoded() | #'OTPCertificate'{}</code></li>
  </ul> 
  <div class="description"> 
    <p>Checks if <code>IssuerCert</code> issued <code>Cert</code>.</p> 
  </div> 
  </div>
  
  <div class="function">
    <h3 id="pkix_is_fixed_dh_cert/1">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
        <li><code>Cert = der_encoded() | #'OTPCertificate'{}</code></li>
  </ul> 
  <div class="description"> 
    <p>Checks if a certificate is a fixed Diffie-Hellman certificate.</p> 
  </div> 
  </div>  
  
  <div class="function">
    <h3 id="pkix_is_self_signed/1">pkix_is_self_signed(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
       <li><code>Cert = der_encoded() | #'OTPCertificate'{}</code></li>
  </ul> 
  <div class="description"> 
    <p>Checks if a certificate is self-signed.</p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_issuer_id/2">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</h3>
    
    <ul class="type">
        <li><code>Cert = der_encoded() | #'OTPCertificate'{}</code></li>
	<li><code>IssuedBy = self | other</code></li>
	<li><code>IssuerID = {integer(), issuer_name()}</code></li>
	<d>The issuer id consists of the serial number and the issuers name.</d>
	<li><code>Reason = term()</code></li>
    </ul> 
    <div class="description"> 
    <p>Returns the issuer id.</p> 
    </div> 
  </div>
  
 
  <div class="function">
    <h3 id="pkix_normalize_name/1">pkix_normalize_name(Issuer) -&gt; Normalized</h3>
    
    <ul class="type">
      <li><code>Issuer = issuer_name()</code></li>
      <li><code>Normalized = issuer_name()</code></li>
  </ul> 
  <div class="description"> 
    <p>Normalizes an issuer name so that it can be easily
    compared to another issuer name.</p> 
  </div> 
  </div>
   
  <div class="function">
    <h3 id="pkix_path_validation/3">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </h3>
    
     <ul class="type">
       <li><code>TrustedCert =  #'OTPCertificate'{} | der_encoded() | atom()</code></li>
       <d>Normally a trusted certificate, but it can also be a path-validation
       error that can be discovered while
       constructing the input to this function and that is to be run through the <code>verify_fun</code>.
       Examples are <code>unknown_ca</code> and <code>selfsigned_peer.</code>
       </d>
       <li><code>CertChain = [der_encoded()]</code></li>
       <d>A list of DER-encoded certificates in trust order ending with the peer certificate.</d>
       <li><code>Options = proplists:proplist()</code></li>
       <li><code>PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</code></li>
       <li><code>PolicyTree = term()</code></li>
       <d>At the moment this is always an empty list as policies are not currently supported.</d>
       <li><code>Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted |
       missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()
       </code></li>
     </ul>
     <div class="description">
       <p>
	 Performs a basic path validation according to
	 <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</url>
	 However, CRL validation is done separately by <a href="#pkix_crls_validate/3" class="seealso">pkix_crls_validate/3 </a> and is to be called
	 from the supplied <code>verify_fun</code>.
       </p>

       <p>Available options:</p>

       <taglist>
	<dt>{verify_fun, fun()}</dt>
	<item>
	  <p>The fun must be defined as:</p>

	  <code>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </code>

	<p>If the verify callback fun returns <code>{fail, Reason}</code>, the
	verification process is immediately stopped. If the verify
	callback fun returns <code>{valid, UserState}</code>, the verification
	process is continued. This can be used to accept specific path
	validation errors, such as <code>selfsigned_peer</code>, as well as
	verifying application-specific extensions. If called with an
	extension unknown to the user application, the return value
	<code>{unknown, UserState}</code> is to be used.</p>

	</item>
	<dt>{max_path_length, integer()}</dt>
	<item>
	  The <code>max_path_length</code> is the maximum number of non-self-issued
	  intermediate certificates that can follow the peer certificate
	  in a valid certification path. So, if <code>max_path_length</code> is 0, the PEER must
	  be signed by the trusted ROOT-CA directly, if it is 1, the path can
	  be PEER, CA, ROOT-CA, if it is 2, the path can
	  be PEER, CA, CA, ROOT-CA, and so on.
	</item>
      </taglist>

      <p>Possible reasons for a bad certificate: </p>
      <taglist>
	<dt>cert_expired</dt>
	<item><p>Certificate is no longer valid as its expiration date has passed.</p></item>

	<dt>invalid_issuer</dt>
	<item><p>Certificate issuer name does not match the name of the issuer certificate in the chain.</p></item>

	<dt>invalid_signature</dt>
	<item><p>Certificate was not signed by its issuer certificate in the chain.</p></item>

	<dt>name_not_permitted</dt>
	<item><p>Invalid Subject Alternative Name extension.</p></item>

	<dt>missing_basic_constraint</dt>
	<item><p>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</p></item>

	<dt>invalid_key_usage</dt>
	<item><p>Certificate key is used in an invalid way according to the key-usage extension.</p></item>

	<dt>{revoked, crl_reason()}</dt>
	<item><p>Certificate has been revoked.</p></item>

	<dt>atom()</dt>
	<item><p>Application-specific error reason that is to be checked by the <code>verify_fun</code>.</p></item>
      </taglist>

    </div>
   </div>

    <div class="function">  
      <h3 id="pkix_crl_issuer/1">pkix_crl_issuer(CRL) -&gt; issuer_name()</h3>
      
      <ul class="type">
	<li><code>CRL = der_encoded() | #'CertificateList'{} </code></li> 
      </ul> 
      <div class="description"> 
	<p>Returns the issuer of the <code>CRL</code>.</p>
      </div> 
    </div> 
   
   <div class="function">
     <h3 id="pkix_crls_validate/3">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</h3>
     
     <ul class="type">
       <li><code>OTPCertificate =  #'OTPCertificate'{}</code></li>
       <li><code>DPAndCRLs  = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}] </code></li>
       <li><code>Options = proplists:proplist()</code></li>
       <li><code>CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</code></li>
     </ul>
     <div class="description">
      <p>Performs CRL validation. It is intended to be called from
      the verify fun of  <a href="#pkix_path_validation/3" class="seealso"> pkix_path_validation/3
       </a>.</p>

       <p>Available options:</p>

      <taglist>
	
	<dt>{update_crl, fun()}</dt>
	<item>
	  <p>The fun has the following type specification:</p>

	  <code> fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
        #'CertificateList'{}</code>

	  <p>The fun uses the information in the distribution point to access
	  the latest possible version of the CRL. If this fun is not specified,
	  Public Key uses the default implementation:
	  </p>
	  <code> fun(_DP, CRL) -&gt; CRL end</code>
	</item>

	<dt>{issuer_fun, fun()}</dt>
	<item>
	  <p>The fun has the following type specification:</p>

	  <code>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}</code>

	  <p>The fun returns the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <code> fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}</code>
	</item>	
      </taglist>
    </div>
   </div>
   
   <div class="function">  
     <h3 id="pkix_crl_verify/2">pkix_crl_verify(CRL, Cert) -&gt; boolean()</h3>
     
     <ul class="type">
       <li><code>CRL = der_encoded() | #'CertificateList'{} </code></li> 
       <li><code>Cert = der_encoded() | #'OTPCertificate'{} </code></li> 
     </ul> 
     <div class="description"> 
       <p>Verify that <code>Cert</code> is the <code>CRL</code> signer.</p>
     </div> 
   </div>

   <div class="function">  
     <h3 id="pkix_dist_point/1">pkix_dist_point(Cert) -&gt; DistPoint</h3>
     
     <ul class="type">
       <li><code> Cert  = der_encoded() | #'OTPCertificate'{} </code></li> 
       <li><code> DistPoint =  #'DistributionPoint'{}</code></li> 
     </ul> 
     <div class="description"> 
       <p>Creates a distribution point for CRLs issued by the same issuer as <code>Cert</code>.
       Can be used as input to <a href="#pkix_crls_validate/3" class="seealso">pkix_crls_validate/3 </a>
       </p>
     </div> 
   </div>
   
   <div class="function">  
     <h3 id="pkix_dist_points/1">pkix_dist_points(Cert) -&gt; DistPoints</h3>
     
     <ul class="type">
       <li><code> Cert  = der_encoded() | #'OTPCertificate'{} </code></li> 
       <li><code> DistPoints =  [#'DistributionPoint'{}]</code></li> 
     </ul> 
     <div class="description"> 
       <p> Extracts distribution points from the certificates extensions.</p>
     </div> 
 </div>
   
  <div class="function">
    <h3 id="pkix_sign/2">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Key = rsa_private_key() | dsa_private_key()</code></li> 
    </ul> 
    <div class="description"> 
      <p>Signs an 'OTPTBSCertificate'. Returns the corresponding
      DER-encoded certificate.</p> 
    </div> 
  </div> 

  <div class="function">
    <h3 id="pkix_sign_types/1">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</h3>
    
    <ul class="type">
      <li><code>AlgorithmId = oid()</code></li>
      <d>Signature OID from a certificate or a certificate revocation list.</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type()</code></li>
      <li><code>SignatureType = rsa | dsa | ecdsa</code></li>
    </ul>
    <div class="description">
      <p>Translates signature algorithm OID to Erlang digest and signature types.
      </p>
    </div>
  </div>

  <div class="function">  
    <h3 id="pkix_verify/2">pkix_verify(Cert, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encoded()</code></li>
      <li><code>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</code></li> 
    </ul> 
  <div class="description"> 
    <p>Verifies PKIX x.509 certificate signature.</p>
  </div> 
  </div> 

  <div class="function">
    <h3 id="sign/3">sign(Msg, DigestType, Key) -&gt; binary()</h3>
    
    <ul class="type">
       <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The <code>Msg</code> is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text", that is, the
       digest.</d>
       <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
       <li><code>Key = rsa_private_key() | dsa_private_key() | ec_private_key()</code></li>
  </ul>
  <div class="description">
    <p>Creates a digital signature.</p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="ssh_decode/2">ssh_decode(SshBin,  Type) -&gt; [{public_key(), Attributes::list()}]</h3>
    
    <ul class="type">
      <li><code>SshBin = binary()</code></li>
      <d>Example <code>{ok, SshBin} = file:read_file("known_hosts")</code>.</d>
      <li><code>Type = public_key | ssh_file()</code></li>
      <d>If <code>Type</code> is <code>public_key</code> the binary can be either
      an RFC4716 public key or an OpenSSH public key.</d>
    </ul>
  <div class="description">
    <p>Decodes an SSH file-binary. In the case of <code>known_hosts</code> or
    <code>auth_keys</code>, the binary can include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <taglist>
      <dt>RFC4716 attributes - see RFC 4716.</dt>
      <item><p>{headers, [{string(), utf8_string()}]}</p></item>
      <dt>auth_key attributes - see manual page for sshd.</dt>
      <item>{comment, string()}</item>
      <item>{options, [string()]}</item>
      <item><p>{bits, integer()} - In SSH version 1 files.</p></item>
      <dt>known_host attributes - see manual page for sshd.</dt>
      <item>{hostnames, [string()]}</item>
      <item>{comment, string()}</item>
      <item><p>{bits, integer()} - In SSH version 1 files.</p></item>
    </taglist>

  </div>
  </div>

  <div class="function">
    <h3 id="ssh_encode/3">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>Key = public_key()</code></li>
      <li><code>Attributes = list()</code></li>
      <li><code>Type = ssh_file()</code></li>
    </ul>
  <div class="description">
    <p>Encodes a list of SSH file entries (public keys and attributes) to a binary. Possible
    attributes depend on the file type, see <a href="#ssh_decode/2" class="seealso"> ssh_decode/2 </a>.</p>
  </div>
  </div>

  <div class="function">
    <h3 id="verify/4">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The <code>Msg</code> is either the binary "plain text" data 
        or it is the hashed value of "plain text", that is, the digest.</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
      <li><code>Signature = binary()</code></li>
      <li><code>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</code></li>
  </ul>
  <div class="description">
    <p>Verifies a digital signature.</p>
  </div> 
  </div>
  
</div>


      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
