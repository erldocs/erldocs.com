<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>public_key (public_key) -  - erldocs.com (Erlang Documentation)</title>
    <link rel="search" type="application/opensearchdescription+xml" title="erldocs" href="/search.xml"/>
    <link type="text/css" rel="stylesheet" href="../erldocs.css"/>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_require', 'inpage_linkid', '//www.google-analytics.com/plugins/ga/inpage_linkid.js']);
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_setDomainName', 'erldocs.com']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>public_key</h1>
  <h2 class="modsummary"> API module for public key infrastructure.</h2>
  <div class="description">
    <p>This module provides functions to handle public key infrastructure. It can
    encode/decode different file formats (PEM, openssh), sign and verify digital signatures and validate
    certificate paths and certificate revocation lists.
    </p>
  </div>

  <div class="section">
    <h4>public_key</h4>

    <list type="bulleted">
      <item>public_key requires the crypto and asn1 applications, the latter since R16 (hopefully the runtime dependency on asn1 will
      be removed again in the future).</item>

      <item>Supports <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </url> -
      Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile </item>
      <item>Supports <url href="http://www.rsa.com/rsalabs/node.asp?id=2125"> PKCS-1 </url> - RSA Cryptography Standard </item>
      <item>Supports <url href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</url>- Digital Signature Standard (DSA - Digital Signature Algorithm)</item>
      <item>Supports <url href="http://www.rsa.com/rsalabs/node.asp?id=2126"> PKCS-3 </url> - Diffie-Hellman Key Agreement Standard </item>
      <item>Supports <url href="http://www.rsa.com/rsalabs/node.asp?id=2127"> PKCS-5</url> - Password-Based Cryptography Standard </item>
      <item>Supports <url href="http://www.rsa.com/rsalabs/node.asp?id=2130"> PKCS-8</url> - Private-Key Information Syntax Standard</item>
      <item>Supports <url href="http://www.rsa.com/rsalabs/node.asp?id=2132"> PKCS-10</url> - Certification Request Syntax Standard</item>
    </list>
  </div>

  <div class="section">
    <h4>COMMON DATA TYPES </h4> 
    
    <div class="note"><h2>Note!</h2><p>All records used in this manual 
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <a href="public_key_records.html" class="seealso">Public key records</a> and <a href="cert_records.html" class="seealso">X.509 Certificate records</a>. 
    </p></div>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide.</p>
    
    <code> -include_lib("public_key/include/public_key.hrl"). </code>

    <p><em>Data Types </em></p>
    
    <p><code>oid() - a tuple of integers as generated by the ASN1 compiler.</code></p>

    <p><code>boolean() = true | false</code></p>

    <p><code>string() = [bytes()]</code></p>

    <p><code>der_encoded() = binary()</code></p>
   
    <p><code>pki_asn1_type() = 'Certificate' | 'RSAPrivateKey'| 'RSAPublicKey' |
    'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' | 'SubjectPublicKeyInfo' |
    'PrivateKeyInfo' | 'CertificationRequest' | 'ECPrivateKey'|
    'EcpkParameters'</code></p>
    
    <p><code>pem_entry () = {pki_asn1_type(), binary(), %% DER or encrypted DER
          not_encrypted | cipher_info()} </code></p>

    <p><code>cipher_info()  =  {"RC2-CBC | "DES-CBC" | "DES-EDE3-CBC", crypto:rand_bytes(8)} |
    'PBES2-params'} </code></p>
	  
    <p><code>rsa_public_key()  = #'RSAPublicKey'{}</code></p>

    <p><code>rsa_private_key() = #'RSAPrivateKey'{} </code></p>

    <p><code>dsa_public_key() = {integer(),  #'Dss-Parms'{}} </code></p>

    <p><code>dsa_private_key() = #'DSAPrivateKey'{}</code></p>

    <p><code>ec_public_key()  = {#'ECPoint'{}, #'EcpkParameters'{} | {namedCurve, oid()}} </code></p>
    
    <p><code>ec_private_key()  = #'ECPrivateKey'{}</code></p>

    <p><code> public_crypt_options() = [{rsa_pad, rsa_padding()}]. </code></p>

    <p><code> rsa_padding() =  'rsa_pkcs1_padding' | 'rsa_pkcs1_oaep_padding'
    | 'rsa_no_padding'</code></p>
    
    <p><code> rsa_digest_type()  = 'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' | 'sha512' </code></p>

    <p><code> dss_digest_type()  = 'sha' </code></p>

    <p><code> ecdsa_digest_type()  = 'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512' </code></p>

    <p><code> crl_reason()  = unspecified | keyCompromise | cACompromise | affiliationChanged | superseded | cessationOfOperation | certificateHold | privilegeWithdrawn |  aACompromise
    </code></p>

    <p><code> ssh_file()  = openssh_public_key | rfc4716_public_key |
    known_hosts | auth_keys </code></p>
    
</div> 

<div class="functions"><h4>Functions</h4><hr  />    

  <div class="function">
    <h3 id="compute_key/2">compute_key(OthersKey, MyKey)-&gt;</h3>
    <h3 id="compute_key/3">compute_key(OthersKey, MyKey, Params)-&gt;</h3>
    
    <ul class="type">
      <li><code>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</code></li>
      <li><code>Params =  #'DHParameter'{}</code></li>
    </ul>
  <div class="description">
    <p> Compute shared secret </p>
  </div>
  </div>

  <div class="function">
    <h3 id="decrypt_private/2">decrypt_private(CipherText, Key) -&gt; binary()</h3>
    <h3 id="decrypt_private/3">decrypt_private(CipherText, Key, Options) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p>Public key decryption using the private key. See also <a href="../crypto/crypto.html#private_decrypt/4" class="seealso">crypto:private_decrypt/4</a></p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="decrypt_public/2">decrypt_public(CipherText, Key) - &gt; binary()</h3>
    <h3 id="decrypt_public/3">decrypt_public(CipherText, Key, Options) - &gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p> Public key decryption using the public key. See also <a href="../crypto/crypto.html#public_decrypt/4" class="seealso">crypto:public_decrypt/4</a></p> 
  </div> 
  </div> 

  <div class="function">
    <h3 id="der_decode/2">der_decode(Asn1type, Der) -&gt; term()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d> ASN.1 type present in the public_key applications
      asn1 specifications.</d>
      <li><code>Der = der_encoded()</code></li>
    </ul> 
    <div class="description"> 
      <p> Decodes a public key ASN.1 DER encoded entity.</p>
    </div> 
  </div>
    
  <div class="function">
    <h3 id="der_encode/2">der_encode(Asn1Type, Entity) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d> Asn1 type present in the public_key applications
	 ASN.1 specifications.</d>
      <li><code>Entity = term()</code></li>
      <d>The erlang representation of <code>Asn1Type</code></d>
  </ul> 
  <div class="description"> 
    <p> Encodes a public key entity with ASN.1 DER encoding.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="generate_key/1">generate_key(Params) -&gt; {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </h3>
    
    <ul class="type">
      <li><code> Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{} </code></li>
    </ul>
  <div class="description">
    <p>Generates a new keypair</p>
  </div>
  </div>

  <div class="function">
    <h3 id="pem_decode/1">pem_decode(PemBin) -&gt; [pem_entry()]</h3>
    
    <ul class="type">
      <li><code>PemBin = binary()</code></li>
      <d>Example {ok, PemBin} = file:read_file("cert.pem").</d>
    </ul> 
  <div class="description"> 
    <p>Decode PEM binary data and return
    entries as ASN.1 DER encoded entities.</p>
  </div> 
  </div> 
    
   <div class="function">
    <h3 id="pem_encode/1">pem_encode(PemEntries) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code> PemEntries = [pem_entry()] </code></li> 
  </ul> 
  <div class="description"> 
    <p>Creates a PEM binary</p> 
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_decode/1">pem_entry_decode(PemEntry) -&gt; term()</h3>
    <h3 id="pem_entry_decode/2">pem_entry_decode(PemEntry, Password) -&gt; term()</h3>
    
    <ul class="type">
      <li><code> PemEntry = pem_entry() </code></li> 
      <li><code> Password = string() </code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes a PEM entry. pem_decode/1 returns a list of PEM
    entries. Note that if the PEM entry is of type
    'SubjectPublickeyInfo' it will be further decoded to an
    rsa_public_key() or dsa_public_key().</p>
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_encode/2">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</h3>
    <h3 id="pem_entry_encode/4">pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = pki_asn1_type()</code></li>
      <li><code>Entity = term()</code></li>
      <d>The Erlang representation of
      <code>Asn1Type</code>.  If <code>Asn1Type</code> is 'SubjectPublicKeyInfo'
      then <code>Entity</code> must be either an rsa_public_key() or a
      dsa_public_key() and this function will create the appropriate
      'SubjectPublicKeyInfo' entry.
      </d>
      <li><code>CipherInfo = cipher_info()</code></li>
      <li><code>Password = string()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Creates a PEM entry that can be feed to pem_encode/1.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="encrypt_private/2">encrypt_private(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Public key encryption using the private key.
     See also <a href="../crypto/crypto.html#private_encrypt/4" class="seealso">crypto:private_encrypt/4</a></p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="encrypt_public/2">encrypt_public(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Public key encryption using the public key.  See also <a href="../crypto/crypto.html#public_encrypt/4" class="seealso">crypto:public_encrypt/4</a></p> 
  </div> 
  </div>   
  
  <div class="function">
    <h3 id="pkix_decode_cert/2">pkix_decode_cert(Cert, otp|plain) -&gt;  #'Certificate'{} | #'OTPCertificate'{}</h3>
    
    <ul class="type">
      <li><code>Cert = der_encoded()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes an ASN.1 DER encoded PKIX certificate.  The otp option
    will use the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_encode/3">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either .</d>
      <li><code>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</code></li>
  </ul> 
  <div class="description"> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the otp format, whereas for the plain format this
    function will directly call der_encode/2. </p> 
  </div> 
  </div>

 <div class="function">
    <h3 id="pkix_is_issuer/2">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
      <li><code>IssuerCert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if <code>IssuerCert</code> issued <code>Cert</code> </p> 
  </div> 
  </div>
  
  <div class="function">
    <h3 id="pkix_is_fixed_dh_cert/1">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
        <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if a Certificate is a fixed Diffie-Hellman Cert.</p> 
  </div> 
  </div>  
  
  <div class="function">
    <h3 id="pkix_is_self_signed/1">pkix_is_self_signed(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
       <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if a Certificate is self signed.</p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_issuer_id/2">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</h3>
    
    <ul class="type">
        <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li>
	<li><code>IssuedBy = self | other</code></li>
	<li><code>IssuerID = {integer(), {rdnSequence, [#'AttributeTypeAndValue'{}]}}</code></li>
	<d>The issuer id consists of the serial number and the issuers name.</d>
	<li><code>Reason = term()</code></li>
  </ul> 
  <div class="description"> 
    <p> Returns the issuer id.</p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_normalize_name/1">pkix_normalize_name(Issuer) -&gt; Normalized</h3>
    
    <ul class="type">
      <li><code>Issuer = {rdnSequence,[#'AttributeTypeAndValue'{}]}</code></li>
      <li><code>Normalized = {rdnSequence, [#'AttributeTypeAndValue'{}]}</code></li>
  </ul> 
  <div class="description"> 
    <p>Normalizes a issuer name so that it can be easily
    compared to another issuer name.</p> 
  </div> 
  </div>
   
  <div class="function">
    <h3 id="pkix_path_validation/3">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </h3>
    
     <ul class="type">
       <li><code> TrustedCert =  #'OTPCertificate'{} | der_encode() | unknown_ca | selfsigned_peer  </code></li>
       <d>Normally a trusted certificate but it can also be one of the path validation
       errors <code>unknown_ca </code> or <code>selfsigned_peer </code> that can be discovered while
       constructing the input to this function and that should be run through the <code>verify_fun</code>.</d>
       <li><code> CertChain = [der_encode()]</code></li>
       <d>A list of DER encoded certificates in trust order ending with the peer certificate.</d>
       <li><code> Options = proplists:proplists()</code></li>
       <li><code>PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</code></li>
       <li><code> PolicyTree = term() </code></li>
       <d>At the moment this will always be an empty list as Policies are not currently supported</d>
       <li><code> Reason = cert_expired | invalid_issuer | invalid_signature | unknown_ca |
       selfsigned_peer | name_not_permitted | missing_basic_constraint | invalid_key_usage | crl_reason()
       </code></li>
     </ul>
     <div class="description">
       <p>
	 Performs a basic path validation according to
	 <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</url>
	 However CRL validation is done separately by <a href="public_key.html#pkix_crls_validate-3" class="seealso">pkix_crls_validate/3 </a> and should be called
	 from the supplied <code>verify_fun</code>
       </p>

       <taglist>
	 <p> Available options are: </p>

	<dt>{verify_fun, fun()}</dt>
	<item>
	  <p>The fun should be defined as:</p>

	  <code>
fun(OtpCert :: #'OTPCertificate'{}, Event :: {bad_cert, Reason :: atom()} |
	                                     {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} | {valid_peer, UserState :: term()} |
	{fail, Reason :: term()} | {unknown, UserState :: term()}.
	  </code>

	<p>If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped. If the verify
	callback fun returns {valid, UserState}, the verification
	process is continued, this can be used to accept specific path
	validation errors such as <code>selfsigned_peer</code> as well as
	verifying application specific extensions.  If called with an
	extension unknown to the user application the return value
	{unknown, UserState} should be used.</p>

	</item>
	<dt>{max_path_length, integer()}</dt>
	<item>
	  The <code>max_path_length</code> is the maximum number of non-self-issued
	  intermediate certificates that may follow the peer certificate
	  in a valid certification path.  So if <code>max_path_length</code> is 0 the PEER must
	  be signed by the trusted ROOT-CA directly, if 1 the path can
	  be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	  on.
	</item>
      </taglist>
    </div>
   </div>

   <div class="function">
     <h3 id="pkix_crls_validate/3">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</h3>
     
     <ul class="type">
       <li><code> OTPCertificate =  #'OTPCertificate'{}</code></li>
       <li><code> DPAndCRLs  = [{DP::#'DistributionPoint'{} ,CRL::#'CertificateList'{}}] </code></li>
       <li><code> Options = proplists:proplists()</code></li>
       <li><code> CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</code></li>
     </ul>
     <div class="description">
      <p> Performs CRL validation. It is intended to be called from
      the verify fun of  <a href="public_key.html#pkix_path_validation-3" class="seealso"> pkix_path_validation/3
       </a></p>
      <taglist>
	<p> Available options are: </p>
	<dt>{update_crl, fun()}</dt>
	<item>
	  <p>The fun has the following type spec:</p>

	  <code> fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt; #'CertificateList'{}</code>

	  <p>The fun should use the information in the distribution point to acesses
	  the lates possible version of the CRL. If this fun is not specified
	  public_key will use the default implementation:
	  </p>
	  <code> fun(_DP, CRL) -&gt; CRL end</code>
	</item>
      </taglist>
    </div>
   </div>

  <div class="function">
    <h3 id="pkix_sign/2">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encode()</h3>
    
    <ul class="type">
      <li><code>Key = rsa_public_key() | dsa_public_key()</code></li> 
    </ul> 
    <div class="description"> 
      <p>Signs a 'OTPTBSCertificate'. Returns the corresponding
      der encoded certificate.</p> 
    </div> 
  </div> 

  <div class="function">
    <h3 id="pkix_sign_types/1">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</h3>
    
    <ul class="type">
      <li><code>AlgorithmId = oid()</code></li>
      <d>Signature oid from a certificate or a certificate revocation list</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type() </code></li>
      <li><code>SignatureType = rsa | dsa</code></li>
    </ul>
    <div class="description">
      <p>Translates signature algorithm oid to erlang digest and signature types.
      </p>
    </div>
  </div>

  <div class="function">  
    <h3 id="pkix_verify/2">pkix_verify(Cert, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encode()</code></li> 
      <li><code>Key = rsa_public_key() | dsa_public_key()</code></li> 
    </ul> 
  <div class="description"> 
    <p> Verify PKIX x.509 certificate signature.</p>
  </div> 
  </div> 

  <div class="function">
    <h3 id="sign/3">sign(Msg, DigestType, Key) -&gt; binary()</h3>
    
    <ul class="type">
       <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The msg is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text" i.e. the
       digest.</d>
       <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
       <li><code>Key = rsa_private_key() | dsa_private_key() | ec_private_key()</code></li>
  </ul>
  <div class="description">
    <p> Creates a digital signature.</p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="ssh_decode/2">ssh_decode(SshBin,  Type) -&gt; [{public_key(), Attributes::list()}]</h3>
    
    <ul class="type">
      <li><code>SshBin = binary()</code></li>
      <d>Example {ok, SshBin} = file:read_file("known_hosts").</d>
      <li><code> Type = public_key | ssh_file()</code></li>
      <d>If <code>Type</code> is <code>public_key</code> the binary may be either
      a rfc4716 public key or a openssh public key.</d>
    </ul>
  <div class="description">
    <p> Decodes a ssh file-binary. In the case of know_hosts or
    auth_keys the binary may include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <taglist>
      <dt>rfc4716 attributes - see RFC 4716</dt>
      <item>{headers, [{string(), utf8_string()}]}</item>
      <dt>auth_key attributes - see man sshd </dt>
      <item>{comment, string()}</item>
      <item>{options, [string()]}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
      <dt>known_host attributes - see man sshd</dt>
      <item>{hostnames, [string()]}</item>
      <item>{comment, string()}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
    </taglist>

  </div>
  </div>

  <div class="function">
    <h3 id="ssh_encode/3">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>Key = public_key()</code></li>
      <li><code>Attributes = list()</code></li>
      <li><code>Type = ssh_file()</code></li>
    </ul>
  <div class="description">
    <p>Encodes a list of ssh file entries (public keys and attributes) to a binary. Possible
    attributes depends on the file type, see <a href="#ssh_decode-2" class="seealso"> ssh_decode/2 </a></p>
  </div>
  </div>

  <div class="function">
    <h3 id="verify/4">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The msg is either the binary "plain text" data 
        or it is the hashed value of "plain text" i.e. the digest.</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
      <li><code>Signature = binary()</code></li>
      <li><code>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</code></li>
  </ul>
  <div class="description">
    <p>Verifies a digital signature</p>
  </div> 
  </div>
  
</div>


      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        <ul id="funs"><li><a href="#compute_key/2">compute_key/2</a></li><li><a href="#compute_key/3">compute_key/3</a></li><li><a href="#decrypt_private/2">decrypt_private/2</a></li><li><a href="#decrypt_private/3">decrypt_private/3</a></li><li><a href="#decrypt_public/2">decrypt_public/2</a></li><li><a href="#decrypt_public/3">decrypt_public/3</a></li><li><a href="#der_decode/2">der_decode/2</a></li><li><a href="#der_encode/2">der_encode/2</a></li><li><a href="#generate_key/1">generate_key/1</a></li><li><a href="#pem_decode/1">pem_decode/1</a></li><li><a href="#pem_encode/1">pem_encode/1</a></li><li><a href="#pem_entry_decode/1">pem_entry_decode/1</a></li><li><a href="#pem_entry_decode/2">pem_entry_decode/2</a></li><li><a href="#pem_entry_encode/2">pem_entry_encode/2</a></li><li><a href="#pem_entry_encode/4">pem_entry_encode/4</a></li><li><a href="#encrypt_private/2">encrypt_private/2</a></li><li><a href="#encrypt_public/2">encrypt_public/2</a></li><li><a href="#pkix_decode_cert/2">pkix_decode_cert/2</a></li><li><a href="#pkix_encode/3">pkix_encode/3</a></li><li><a href="#pkix_is_issuer/2">pkix_is_issuer/2</a></li><li><a href="#pkix_is_fixed_dh_cert/1">pkix_is_fixed_dh_cert/1</a></li><li><a href="#pkix_is_self_signed/1">pkix_is_self_signed/1</a></li><li><a href="#pkix_issuer_id/2">pkix_issuer_id/2</a></li><li><a href="#pkix_normalize_name/1">pkix_normalize_name/1</a></li><li><a href="#pkix_path_validation/3">pkix_path_validation/3</a></li><li><a href="#pkix_crls_validate/3">pkix_crls_validate/3</a></li><li><a href="#pkix_sign/2">pkix_sign/2</a></li><li><a href="#pkix_sign_types/1">pkix_sign_types/1</a></li><li><a href="#pkix_verify/2">pkix_verify/2</a></li><li><a href="#sign/3">sign/3</a></li><li><a href="#ssh_decode/2">ssh_decode/2</a></li><li><a href="#ssh_encode/3">ssh_encode/3</a></li><li><a href="#verify/4">verify/4</a></li></ul>
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
