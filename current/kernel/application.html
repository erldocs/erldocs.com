<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>application (kernel) -  (Erlang Documentation)</title>
    <link href="../erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44246018-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>application</h1>
  <h2 class="modsummary">Generic OTP application functions</h2>
  <div class="description">
    <p>In OTP, <em>application</em> denotes a component implementing
      some specific functionality, that can be started and stopped as a
      unit, and that can be reused in other systems. This
      module interacts with <em>application controller</em>, a process
      started at every Erlang runtime system. This module contains functions
      for controlling applications (for example, starting and stopping
      applications), and functions to access information about
      applications (for example, configuration parameters).</p>
    <p>An application is defined by an <em>application specification</em>.
      The specification is normally located in an
      <em>application resource file</em> named <code>Application.app</code>,
      where <code>Application</code> is the application name. For details
      about the application specification, see
    <a href="app.html" class="seealso"><code>app(4)</code></a>.</p>
    <p>This module can also be viewed as a behaviour for an application
      implemented according to the OTP design principles as a
      supervision tree. The definition of how to start and stop
      the tree is to be located in an <em>application callback module</em>,
      exporting a predefined set of functions.</p>
    <p>For details about applications and behaviours, see
    <a href="../doc/design_principles/des_princ.html" class="seealso">OTP Design Principles</a>.</p>
  </div>
  <div id="types" class="category"><h4><a href="#types">Types</a></h4><hr/>
    <div class="type">
      <h3 id="type-start_type">start_type() = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normal |<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{takeover, Node :: node()} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{failover, Node :: node()}</h3>
    </div>
    <div class="type">
      <h3 id="type-restart_type">restart_type() = permanent | transient | temporary</h3>
    </div>
    <div class="type">
      <h3 id="tuple_of/1">tuple_of(T)</h3>
      <div class="description"><p>A tuple where the elements are of type <code>T</code>.</p></div>
    </div>
  </div>
  <div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>
    <div class="function">
        <h3 id="ensure_all_started/1">ensure_all_started(Application) -&gt; {ok, Started} | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Started = [atom()]</code></li><li><code>Reason = term()</code></li></ul>
        <h3 id="ensure_all_started/2">ensure_all_started(Application, Type) -&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ok, Started} | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Type = <a href="#type-restart_type" class="seealso">restart_type()</a></code></li><li><code>Started = [atom()]</code></li><li><code>Reason = term()</code></li></ul>
        
        <div class="description">
          <p>Equivalent to calling
	  <a href="#start/1" class="seealso"><code>start/1,2</code></a>
          repeatedly on all dependencies that are not yet started for an application.</p>
          <p>Returns <code>{ok, AppNames}</code> for a successful start or for an already started
          application (which is, however, omitted from the <code>AppNames</code> list).</p>
	  <p>The function reports <code>{error, {AppName,Reason}}</code> for errors, where
	  <code>Reason</code> is any possible reason returned by
	  <a href="#start/1" class="seealso"><code>start/1,2</code></a>
	  when starting a specific dependency.</p>
	  <p>If an error occurs, the applications started by the function are stopped
	  to bring the set of running applications back to its initial state.</p>
        </div>
    </div>
    <div class="function">
      <h3 id="ensure_started/1">ensure_started(Application) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Reason = term()</code></li></ul>
      <h3 id="ensure_started/2">ensure_started(Application, Type) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Type = <a href="#type-restart_type" class="seealso">restart_type()</a></code></li><li><code>Reason = term()</code></li></ul>
      
      <div class="description">
	<p>Equivalent to
	<a href="#start/1" class="seealso"><code>start/1,2</code></a>
	except it returns <code>ok</code> for already started applications.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="get_all_env/0">get_all_env() -&gt; Env</h3>
      <ul class="type_desc"><li><code>Env = [{Par :: atom(), Val :: term()}]</code></li></ul>
      <h3 id="get_all_env/1">get_all_env(Application) -&gt; Env</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Env = [{Par :: atom(), Val :: term()}]</code></li></ul>
      
      <div class="description">
        <p>Returns the configuration parameters and their values for
          <code><anno>Application</anno></code>. If the argument is omitted, it defaults to
          the application of the calling process.</p>
        <p>If the specified application is not loaded, or if the process
          executing the call does not belong to any application,
          the function returns <code>[]</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="get_all_key/0">get_all_key() -&gt; [] | {ok, Keys}</h3>
      <ul class="type_desc"><li><code>Keys = [{Key :: atom(), Val :: term()}, ...]</code></li></ul>
      <h3 id="get_all_key/1">get_all_key(Application) -&gt; undefined | Keys</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Keys = {ok, [{Key :: atom(), Val :: term()}, ...]}</code></li></ul>
      
      <div class="description">
        <p>Returns the application specification keys and their values
          for <code><anno>Application</anno></code>. If the argument is omitted, it
          defaults to the application of the calling process.</p>
        <p>If the specified application is not loaded, the function
          returns <code>undefined</code>. If the process executing the call
          does not belong to any application, the function returns
          <code>[]</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="get_application/0">get_application() -&gt; undefined | {ok, Application}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li></ul>
      <h3 id="get_application/1">get_application(PidOrModule) -&gt; undefined | {ok, Application}</h3>
      <ul class="type_desc"><li><code>PidOrModule = (Pid :: pid()) | (Module :: module())</code></li><li><code>Application = atom()</code></li></ul>
      
      <div class="description">
        <p>Returns the name of the application to which the process
          <code><anno>Pid</anno></code> or the module <code><anno>Module</anno></code> belongs. Providing no
          argument is the same as calling
          <code>get_application(self())</code>.</p>
        <p>If the specified process does not belong to any application,
          or if the specified process or module does not exist,
          the function returns <code>undefined</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="get_env/1">get_env(Par) -&gt; undefined | {ok, Val}</h3>
      <ul class="type_desc"><li><code>Par = atom()</code></li><li><code>Val = term()</code></li></ul>
      <h3 id="get_env/2">get_env(Application, Par) -&gt; undefined | {ok, Val}</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li><li><code>Val = term()</code></li></ul>
      
      <div class="description">
        <p>Returns the value of configuration parameter <code><anno>Par</anno></code>
          for <code><anno>Application</anno></code>. If the application argument is
          omitted, it defaults to the application of the calling
          process.</p>
	  <p>Returns <code>undefined</code> if any of the following applies:</p>
	  <list type="bulleted">
	    <item>The specified application is not loaded.</item>
	    <item>The configuration parameter does not exist.</item>
	    <item>The process executing the call does not belong to any application.</item>
	  </list>
      </div>
    </div>
    <div class="function">
      <h3 id="get_env/3">get_env(Application, Par, Def) -&gt; Val</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li><li><code>Def = Val = term()</code></li></ul>
      
      <div class="description">
        <p>Works like <a href="#get_env/2" class="seealso"><code>get_env/2</code></a> but returns
          value <code><anno>Def</anno></code> when configuration parameter
          <code><anno>Par</anno></code> does not exist.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="get_key/1">get_key(Key) -&gt; undefined | {ok, Val}</h3>
      <ul class="type_desc"><li><code>Key = atom()</code></li><li><code>Val = term()</code></li></ul>
      <h3 id="get_key/2">get_key(Application, Key) -&gt; undefined | {ok, Val}</h3>
      <ul class="type_desc"><li><code>Application = Key = atom()</code></li><li><code>Val = term()</code></li></ul>
      
      <div class="description">
        <p>Returns the value of the application specification key
          <code><anno>Key</anno></code> for <code><anno>Application</anno></code>. If the application
          argument is omitted, it defaults to the application of
          the calling process.</p>
	  <p>Returns <code>undefined</code> if any of the following applies:</p>
	  <list type="bulleted">
	    <item>The specified application is not loaded.</item>
	    <item>The specification key does not exist.</item>
	    <item>The process executing the call does not belong to any application.</item>
	  </list>

      </div>
    </div>
    <div class="function">
      <h3 id="load/1">load(AppDescr) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>AppDescr = Application | (AppSpec :: <a href="#type-application_spec" class="seealso">application_spec()</a>)</code></li><li><code>Application = atom()</code></li><li><code>Reason = term()</code></li></ul>
      <h3 id="load/2">load(AppDescr, Distributed) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>AppDescr = Application | (AppSpec :: <a href="#type-application_spec" class="seealso">application_spec()</a>)</code></li><li><code>Application = atom()</code></li><li><code>Distributed = <br>
&nbsp;&nbsp;&nbsp;&nbsp;{Application, Nodes} | {Application, Time, Nodes} | default</code></li><li><code>Nodes = [node() | <a href="#type-tuple_of" class="seealso">tuple_of</a>(node())]</code></li><li><code>Time = integer() &gt;= 1</code></li><li><code>Reason = term()</code></li></ul>
      
      <ul class="type"><li><code>application_spec() = <br>
&nbsp;&nbsp;&nbsp;&nbsp;{application,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application :: atom(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppSpecKeys :: [<a href="#type-application_opt" class="seealso">application_opt()</a>]}</code></li></ul>
      <ul class="type"><li><code>application_opt() = <br>
&nbsp;&nbsp;&nbsp;&nbsp;{description, Description :: string()} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{vsn, Vsn :: string()} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{id, Id :: string()} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{modules, [Module :: module()]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{registered, Names :: [Name :: atom()]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{applications, [Application :: atom()]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{included_applications, [Application :: atom()]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{env, [{Par :: atom(), Val :: term()}]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{start_phases,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[{Phase :: atom(), PhaseArgs :: term()}] | undefined} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{maxT, MaxT :: timeout()} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{maxP, MaxP :: integer() &gt;= 1 | infinity} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;{mod, Start :: {Module :: module(), StartArgs :: term()}}</code></li></ul>
      <div class="description">
        <p>Loads the application specification for an application into
          the application controller. It also loads the application
          specifications for any included applications. Notice that
          the function does not load the Erlang object code.</p>
        <p>The application can be specified by its name <code><anno>Application</anno></code>.
          In this case, the application controller searches the code
          path for the application resource file <code><anno>Application</anno>.app</code>
          and loads the specification it contains.</p>
        <p>The application specification can also be specified directly as a
          tuple <code><anno>AppSpec</anno></code>, having the format and
          contents as described in
	<a href="app.html" class="seealso"><code>app(4)</code></a>.</p>
        <p>If <code><anno>Distributed</anno> == {<anno>Application</anno>,[<anno>Time</anno>,]<anno>Nodes</anno>}</code>,
          the application becomes distributed. The argument overrides
          the value for the application in the Kernel configuration
          parameter <code>distributed</code>. <code><anno>Application</anno></code> must be
          the application name (same as in the first argument).
          If a node crashes and <code><anno>Time</anno></code> is specified,
          the application controller waits for <code><anno>Time</anno></code>
          milliseconds before attempting to restart the application on
          another node. If <code><anno>Time</anno></code> is not specified, it
          defaults to <code>0</code> and the application is restarted
          immediately.</p>
        <p><code><anno>Nodes</anno></code> is a list of node names where the application
          can run, in priority from left to right. Node names can be
          grouped using tuples to indicate that they have the same
          priority.</p>
	  <p><em>Example:</em></p>
        <pre class="sh_erlang">
Nodes = [cp1@cave, {cp2@cave, cp3@cave}]</pre>
        <p>This means that the application is preferably to be started
          at <code>cp1@cave</code>. If <code>cp1@cave</code> is down,
          the application is to be started at <code>cp2@cave</code>
          or <code>cp3@cave</code>.</p>
        <p>If <code>Distributed == default</code>, the value for
          the application in the Kernel configuration parameter
          <code>distributed</code> is used.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="loaded_applications/0">loaded_applications() -&gt; [{Application, Description, Vsn}]</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Description = Vsn = string()</code></li></ul>
      
      <div class="description">
        <p>Returns a list with information about the applications, and included
	  applications, which are loaded using <code>load/1,2</code>.
          <code><anno>Application</anno></code> is the application name.
          <code><anno>Description</anno></code> and <code><anno>Vsn</anno></code> are the values
	  of their <code>description</code> and <code>vsn</code> application specification
          keys, respectively.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="permit/2">permit(Application, Permission) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Permission = boolean()</code></li><li><code>Reason = term()</code></li></ul>
      
      <div class="description">
        <p>Changes the permission for <code><anno>Application</anno></code> to run at
          the current node. The application must be loaded using
          <code>load/1,2</code> for the function to have effect.</p>
        <p>If the permission of a loaded, but not started, application
          is set to <code>false</code>, <code>start</code> returns <code>ok</code> but
          the application is not started until the permission is
          set to <code>true</code>.</p>
        <p>If the permission of a running application is set to
          <code>false</code>, the application is stopped. If
          the permission later is set to <code>true</code>, it is
          restarted.</p>
        <p>If the application is distributed, setting the permission to
          <code>false</code> means that the application will be started at, or
          moved to, another node according to how its distribution is
          configured
	(see <a href="#load/2" class="seealso"><code>load/2</code></a>).</p>
        <p>The function does not return until the application is
          started, stopped, or successfully moved to another node.
          However, in some cases where permission is set to <code>true</code>,
          the function returns <code>ok</code> even though the application
          is not started. This is true when an application
          cannot start because of dependencies to other
          applications that are not yet started. When they are
          started, <code>Application</code> is started as well.</p>
        <p>By default, all applications are loaded with permission
          <code>true</code> on all nodes. The permission can be configured
          using the Kernel configuration parameter <code>permissions</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="set_env/3">set_env(Application, Par, Val) -&gt; ok</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li><li><code>Val = term()</code></li></ul>
      <h3 id="set_env/4">set_env(Application, Par, Val, Opts) -&gt; ok</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li><li><code>Val = term()</code></li><li><code>Opts = [{timeout, timeout()} | {persistent, boolean()}]</code></li></ul>
      
      <div class="description">
        <p>Sets the value of configuration parameter <code><anno>Par</anno></code> for
          <code><anno>Application</anno></code>.</p>
        <p><code>set_env/4</code> uses the standard <code>gen_server</code> time-out
          value (5000 ms). Option <code>timeout</code> can be specified
          if another time-out value is useful, for example, in situations
          where the application controller is heavily loaded.</p>
        <p>If <code>set_env/4</code> is called before the application is loaded,
          the application environment values specified in file <code>Application.app</code>
          override the ones previously set. This is also true for application
          reloads.</p>
        <p>Option <code>persistent</code> can be set to <code>true</code>
          to guarantee that parameters set with <code>set_env/4</code>
          are not overridden by those defined in the application resource
          file on load. This means that persistent values will stick after the application
          is loaded and also on application reload.</p>
        <div class="warning"><h2>Warning!</h2>
          <p>Use this function only if you know what you are doing,
            that is, on your own applications. It is very
	    application-dependent and
	    configuration parameter-dependent when and how often
            the value is read by the application. Careless use
            of this function can put the application in a
            weird, inconsistent, and malfunctioning state.</p>
        </div>
      </div>
    </div>
    <div class="function">
      <h3 id="start/1">start(Application) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Reason = term()</code></li></ul>
      <h3 id="start/2">start(Application, Type) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Type = <a href="#type-restart_type" class="seealso">restart_type()</a></code></li><li><code>Reason = term()</code></li></ul>
      
       <div class="description">
        <p>Starts <code><anno>Application</anno></code>. If it is not loaded,
          the application controller first loads it using
          <code>load/1</code>. It ensures that any included applications
          are loaded, but does not start them. That is assumed to be
          taken care of in the code for <code><anno>Application</anno></code>.</p>
        <p>The application controller checks the value of
          the application specification key <code>applications</code>, to
          ensure that all applications needed to be started before
          this application are running. Otherwise,
          <code>{error,{not_started,App}}</code> is returned, where <code>App</code>
          is the name of the missing application.</p>
        <p>The application controller then creates an <em>application master</em>
          for the application. The application master becomes the
          group leader of all the processes in the application. I/O is
          forwarded to the previous group leader, though, this is just
          a way to identify processes that belong to the application.
          Used for example to find itself from any process, or,
          reciprocally, to kill them all when it terminates.</p>
        <p>
          The application master starts the application by calling
          the application callback function <code>Module:start/2</code> as
          defined by the application specification key <code>mod</code>.</p>
        <p>Argument <code><anno>Type</anno></code> specifies the type of
          the application. If omitted, it defaults to <code>temporary</code>.</p>
        <list type="bulleted">
          <item>If a permanent application terminates, all other
           applications and the entire Erlang node are also terminated.</item>
          <item>
	    <list type="bulleted">
	      <item>If a transient application terminates with <code>Reason == normal</code>,
	      this is reported but no other applications are terminated.</item>
	      <item>If a transient application terminates abnormally, all other
	      applications and the entire Erlang node are also terminated.</item>
	    </list>
	   </item>
          <item>If a temporary application terminates, this is reported
           but no other applications are terminated.</item>
        </list>
        <p>Notice that an application can always be stopped
          explicitly by calling <code>stop/1</code>. Regardless of the type of
          the application, no other applications are affected.</p>
        <p>Notice also that the transient type is of little practical use,
          because when a supervision tree terminates, the reason is set to
          <code>shutdown</code>, not <code>normal</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="start_type/0">start_type() -&gt; StartType | undefined | local</h3>
      <ul class="type_desc"><li><code>StartType = <a href="#type-start_type" class="seealso">start_type()</a></code></li></ul>
      
      <div class="description">
        <p>This function is intended to be called by a process belonging
          to an application, when the application is started, to
          determine the start type, which is <code><anno>StartType</anno></code> or
          <code>local</code>.</p>
        <p>For a description of <code><anno>StartType</anno></code>, see
	  <a href="#start_type" class="seealso"><code>Module:start/2</code></a>.</p>
        <p><code>local</code> is returned if only parts of the application are
          restarted (by a supervisor), or if the function is
          called outside a startup.</p>
        <p>If the process executing the call does not belong to any
          application, the function returns <code>undefined</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="stop/1">stop(Application) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Reason = term()</code></li></ul>
      
      <div class="description">
        <p>Stops <code><anno>Application</anno></code>. The application master calls
          <code>Module:prep_stop/1</code>, if such a function is defined, and
          then tells the top supervisor of the application to shut down
          (see <a href="../stdlib/supervisor.html" class="seealso"><code>supervisor(3)</code></a>).
	  This means that the entire
          supervision tree, including included applications, is
          terminated in reversed start order. After the shutdown,
          the application master calls <code>Module:stop/1</code>.
          <code>Module</code> is the callback module as defined by
          the application specification key <code>mod</code>.</p>
        <p>Last, the application master terminates. Notice that all
          processes with the application master as group leader, that is,
          processes spawned from a process belonging to the application,
          are also terminated.</p>
        <p>When stopped, the application is still loaded.</p>
        <p>To stop a distributed application, <code>stop/1</code>
          must be called on all nodes where it can execute (that is,
          on all nodes where it has been started). The call to
          <code>stop/1</code> on the node where the application currently
          executes stops its execution. The application is not
          moved between nodes, as <code>stop/1</code> is called on
          the node where the application currently executes before
          <code>stop/1</code> is called on the other nodes.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="takeover/2">takeover(Application, Type) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Type = <a href="#type-restart_type" class="seealso">restart_type()</a></code></li><li><code>Reason = term()</code></li></ul>
      
      <div class="description">
        <p>Takes over the distributed application
          <code><anno>Application</anno></code>, which executes at another node
          <code>Node</code>. At the current node, the application is
          restarted by calling
          <code>Module:start({takeover,Node},StartArgs)</code>. <code>Module</code>
          and <code>StartArgs</code> are retrieved from the loaded application
          specification. The application at the other node is not
          stopped until the startup is completed, that is, when
          <code>Module:start/2</code> and any calls to
          <code>Module:start_phase/3</code> have returned.</p>
        <p>Thus, two instances of the application run simultaneously
          during the takeover, so that data can be transferred
          from the old to the new instance. If this is not an acceptable
          behavior, parts of the old instance can be shut down when
          the new instance is started. However, the application cannot
          be stopped entirely, at least the top supervisor
          must remain alive.</p>
        <p>For a description of <code>Type</code>, see
	<a href="#start/1" class="seealso"><code>start/1,2</code></a>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="unload/1">unload(Application) -&gt; ok | {error, Reason}</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Reason = term()</code></li></ul>
      
      <div class="description">
        <p>Unloads the application specification for <code><anno>Application</anno></code>
          from the application controller. It also unloads
          the application specifications for any included applications.
          Notice that the function does not purge the Erlang
          object code.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="unset_env/2">unset_env(Application, Par) -&gt; ok</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li></ul>
      <h3 id="unset_env/3">unset_env(Application, Par, Opts) -&gt; ok</h3>
      <ul class="type_desc"><li><code>Application = Par = atom()</code></li><li><code>Opts = [{timeout, timeout()} | {persistent, boolean()}]</code></li></ul>
      
      <div class="description">
        <p>Removes the configuration parameter <code><anno>Par</anno></code> and its value
          for <code><anno>Application</anno></code>.</p>
        <p><code>unset_env/2</code> uses the standard <code>gen_server</code>
          time-out value (5000 ms). Option <code>timeout</code> can be
          specified if another time-out value is useful, for example, in
          situations where the application controller is heavily loaded.</p>
        <p><code>unset_env/3</code> also allows the persistent option to be passed
          (see <a href="#set_env/4" class="seealso"><code>set_env/4</code></a>).</p>
	<div class="warning"><h2>Warning!</h2>
          <p>Use this function only if you know what you are doing,
            that is, on your own applications. It is very
	    application-dependent and configuration
	    parameter-dependent when and how often
            the value is read by the application. Careless use
            of this function can put the application in a
            weird, inconsistent, and malfunctioning state.</p>
        </div>
      </div>
    </div>
    <div class="function">
      <h3 id="which_applications/0">which_applications() -&gt; [{Application, Description, Vsn}]</h3>
      <ul class="type_desc"><li><code>Application = atom()</code></li><li><code>Description = Vsn = string()</code></li></ul>
      <h3 id="which_applications/1">which_applications(Timeout) -&gt; [{Application, Description, Vsn}]</h3>
      <ul class="type_desc"><li><code>Timeout = timeout()</code></li><li><code>Application = atom()</code></li><li><code>Description = Vsn = string()</code></li></ul>
      
      <div class="description">
        <p>Returns a list with information about the applications that
          are currently running. <code><anno>Application</anno></code> is the application
          name. <code><anno>Description</anno></code> and <code><anno>Vsn</anno></code> are the
	  values of their <code>description</code> and <code>vsn</code> application specification
          keys, respectively.</p>
        <p><code>which_applications/0</code> uses the standard
          <code>gen_server</code> time-out value (5000 ms). A <code><anno>Timeout</anno></code>
          argument can be specified if another time-out value is useful,
          for example, in situations where the application controller
          is heavily loaded.</p>
      </div>
    </div>
  </div>

  <div class="section">
    <h4>Callback Module</h4>
    <p>The following functions are to be exported from an
      <code>application</code> callback module.</p>
  </div>
  <div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>
    <div class="function">
      <h3 id="start/2">Module:start(StartType, StartArgs) -&gt; {ok, Pid} | {ok, Pid, State} | {error, Reason}</h3>
      
      <ul class="type">
        <li><code>StartType = <a href="#type-start_type" class="seealso"><code>start_type()</code></a></code></li>
        <li><code>StartArgs = term()</code></li>
        <li><code>Pid = pid()</code></li>
        <li><code>State = term()</code></li>
      </ul>
      <div class="description">
        <p>This function is called whenever an application is started
          using <code>start/1,2</code>, and is to start
          the processes of the application. If the application is
          structured according to the OTP design principles as a
          supervision tree, this means starting the top supervisor of
          the tree.</p>
        <p><span id="start_type"> </span><code>StartType</code> defines the type of start:</p>
        <list type="bulleted">
          <item><code>normal</code> if it is a normal startup.</item>
          <item><code>normal</code> also if the application is distributed and
           started at the current node because of a failover from another
           node, and the application specification key <code>start_phases == undefined</code>.</item>
          <item><code>{takeover,Node}</code> if the application is
           distributed and started at the current node because of a
           takeover from <code>Node</code>, either because
          <code>takeover/2</code> has been called or because
           the current node has higher priority than <code>Node</code>.</item>
          <item><code>{failover,Node}</code> if the application is
           distributed and started at the current node because of a
           failover from <code>Node</code>, and the application
           specification key <code>start_phases /= undefined</code>.</item>
        </list>
        <p><code>StartArgs</code> is the <code>StartArgs</code> argument defined by
          the application specification key <code>mod</code>.</p>
        <p>The function is to return <code>{ok,Pid}</code> or
          <code>{ok,Pid,State}</code>, where <code>Pid</code> is the pid of the top
          supervisor and <code>State</code> is any term. If omitted,
          <code>State</code> defaults to <code>[]</code>. If the application
          is stopped later, <code>State</code> is passed to
          <code>Module:prep_stop/1</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="start_phase/3">Module:start_phase(Phase, StartType, PhaseArgs) -&gt; ok | {error, Reason}</h3>
      
      <ul class="type">
        <li><code>Phase = atom()</code></li>
        <li><code>StartType = <a href="#type-start_type" class="seealso"><code>start_type()</code></a></code></li>
        <li><code>PhaseArgs = term()</code></li>
        <li><code>Pid = pid()</code></li>
        <li><code>State = state()</code></li>
      </ul>
      <div class="description">
        <p>Starts an application with included
          applications, when synchronization is needed between
          processes in the different applications during startup.</p>
        <p>The start phases are defined by the application specification
          key <code>start_phases == [{Phase,PhaseArgs}]</code>. For included
          applications, the set of phases must be a subset of the set of
          phases defined for the including application.</p>
        <p>The function is called for each start phase (as defined for
          the primary application) for the primary application and all
          included applications, for which the start phase is defined.</p>
        <p>For a description of <code>StartType</code>, see
	<a href="../Module/start/2.html" class="seealso"><code>Module:start/2</code></a>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="prep_stop/1">Module:prep_stop(State) -&gt; NewState</h3>
      
      <ul class="type">
        <li><code>State = NewState = term()</code></li>
      </ul>
      <div class="description">
        <p>This function is called when an application is about to be
          stopped, before shutting down the processes of
          the application.</p>
        <p><code>State</code> is the state returned from
          <code>Module:start/2</code>, or <code>[]</code> if no state was returned.
          <code>NewState</code> is any term and is passed to
          <code>Module:stop/1</code>.</p>
        <p>The function is optional. If it is not defined, the processes
          are terminated and then <code>Module:stop(State)</code> is called.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="stop/1">Module:stop(State)</h3>
      
      <ul class="type">
        <li><code>State = term()</code></li>
      </ul>
      <div class="description">
        <p>This function is called whenever an application has stopped.
          It is intended to be the opposite of <code>Module:start/2</code>
          and is to do any necessary cleaning up. The return value is
          ignored.</p>
        <p><code>State</code> is the return value of <code>Module:prep_stop/1</code>,
	  if such a function exists. Otherwise <code>State</code> is taken from
	  the return value of <code>Module:start/2</code>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="config_change/3">Module:config_change(Changed, New, Removed) -&gt; ok</h3>
      
      <ul class="type">
        <li><code>Changed = [{Par,Val}]</code></li>
        <li><code>New = [{Par,Val}]</code></li>
        <li><code>Removed = [Par]</code></li>
        <li><code> Par = atom()</code></li>
        <li><code> Val = term()</code></li>
      </ul>
      <div class="description">
        <p>This function is called by an application after a code
          replacement, if the configuration parameters have changed.</p>
        <p><code>Changed</code> is a list of parameter-value tuples including all
          configuration parameters with changed values.</p>
	<p><code>New</code> is a list of parameter-value tuples including all
	  added configuration parameters.</p>
	<p><code>Removed</code> is a list of all removed parameters.</p>
      </div>
    </div>
  </div>

  <div class="section">
    <h4>See Also</h4>
    <p><a href="../doc/design_principles/des_princ.html" class="seealso">OTP Design Principles</a>,
      <a href="kernel_app.html" class="seealso">kernel(6)</a>,
      <a href="app.html" class="seealso">app(4)</a></p>
  </div>

      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
