<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>crypto (crypto) -  (Erlang Documentation)</title>
    <link href="../erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44246018-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>crypto</h1>
  <h2 class="modsummary">Crypto Functions</h2>
  <div class="description">
    <p>This module provides a set of cryptographic functions.
      </p>
    <list type="bulleted">
      <item>
	<p>Hash functions -
	<url href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf"> Secure Hash Standard</url>,
	<url href="http://www.ietf.org/rfc/rfc1321.txt"> The MD5 Message Digest Algorithm (RFC 1321)</url> and
	<url href="http://www.ietf.org/rfc/rfc1320.txt">The MD4 Message Digest Algorithm (RFC 1320)</url>
	</p>
      </item>
      <item>
        <p>Hmac functions - <url href="http://www.ietf.org/rfc/rfc2104.txt"> Keyed-Hashing for Message Authentication (RFC 2104) </url></p>
      </item>
      <item>
        <p>Cmac functions - <url href="http://www.ietf.org/rfc/rfc4493.txt">The AES-CMAC Algorithm (RFC 4493)</url></p>
      </item>
      <item>
        <p>Block ciphers - <url href="http://csrc.nist.gov/groups/ST/toolkit/block_ciphers.html"> </url> DES and AES in
        Block Cipher Modes - <url href="http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html"> ECB, CBC, CFB, OFB, CTR and GCM </url></p>
      </item>
      <item>
        <p><url href="http://www.ietf.org/rfc/rfc1321.txt"> RSA encryption RFC 1321 </url> </p>
      </item>
      <item>
        <p>Digital signatures <url href="http://csrc.nist.gov/publications/drafts/fips186-3/fips_186-3.pdf">Digital Signature Standard (DSS)</url> and<url href="http://csrc.nist.gov/groups/STM/cavp/documents/dss2/ecdsa2vs.pdf"> Elliptic Curve Digital
	Signature Algorithm (ECDSA) </url> </p>
      </item>
      <item>
        <p><url href="http://www.ietf.org/rfc/rfc2945.txt"> Secure Remote Password Protocol (SRP - RFC 2945) </url></p>
      </item>
      <item>
        <p>gcm: Dworkin, M., "Recommendation for Block Cipher Modes of
        Operation: Galois/Counter Mode (GCM) and GMAC",
        National Institute of Standards and Technology SP 800-
        38D, November 2007.</p>
      </item>
    </list>
  </div>

 <div class="section">
    <h4>DATA TYPES </h4>

    <code>key_value() = integer() | binary() </code>
    <p>Always <code>binary()</code> when used as return value</p>

    <code>rsa_public() = [key_value()] = [E, N]  </code>
    <p> Where E is the public exponent and N is public modulus. </p>

    <code>rsa_private() = [key_value()] = [E, N, D] | [E, N, D, P1, P2, E1, E2, C] </code>
    <p>Where E is the public exponent, N is public modulus and D is
    the private exponent. The longer key format contains redundant
    information that will make the calculation faster. P1,P2 are first
    and second prime factors. E1,E2 are first and second exponents. C
    is the CRT coefficient. Terminology is taken from <url href="http://www.ietf.org/rfc/rfc3477.txt"> RFC 3447</url>.</p>

    <code>dss_public() = [key_value()] = [P, Q, G, Y] </code>
    <p>Where P, Q and G are the dss parameters and Y is the public key.</p>

    <code>dss_private() = [key_value()] = [P, Q, G, X] </code>
    <p>Where P, Q and G are the dss parameters and X is the private key.</p>

    <code>srp_public() = key_value() </code>
    <p>Where is <code>A</code> or <code>B</code> from <url href="http://srp.stanford.edu/design.html">SRP design</url></p>

    <code>srp_private() = key_value() </code>
    <p>Where is  <code>a</code> or <code>b</code> from <url href="http://srp.stanford.edu/design.html">SRP design</url></p>

    <p>Where Verifier is <code>v</code>, Generator is <code>g</code> and Prime is<code> N</code>, DerivedKey is <code>X</code>, and Scrambler is
    <code>u</code> (optional will be generated if not provided) from <url href="http://srp.stanford.edu/design.html">SRP design</url>
    Version = '3' |  '6' |  '6a'
    </p>

    <code>dh_public() = key_value() </code>

    <code>dh_private() = key_value() </code>

    <code>dh_params() = [key_value()] = [P, G] | [P, G, PrivateKeyBitLength]</code>

    <code>ecdh_public() = key_value() </code>

    <code>ecdh_private() = key_value() </code>

    <code>ecdh_params() = ec_named_curve() | ec_explicit_curve()</code>

    <code>ec_explicit_curve() =
    {ec_field(), Prime :: key_value(), Point :: key_value(), Order :: integer(),
     CoFactor :: none | integer()} </code>

    <code>ec_field() = {prime_field, Prime :: integer()} |
    {characteristic_two_field, M :: integer(), Basis :: ec_basis()}</code>

    <code>ec_basis() = {tpbasis, K :: non_neg_integer()} |
    {ppbasis, K1 :: non_neg_integer(), K2 :: non_neg_integer(), K3 :: non_neg_integer()} |
    onbasis</code>

    <code>ec_named_curve() -&gt;
      sect571r1| sect571k1| sect409r1| sect409k1| secp521r1| secp384r1| secp224r1| secp224k1|
      secp192k1| secp160r2| secp128r2| secp128r1| sect233r1| sect233k1| sect193r2| sect193r1|
      sect131r2| sect131r1| sect283r1| sect283k1| sect163r2| secp256k1| secp160k1| secp160r1|
      secp112r2| secp112r1| sect113r2| sect113r1| sect239k1| sect163r1| sect163k1| secp256r1|
      secp192r1|
      brainpoolP160r1| brainpoolP160t1| brainpoolP192r1| brainpoolP192t1| brainpoolP224r1|
      brainpoolP224t1| brainpoolP256r1| brainpoolP256t1| brainpoolP320r1| brainpoolP320t1|
      brainpoolP384r1| brainpoolP384t1| brainpoolP512r1| brainpoolP512t1
    </code>
    <p>Note that the <em>sect</em> curves are GF2m (characteristic two) curves and are only supported if the
    underlying OpenSSL has support for them.
    See also <a href="#supports/0" class="seealso">crypto:supports/0</a>
    </p>

    <span id="type-engine_key_ref"> </span>
    <span id="engine_key_ref_type"> </span>
    <code>engine_key_ref() = #{engine   := engine_ref(),
                               key_id   := key_id(),
                               password =&gt; password()}</code>

    <code>engine_ref() = term()</code>
    <p>The result of a call to <a href="#engine_load/3" class="seealso">engine_load/3</a>.
    </p>

    <code>key_id() = string() | binary()</code>
    <p>Identifies the key to be used. The format depends on the loaded engine. It is passed to
    the <code>ENGINE_load_(private|public)_key</code> functions in libcrypto.
    </p>

    <code>password() = string() | binary()</code>
    <p>The key's password
    </p>

     <code>stream_cipher() = rc4 | aes_ctr </code>

     <code>block_cipher() = aes_cbc | aes_cfb8 | aes_cfb128 | aes_ige256 | blowfish_cbc |
     blowfish_cfb64 | des_cbc | des_cfb | des3_cbc | des3_cfb | des_ede3 | rc2_cbc </code>

     <code>aead_cipher() = aes_gcm | chacha20_poly1305 </code>

     <code>stream_key() = aes_key() | rc4_key() </code>

     <code>block_key() = aes_key() |  blowfish_key() | des_key()| des3_key() </code>

     <code>aes_key() = iodata() </code> <p>Key length is 128, 192 or 256 bits</p>

     <code>rc4_key() = iodata() </code> <p>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</p>

     <code>blowfish_key() = iodata() </code> <p>Variable key length from 32 bits up to 448 bits</p>

     <code>des_key() = iodata() </code> <p>Key length is 64 bits (in CBC mode only 8 bits are used)</p>

     <code>des3_key() = [binary(), binary(), binary()] </code> <p>Each key part is 64 bits (in CBC mode only 8 bits are used)</p>

     <code>digest_type() =  md5 | sha | sha224 | sha256 | sha384 | sha512</code>

     <code>rsa_digest_type() = md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512</code>

     <code>dss_digest_type() = sha | sha224 | sha256 | sha384 | sha512</code> <p>Note that the actual supported
     dss_digest_type depends on the underlying crypto library. In OpenSSL version &gt;= 1.0.1 the listed digest are supported, while in 1.0.0 only sha, sha224 and sha256 are supported. In version 0.9.8 only sha is supported.</p>

     <code>ecdsa_digest_type() = sha | sha224 | sha256 | sha384 | sha512</code>

     <code>sign_options() = [{rsa_pad, rsa_sign_padding()} | {rsa_pss_saltlen, integer()}]</code>

     <code>rsa_sign_padding() = rsa_pkcs1_padding | rsa_pkcs1_pss_padding</code>

     <code> hash_algorithms() =  md5 | ripemd160 | sha | sha224 | sha256 | sha384 | sha512 </code> <p>md4 is also supported for hash_init/1 and hash/2.
     Note that both md4 and md5 are recommended only for compatibility with existing applications.
     </p>
     <code> cipher_algorithms() = aes_cbc | aes_cfb8 | aes_cfb128 | aes_ctr | aes_gcm |
     aes_ige256 | blowfish_cbc | blowfish_cfb64 | chacha20_poly1305 | des_cbc |
     des_cfb | des3_cbc | des3_cfb | des_ede3 | rc2_cbc | rc4 </code>
     <code> mac_algorithms() = hmac | cmac</code>
     <code> public_key_algorithms() = rsa |dss | ecdsa | dh | ecdh | ec_gf2m</code>
     <p>Note that ec_gf2m is not strictly a public key algorithm, but a restriction on what curves are supported
     with ecdsa and ecdh.
     </p>
     <code>engine_method_type() = engine_method_rsa | engine_method_dsa | engine_method_dh |
     engine_method_rand | engine_method_ecdh | engine_method_ecdsa |
     engine_method_ciphers | engine_method_digests | engine_method_store |
     engine_method_pkey_meths | engine_method_pkey_asn1_meths</code>

 </div>

  <div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>
    <div class="function">
      <h3 id="block_encrypt/3">block_encrypt(Type, Key, PlainText) -&gt; CipherText</h3>
      
      <ul class="type">
  <li><code>Type = des_ecb | blowfish_ecb | aes_ecb </code></li>
  <li><code>Key = block_key() </code></li>
        <li><code>PlainText = iodata() </code></li>
      </ul>
      <div class="description">
        <p>Encrypt <code>PlainText</code> according to <code>Type</code> block cipher.</p>
  <p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
  is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="block_decrypt/3">block_decrypt(Type, Key, CipherText) -&gt; PlainText</h3>
      
      <ul class="type">
  <li><code>Type = des_ecb | blowfish_ecb | aes_ecb </code></li>
  <li><code>Key = block_key() </code></li>
        <li><code>PlainText = iodata() </code></li>
      </ul>
      <div class="description">
        <p>Decrypt <code>CipherText</code> according to <code>Type</code> block cipher.</p>
  <p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
  is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="block_encrypt/4">block_encrypt(Type, Key, Ivec, PlainText) -&gt; CipherText</h3>
      <h3 id="block_encrypt/5">block_encrypt(AeadType, Key, Ivec, {AAD, PlainText}) -&gt; {CipherText, CipherTag}</h3>
      <h3 id="block_encrypt/6">block_encrypt(aes_gcm, Key, Ivec, {AAD, PlainText, TagLength}) -&gt; {CipherText, CipherTag}</h3>
      
      <ul class="type">
	<li><code>Type = block_cipher() </code></li>
	<li><code>AeadType = aead_cipher() </code></li>
	<li><code>Key = block_key() </code></li>
        <li><code>PlainText = iodata() </code></li>
        <li><code>AAD = IVec = CipherText = CipherTag = binary()</code></li>
        <li><code>TagLength = 1..16</code></li>
      </ul>
      <div class="description">
        <p>Encrypt <code>PlainText</code> according to <code>Type</code> block cipher.
	<code>IVec</code> is an arbitrary initializing vector.</p>
	<p>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt
	<code>PlainText</code>according to <code>Type</code> block cipher and calculate
	<code>CipherTag</code> that also authenticates the <code>AAD</code> (Associated Authenticated Data).</p>
	<p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
	is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="block_decrypt/4">block_decrypt(Type, Key, Ivec, CipherText) -&gt; PlainText</h3>
      <h3 id="block_decrypt/6">block_decrypt(AeadType, Key, Ivec, {AAD, CipherText, CipherTag}) -&gt; PlainText | error</h3>
      
      <ul class="type">
	<li><code>Type = block_cipher() </code></li>
	<li><code>AeadType = aead_cipher() </code></li>
	<li><code>Key = block_key() </code></li>
        <li><code>PlainText = iodata() </code></li>
        <li><code>AAD = IVec = CipherText = CipherTag = binary()</code></li>
      </ul>
      <div class="description">
        <p>Decrypt <code>CipherText</code> according to <code>Type</code> block cipher.
	<code>IVec</code> is an arbitrary initializing vector.</p>
        <p>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt
	<code>CipherText</code>according to <code>Type</code> block cipher and check the authenticity
	the <code>PlainText</code> and <code>AAD</code> (Associated Authenticated Data) using the
	<code>CipherTag</code>. May return <code>error</code> if the decryption or validation fail's</p>
	<p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
	is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

     <div class="function">
      <h3 id="bytes_to_integer/1">bytes_to_integer(Bin) -&gt; Integer </h3>
      
      <ul class="type">
	<li><code>Bin = binary() - as returned by crypto functions</code></li>

        <li><code>Integer = integer() </code></li>
      </ul>
      <div class="description">
        <p>Convert binary representation, of an integer, to an Erlang integer.
         </p>
      </div>
    </div>

    <div class="function">
      <h3 id="compute_key/4">compute_key(Type, OthersPublicKey, MyKey, Params) -&gt; SharedSecret</h3>
      
      <ul class="type">
	<li><code> Type = dh | ecdh | srp </code></li>
	<li><code>OthersPublicKey =  dh_public() | ecdh_public() | srp_public() </code></li>
	<li><code>MyKey = dh_private() | ecdh_private() | {srp_public(),srp_private()}</code></li>
	<li><code>Params = dh_params() | ecdh_params() | SrpUserParams | SrpHostParams</code></li>
	<li><code>SrpUserParams = {user, [DerivedKey::binary(), Prime::binary(), Generator::binary(), Version::atom() | [Scrambler:binary()]]} </code></li>
	<li><code>SrpHostParams = {host, [Verifier::binary(), Prime::binary(), Version::atom() | [Scrambler::binary]]} </code></li>
	<li><code>SharedSecret = binary()</code></li>
      </ul>
      <div class="description">
	<p>Computes the shared secret from the private key and the other party's public key.
	 See also <a href="../public_key/public_key.html#compute_key/2" class="seealso">public_key:compute_key/2</a>
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="exor/2">exor(Data1, Data2) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Data1, Data2 = iodata()</code></li>
	<li><code>Result = binary()</code></li>
      </ul>
      <div class="description">
	<p>Performs bit-wise XOR (exclusive or) on the data supplied.</p>
      </div>
    </div>

   <div class="function">
      <h3 id="generate_key/2">generate_key(Type, Params) -&gt; {PublicKey, PrivKeyOut} </h3>
      <h3 id="generate_key/3">generate_key(Type, Params, PrivKeyIn) -&gt; {PublicKey, PrivKeyOut} </h3>
      
      <ul class="type">
	<li><code> Type = dh | ecdh | rsa | srp </code></li>
	<li><code>Params = dh_params() | ecdh_params() | RsaParams | SrpUserParams | SrpHostParams </code></li>
	<li><code>RsaParams = {ModulusSizeInBits::integer(), PublicExponent::key_value()}</code></li>
	<li><code>SrpUserParams = {user, [Generator::binary(), Prime::binary(), Version::atom()]}</code></li>
	<li><code>SrpHostParams = {host, [Verifier::binary(), Generator::binary(), Prime::binary(), Version::atom()]}</code></li>
	<li><code>PublicKey =  dh_public() | ecdh_public() | rsa_public() | srp_public() </code></li>
	<li><code>PrivKeyIn = undefined | dh_private() | ecdh_private() | srp_private() </code></li>
	<li><code>PrivKeyOut =  dh_private() | ecdh_private() | rsa_private() | srp_private() </code></li>
      </ul>
      <div class="description">
	<p>Generates a public key of type <code>Type</code>.
	See also <a href="../public_key/public_key.html#generate_key/1" class="seealso">public_key:generate_key/1</a>.
	May throw exception an exception of class <code>error</code>:
        </p>
        <list type="bulleted">
          <item><code>badarg</code>: an argument is of wrong type or has an illegal value,</item>
	  <item><code>low_entropy</code>: the random generator failed due to lack of secure "randomness",</item>
          <item><code>computation_failed</code>: the computation fails of another reason than <code>low_entropy</code>.</item>
        </list>
	<div class="note"><h2>Note!</h2>
	  <p>RSA key generation is only available if the runtime was
	  built with dirty scheduler support. Otherwise, attempting to
	  generate an RSA key will throw exception <code>error:notsup</code>.</p>
	</div>
      </div>
    </div>

     <div class="function">
      <h3 id="hash/2">hash(Type, Data) -&gt; Digest</h3>
      
      <ul class="type">
	<li><code>Type = md4 | hash_algorithms()</code></li>
	<li><code>Data = iodata()</code></li>
	<li><code>Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes a message digest of type <code>Type</code> from <code>Data</code>.</p>
	<p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
	is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hash_init/1">hash_init(Type) -&gt; Context</h3>
      
      <ul class="type">
	<li><code>Type = md4 | hash_algorithms()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the context for streaming hash operations. <code>Type</code> determines
        which digest to use. The returned context should be used as argument
	to <a href="#hash_update/2" class="seealso">hash_update</a>.</p>
	<p>May throw exception <code>notsup</code> in case the chosen <code>Type</code>
	is not supported by the underlying OpenSSL implementation.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hash_update/2">hash_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
	<li><code>Data = iodata()</code></li>
      </ul>
      <div class="description">
        <p>Updates the digest represented by <code>Context</code> using the given <code>Data</code>. <code>Context</code>
        must have been generated using <a href="#hash_init/1" class="seealso">hash_init</a>
	or a previous call to this function. <code>Data</code> can be any length. <code>NewContext</code>
        must be passed into the next call to <code>hash_update</code>
	or <a href="#hash_final/1" class="seealso">hash_final</a>.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="hash_final/1">hash_final(Context) -&gt; Digest</h3>
      
      <ul class="type">
	<li><code>Digest = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finalizes the hash operation referenced by <code>Context</code> returned
	from a previous call to <a href="#hash_update/2" class="seealso">hash_update</a>.
	The size of <code>Digest</code> is determined by the type of hash
	function used to generate it.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hmac/3">hmac(Type, Key, Data) -&gt; Mac</h3>
      <h3 id="hmac/4">hmac(Type, Key, Data, MacLength) -&gt; Mac</h3>
      
      <ul class="type">
	<li><code>Type = hash_algorithms() - except ripemd160</code></li>
        <li><code>Key = iodata()</code></li>
	<li><code>Data = iodata()</code></li>
        <li><code>MacLength = integer()</code></li>
	<li><code>Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes a HMAC of type <code>Type</code> from <code>Data</code> using
        <code>Key</code> as the authentication key.</p> <p><code>MacLength</code>
        will limit the size of the resultant <code>Mac</code>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hmac_init/2">hmac_init(Type, Key) -&gt; Context</h3>
      
      <ul class="type">
	<li><code>Type = hash_algorithms() - except ripemd160</code></li>
        <li><code>Key = iodata()</code></li>
        <li><code>Context = binary()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the context for streaming HMAC operations. <code>Type</code> determines
        which hash function to use in the HMAC operation. <code>Key</code> is the authentication
        key. The key can be any length.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hmac_update/2">hmac_update(Context, Data) -&gt; NewContext</h3>
      
      <ul class="type">
        <li><code>Context = NewContext = binary()</code></li>
        <li><code>Data = iodata()</code></li>
      </ul>
      <div class="description">
        <p>Updates the HMAC represented by <code>Context</code> using the given <code>Data</code>. <code>Context</code>
        must have been generated using an HMAC init function (such as
        <a href="#hmac_init/2" class="seealso">hmac_init</a>). <code>Data</code> can be any length. <code>NewContext</code>
        must be passed into the next call to <code>hmac_update</code>
	or to one of the functions <a href="#hmac_final/1" class="seealso">hmac_final</a> and
	<a href="#hmac_final_n/2" class="seealso">hmac_final_n</a>
	</p>
	<div class="warning"><h2>Warning!</h2><p>Do not use a <code>Context</code> as argument in more than one
	call to	hmac_update or hmac_final. The semantics of reusing old contexts
	in any way is undefined and could even crash the VM in earlier releases.
	The reason for this limitation is a lack of support in the underlying
	OpenSSL	API.</p></div>
      </div>
    </div>

    <div class="function">
      <h3 id="hmac_final/1">hmac_final(Context) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Context = Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Finalizes the HMAC operation referenced by <code>Context</code>. The size of the resultant MAC is
        determined by the type of hash function used to generate it.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="hmac_final_n/2">hmac_final_n(Context, HashLen) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Context = Mac = binary()</code></li>
        <li><code>HashLen = non_neg_integer()</code></li>
      </ul>
      <div class="description">
        <p>Finalizes the HMAC operation referenced by <code>Context</code>. <code>HashLen</code> must be greater than
        zero. <code>Mac</code> will be a binary with at most <code>HashLen</code> bytes. Note that if HashLen is greater than the actual number of bytes returned from the underlying hash, the returned hash will have fewer than <code>HashLen</code> bytes.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="cmac/3">cmac(Type, Key, Data) -&gt; Mac</h3>
      <h3 id="cmac/4">cmac(Type, Key, Data, MacLength) -&gt; Mac</h3>
      
      <ul class="type">
        <li><code>Type = block_cipher()</code></li>
        <li><code>Key = iodata()</code></li>
        <li><code>Data = iodata()</code></li>
        <li><code>MacLength = integer()</code></li>
        <li><code>Mac = binary()</code></li>
      </ul>
      <div class="description">
        <p>Computes a CMAC of type <code>Type</code> from <code>Data</code> using
        <code>Key</code> as the authentication key.</p> <p><code>MacLength</code>
        will limit the size of the resultant <code>Mac</code>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="info_fips/0">info_fips() -&gt; Status</h3>
      
      <ul class="type">
        <li><code>Status = enabled | not_enabled | not_supported</code></li>
      </ul>
      <div class="description">
        <p>Provides information about the FIPS operating status of
        crypto and the underlying OpenSSL library. If crypto was built
        with FIPS support this can be either <code>enabled</code> (when
        running in FIPS mode) or <code>not_enabled</code>. For other builds
        this value is always <code>not_supported</code>.</p>
        <div class="warning"><h2>Warning!</h2>
          <p>In FIPS mode all non-FIPS compliant algorithms are
          disabled and throw exception <code>not_supported</code>. Check
          <a href="#supports/0" class="seealso">supports</a> that in
          FIPS mode returns the restricted list of available
          algorithms.</p>
        </div>
      </div>
    </div>

    <div class="function">
      <h3 id="info_lib/0">info_lib() -&gt; [{Name,VerNum,VerStr}]</h3>
      
      <ul class="type">
        <li><code>Name = binary()</code></li>
        <li><code>VerNum = integer()</code></li>
        <li><code>VerStr = binary()</code></li>
      </ul>
      <div class="description">
        <p>Provides the name and version of the libraries used by crypto.</p>
        <p><code>Name</code> is the name of the library. <code>VerNum</code> is
        the numeric version according to the library's own versioning
        scheme. <code>VerStr</code> contains a text variant of the version.</p>
        <pre class="sh_erlang">
&gt; <code>info_lib().</code>
[{&lt;&lt;"OpenSSL"&gt;&gt;,269484095,&lt;&lt;"OpenSSL 1.1.0c  10 Nov 2016""&gt;&gt;}]
        </pre>
	<div class="note"><h2>Note!</h2><p>
	  From OTP R16 the <em>numeric version</em> represents the version of the OpenSSL
	  <em>header files</em> (<code>openssl/opensslv.h</code>) used when crypto was compiled.
	  The text variant represents the OpenSSL library used at runtime.
	  In earlier OTP versions both numeric and text was taken from the library.
	</p></div>
      </div>
    </div>

    <div class="function">
      <h3 id="mod_pow/3">mod_pow(N, P, M) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>N, P, M = binary() | integer()</code></li>
	<li><code>Result = binary() | error</code></li>
      </ul>
      <div class="description">
	<p>Computes the function <code>N^P mod M</code>.</p>
      </div>
    </div>

    <div class="function">
   <h3 id="next_iv/2">next_iv(Type, Data) -&gt; NextIVec</h3>
   <h3 id="next_iv/3">next_iv(Type, Data, IVec) -&gt; NextIVec</h3>
   
   <ul class="type">
     <li><code>Type = des_cbc | des3_cbc | aes_cbc | des_cfb</code></li>
     <li><code>Data = iodata()</code></li>
     <li><code>IVec = NextIVec = binary()</code></li>
   </ul>
   <div class="description">
     <p>Returns the initialization vector to be used in the next
     iteration of encrypt/decrypt of type <code>Type</code>. <code>Data</code> is the
     encrypted data from the previous iteration step. The <code>IVec</code>
     argument is only needed for <code>des_cfb</code> as the vector used
     in the previous iteration step.</p>
   </div>
    </div>

    <div class="function">
      <h3 id="private_decrypt/4">private_decrypt(Type, CipherText, PrivateKey, Padding) -&gt; PlainText</h3>
      
      <ul class="type">
	<li><code>Type = rsa</code></li>
	<li><code>CipherText = binary()</code></li>
	<li><code>PrivateKey = rsa_private() | engine_key_ref()</code></li>
	<li><code>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</code></li>
        <li><code>PlainText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Decrypts the <code>CipherText</code>, encrypted with
	<a href="#public_encrypt/4" class="seealso">public_encrypt/4</a> (or equivalent function)
	  using the <code>PrivateKey</code>, and returns the
	  plaintext (message digest). This is a low level signature  verification operation
	used for instance by older versions of the SSL protocol.
	  See also <a href="../public_key/public_key.html#decrypt_private/2" class="seealso">public_key:decrypt_private/[2,3]</a>
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="privkey_to_pubkey/2">privkey_to_pubkey(Type, EnginePrivateKeyRef) -&gt; PublicKey</h3>
      
      <ul class="type">
	<li><code>Type = rsa | dss</code></li>
	<li><code>EnginePrivateKeyRef = engine_key_ref()</code></li>
	<li><code>PublicKey =  rsa_public() | dss_public()</code></li>
      </ul>
      <div class="description">
	<p>Fetches the corresponding public key from a private key stored in an Engine.
	The key must be of the type indicated by the Type parameter.
	</p>	
      </div>
    </div>

    <div class="function">
      <h3 id="private_encrypt/4">private_encrypt(Type, PlainText, PrivateKey, Padding) -&gt; CipherText</h3>
      
      <ul class="type">
	<li><code>Type = rsa</code></li>
	<li><code>PlainText = binary()</code></li>
	<d> The size of the <code>PlainText</code> must be less
	than <code>byte_size(N)-11</code> if <code>rsa_pkcs1_padding</code> is
	used, and <code>byte_size(N)</code> if <code>rsa_no_padding</code> is
	used, where N is public modulus of the RSA key.</d>
	<li><code>PrivateKey = rsa_private() | engine_key_ref()</code></li>
	<li><code>Padding = rsa_pkcs1_padding | rsa_no_padding</code></li>
        <li><code>CipherText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts the <code>PlainText</code> using the <code>PrivateKey</code>
	and returns the ciphertext. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See
	also <a href="../public_key/public_key.html#encrypt_private/2" class="seealso">public_key:encrypt_private/[2,3]</a>
	</p>
      </div>
    </div>
    <div class="function">
      <h3 id="public_decrypt/4">public_decrypt(Type, CipherText, PublicKey, Padding) -&gt; PlainText</h3>
      
      <ul class="type">
	<li><code>Type = rsa</code></li>
	<li><code>CipherText = binary()</code></li>
	<li><code>PublicKey =  rsa_public() | engine_key_ref()</code></li>
	<li><code>Padding = rsa_pkcs1_padding | rsa_no_padding</code></li>
        <li><code>PlainText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Decrypts the <code>CipherText</code>, encrypted with
	<a href="#private_encrypt/4" class="seealso">private_encrypt/4</a>(or equivalent function)
	  using the <code>PrivateKey</code>, and returns the
	  plaintext (message digest). This is a low level signature verification operation
	  used for instance by older versions of the SSL protocol.
	  See also <a href="../public_key/public_key.html#decrypt_public/2" class="seealso">public_key:decrypt_public/[2,3]</a>
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="public_encrypt/4">public_encrypt(Type, PlainText, PublicKey, Padding) -&gt; CipherText</h3>
      
      <ul class="type">
	<li><code>Type = rsa</code></li>
	<li><code>PlainText = binary()</code></li>
	<d> The size of the <code>PlainText</code> must be less
	than <code>byte_size(N)-11</code> if <code>rsa_pkcs1_padding</code> is
	used, and <code>byte_size(N)</code> if <code>rsa_no_padding</code> is
	used, where N is public modulus of the RSA key.</d>
	<li><code>PublicKey = rsa_public() | engine_key_ref()</code></li>
	<li><code>Padding = rsa_pkcs1_padding | rsa_pkcs1_oaep_padding | rsa_no_padding</code></li>
        <li><code>CipherText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts the <code>PlainText</code> (message digest) using the <code>PublicKey</code>
	and returns the <code>CipherText</code>. This is a low level signature operation
	used for instance by older versions of the SSL protocol. See also <a href="../public_key/public_key.html#encrypt_public/2" class="seealso">public_key:encrypt_public/[2,3]</a>
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rand_seed/1">rand_seed(Seed) -&gt; ok</h3>
      
      <ul class="type">
        <li><code>Seed = binary()</code></li>
      </ul>
      <div class="description">
        <p>Set the seed for PRNG to the given binary. This calls the
        RAND_seed function from openssl. Only use this if the system
        you are running on does not have enough "randomness" built in.
        Normally this is when
        <a href="#strong_rand_bytes/1" class="seealso">strong_rand_bytes/1</a>
        throws <code>low_entropy</code></p>
      </div>
    </div>

     <div class="function">
      <h3 id="rand_uniform/2">rand_uniform(Lo, Hi) -&gt; N</h3>
      
      <ul class="type">
        <li><code>Lo, Hi, N = integer()</code></li>
      </ul>
      <div class="description">
        <p>Generate a random number <code>N, Lo =&lt; N &lt; Hi.</code> Uses the
	<code>crypto</code> library pseudo-random number generator.
	<code>Hi</code> must be larger than <code>Lo</code>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="sign/4">sign(Algorithm, DigestType, Msg, Key) -&gt; binary()</h3>
      <h3 id="sign/5">sign(Algorithm, DigestType, Msg, Key, Options) -&gt; binary()</h3>
      
      <ul class="type">
	<li><code>Algorithm = rsa | dss | ecdsa </code></li>
	<li><code>Msg = binary() | {digest,binary()}</code></li>
	<d>The msg is either the binary "cleartext" data to be
	signed or it is the hashed value of "cleartext" i.e. the
	digest (plaintext).</d>
	<li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
	<li><code>Key = rsa_private() | dss_private() | [ecdh_private(),ecdh_params()] | engine_key_ref()</code></li>
	<li><code>Options = sign_options()</code></li>
      </ul>
      <div class="description">
	<p>Creates a digital signature.</p>
	<p>Algorithm <code>dss</code> can only be used together with digest type
	<code>sha</code>.</p>
	<p>See also <a href="../public_key/public_key.html#sign/3" class="seealso">public_key:sign/3</a>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="start/0">start() -&gt; ok</h3>
      
      <div class="description">
        <p> Equivalent to application:start(crypto).</p>
      </div>
    </div>
    <div class="function">
      <h3 id="stop/0">stop() -&gt; ok</h3>
      
      <div class="description">
        <p> Equivalent to application:stop(crypto).</p>
      </div>
    </div>

    <div class="function">
      <h3 id="strong_rand_bytes/1">strong_rand_bytes(N) -&gt; binary()</h3>
      
      <ul class="type">
        <li><code>N = integer()</code></li>
      </ul>
      <div class="description">
        <p>Generates N bytes randomly uniform 0..255, and returns the
        result in a binary. Uses a cryptographically secure prng seeded and
        periodically mixed with operating system provided entropy. By default
        this is the <code>RAND_bytes</code> method from OpenSSL.</p>
	<p>May throw exception <code>low_entropy</code> in case the random generator
	failed due to lack of secure "randomness".</p>
      </div>
    </div>

    <div class="function">
      <h3 id="rand_seed/0">rand_seed() -&gt; rand:state()</h3>
      
      <div class="description">
	<p>
          Creates state object for
	  <a href="../stdlib/rand.html" class="seealso">random number generation</a>,
          in order to generate cryptographically strong random numbers
          (based on OpenSSL's <code>BN_rand_range</code>),
          and saves it in the process dictionary before returning it as well.
          See also
	  <a href="../stdlib/rand.html#seed/1" class="seealso">rand:seed/1</a> and
	  <a href="#rand_seed_s/0" class="seealso">rand_seed_s/0</a>.
	</p>
	<p>
	  When using the state object from this function the 
	  <a href="../stdlib/rand.html" class="seealso">rand</a> functions using it
	  may throw exception <code>low_entropy</code> in case the random generator
	  failed due to lack of secure "randomness".
	</p>
        <p><em>Example</em></p>
        <pre class="sh_erlang">
_ = crypto:rand_seed(),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[</pre>
      </div>
    </div>

    <div class="function">
      <h3 id="rand_seed_s/0">rand_seed_s() -&gt; rand:state()</h3>
      
      <div class="description">
	<p>
          Creates state object for
	  <a href="../stdlib/rand.html" class="seealso">random number generation</a>,
          in order to generate cryptographically strongly random numbers
          (based on OpenSSL's <code>BN_rand_range</code>).
          See also
	  <a href="../stdlib/rand.html#seed_s/1" class="seealso">rand:seed_s/1</a>.
	</p>
	<p>
	  When using the state object from this function the 
	  <a href="../stdlib/rand.html" class="seealso">rand</a> functions using it
	  may throw exception <code>low_entropy</code> in case the random generator
	  failed due to lack of secure "randomness".
	</p>
	<div class="note"><h2>Note!</h2>
	  <p>
	    The state returned from this function can not be used
	    to get a reproducable random sequence as from
	    the other 
	    <a href="../stdlib/rand.html" class="seealso">rand</a>
	    functions,
	    since reproducability does not match cryptographically safe.
	  </p>
	  <p>
	    The only supported usage is to generate one distinct
	    random sequence from this start state.
	  </p>
	</div>
      </div>
    </div>

    <div class="function">
      <h3 id="rand_seed_alg/1">rand_seed_alg(Alg) -&gt; rand:state()</h3>
      
      <ul class="type">
        <li><code>Alg = crypto | crypto_cache</code></li>
      </ul>
      <div class="description">
	
	<p>
          Creates state object for
	  <a href="../stdlib/rand.html" class="seealso">random number generation</a>,
          in order to generate cryptographically strong random numbers.
          See also
	  <a href="../stdlib/rand.html#seed/1" class="seealso">rand:seed/1</a> and
	  <a href="#rand_seed_alg_s/1" class="seealso">rand_seed_alg_s/1</a>.
	</p>
	<p>
	  When using the state object from this function the 
	  <a href="../stdlib/rand.html" class="seealso">rand</a> functions using it
	  may throw exception <code>low_entropy</code> in case the random generator
	  failed due to lack of secure "randomness".
	</p>
	<p>
	  The cache size can be changed from its default value using the
	  <a href="crypto_app.html" class="seealso">
	    crypto app's
	  </a> configuration parameter <code>rand_cache_size</code>.
	</p>
        <p><em>Example</em></p>
        <pre class="sh_erlang">
_ = crypto:rand_seed_alg(crypto_cache),
_IntegerValue = rand:uniform(42), % [1; 42]
_FloatValue = rand:uniform().     % [0.0; 1.0[</pre>
      </div>
    </div>

    <div class="function">
      <h3 id="rand_seed_alg_s/1">rand_seed_alg_s(Alg) -&gt; rand:state()</h3>
      
      <ul class="type">
        <li><code>Alg = crypto | crypto_cache</code></li>
      </ul>
      <div class="description">
	
	<p>
          Creates state object for
	  <a href="../stdlib/rand.html" class="seealso">random number generation</a>,
          in order to generate cryptographically strongly random numbers.
          See also
	  <a href="../stdlib/rand.html#seed_s/1" class="seealso">rand:seed_s/1</a>.
	</p>
	<p>
	  If <code>Alg</code> is <code>crypto</code> this function behaves exactly like
	  <a href="#rand_seed_s/0" class="seealso">rand_seed_s/0</a>.
	</p>
	<p>
	  If <code>Alg</code> is <code>crypto_cache</code> this function
	  fetches random data with OpenSSL's <code>RAND_bytes</code>
	  and caches it for speed using an internal word size
	  of 56 bits that makes calculations fast on 64 bit machines.
	</p>
	<p>
	  When using the state object from this function the 
	  <a href="../stdlib/rand.html" class="seealso">rand</a> functions using it
	  may throw exception <code>low_entropy</code> in case the random generator
	  failed due to lack of secure "randomness".
	</p>
	<p>
	  The cache size can be changed from its default value using the
	  <a href="crypto_app.html" class="seealso">
	    crypto app's
	  </a> configuration parameter <code>rand_cache_size</code>.
	</p>
	<div class="note"><h2>Note!</h2>
	  <p>
	    The state returned from this function can not be used
	    to get a reproducable random sequence as from
	    the other 
	    <a href="../stdlib/rand.html" class="seealso">rand</a>
	    functions,
	    since reproducability does not match cryptographically safe.
	  </p>
	  <p>
	    In fact since random data is cached some numbers may
	    get reproduced if you try, but this is unpredictable.
	  </p>
	  <p>
	    The only supported usage is to generate one distinct
	    random sequence from this start state.
	  </p>
	</div>
      </div>
    </div>

    <div class="function">
      <h3 id="stream_init/2">stream_init(Type, Key) -&gt; State</h3>
      
      <ul class="type">
	<li><code>Type = rc4 </code></li>
        <li><code>State = opaque() </code></li>
        <li><code>Key = iodata()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the state for use in RC4 stream encryption
        <a href="#stream_encrypt/2" class="seealso">stream_encrypt</a> and
        <a href="#stream_decrypt/2" class="seealso">stream_decrypt</a></p>
      </div>
    </div>

   <div class="function">
      <h3 id="stream_init/3">stream_init(Type, Key, IVec) -&gt; State</h3>
      
      <ul class="type">
	<li><code>Type = aes_ctr </code></li>
        <li><code>State = opaque() </code></li>
        <li><code>Key = iodata()</code></li>
        <li><code>IVec = binary()</code></li>
      </ul>
      <div class="description">
        <p>Initializes the state for use in streaming AES encryption using Counter mode (CTR).
        <code>Key</code> is the AES key and must be either 128, 192, or 256 bits long. <code>IVec</code> is
        an arbitrary initializing vector of 128 bits (16 bytes). This state is for use with
        <a href="#stream_encrypt/2" class="seealso">stream_encrypt</a> and
        <a href="#stream_decrypt/2" class="seealso">stream_decrypt</a>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="stream_encrypt/2">stream_encrypt(State, PlainText) -&gt; { NewState, CipherText}</h3>
      
      <ul class="type">
        <li><code>Text = iodata()</code></li>
        <li><code>CipherText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Encrypts <code>PlainText</code> according to the stream cipher <code>Type</code> specified in stream_init/3.
	<code>Text</code> can be any number of bytes. The initial <code>State</code> is created using
        <a href="#stream_init/2" class="seealso">stream_init</a>.
	<code>NewState</code> must be passed into the next call to <code>stream_encrypt</code>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="stream_decrypt/2">stream_decrypt(State, CipherText) -&gt; { NewState, PlainText }</h3>
      
      <ul class="type">
        <li><code>CipherText = iodata()</code></li>
        <li><code>PlainText = binary()</code></li>
      </ul>
      <div class="description">
	<p>Decrypts <code>CipherText</code> according to the stream cipher <code>Type</code> specified in stream_init/3.
	<code>PlainText</code> can be any number of bytes. The initial <code>State</code> is created using
        <a href="#stream_init/2" class="seealso">stream_init</a>.
	<code>NewState</code> must be passed into the next call to <code>stream_decrypt</code>.</p>
      </div>
    </div>

   <div class="function">
      <h3 id="supports/0">supports() -&gt; AlgorithmList </h3>
      
      <ul class="type">
      <li><code> AlgorithmList =  [{hashs, [hash_algorithms()]},
                            {ciphers, [cipher_algorithms()]},
			    {public_keys, [public_key_algorithms()]},
			    {macs, [mac_algorithms()]}]
      </code></li>
      </ul>
      <div class="description">
        <p> Can be used to determine which crypto algorithms that are supported
	by the underlying OpenSSL library</p>
      </div>
    </div>

    <div class="function">
      <h3 id="ec_curves/0">ec_curves() -&gt; EllipticCurveList </h3>
      
      <ul class="type">
      <li><code>EllipticCurveList = [ec_named_curve()]</code></li>
      </ul>
      <div class="description">
        <p>Can be used to determine which named elliptic curves are supported.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="ec_curve/1">ec_curve(NamedCurve) -&gt; EllipticCurve </h3>
      
      <ul class="type">
      <li><code>NamedCurve = ec_named_curve()</code></li>
      <li><code>EllipticCurve = ec_explicit_curve()</code></li>
      </ul>
      <div class="description">
        <p>Return the defining parameters of a elliptic curve.</p>
      </div>
    </div>

  <div class="function">
      <h3 id="verify/5">verify(Algorithm, DigestType, Msg, Signature, Key) -&gt; boolean()</h3>
      <h3 id="verify/6">verify(Algorithm, DigestType, Msg, Signature, Key, Options) -&gt; boolean()</h3>
      
      <ul class="type">
	<li><code> Algorithm = rsa | dss | ecdsa </code></li>
	<li><code>Msg = binary() | {digest,binary()}</code></li>
	<d>The msg is either the binary "cleartext" data
        or it is the hashed value of "cleartext" i.e. the digest (plaintext).</d>
	<li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
	<li><code>Signature = binary()</code></li>
	<li><code>Key = rsa_public() | dss_public() | [ecdh_public(),ecdh_params()] | engine_key_ref()</code></li>
	<li><code>Options = sign_options()</code></li>
      </ul>
      <div class="description">
	<p>Verifies a digital signature</p>
	<p>Algorithm <code>dss</code> can only be used together with digest type
	<code>sha</code>.</p>

	<p>See also <a href="../public_key/public_key.html#verify/4" class="seealso">public_key:verify/4</a>.</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_get_all_methods/0">engine_get_all_methods() -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Result = [EngineMethod::atom()]</code></li>
      </ul>
      <div class="description">
	<p>
	  Returns a list of all possible engine methods.
	</p>
	<p>	  
	  May throw exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
	<p>
	  See also the chapter <a href="../crypto/engine_load.html#engine_load" class="seealso">Engine Load</a>
	  in the User's Guide.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_load/3">engine_load(EngineId, PreCmds, PostCmds) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>EngineId = unicode:chardata()</code></li>
	<li><code>PreCmds, PostCmds = [{unicode:chardata(), unicode:chardata()}]</code></li>
	<li><code>Result = {ok, Engine::term()} | {error, Reason::term()}</code></li>
      </ul>
      <div class="description">
	<p>
	  Loads the OpenSSL engine given by <code>EngineId</code> if it is available and then returns ok and
	  an engine handle. This function is the same as calling <code>engine_load/4</code> with 
	  <code>EngineMethods</code> set to a list of all the possible methods.  An error tuple is 
	  returned if the engine can't be loaded.
	</p>
	<p>
	  The function throws a badarg if the parameters are in wrong format.
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
	<p>
	  See also the chapter <a href="../crypto/engine_load.html#engine_load" class="seealso">Engine Load</a>
	  in the User's Guide.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_load/4">engine_load(EngineId, PreCmds, PostCmds, EngineMethods) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>EngineId = unicode:chardata()</code></li>
	<li><code>PreCmds, PostCmds = [{unicode:chardata(), unicode:chardata()}]</code></li>
	<li><code>EngineMethods = [engine_method_type()]</code></li>
	<li><code>Result = {ok, Engine::term()} | {error, Reason::term()}</code></li>
      </ul>
      <div class="description">
	<p>
	  Loads the OpenSSL engine given by <code>EngineId</code> if it is available and then returns ok and
	  an engine handle. An error tuple is returned if the engine can't be loaded.
	</p>
	<p>
	  The function throws a badarg if the parameters are in wrong format.
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
	<p>
	  See also the chapter <a href="../crypto/engine_load.html#engine_load" class="seealso">Engine Load</a>
	  in the User's Guide.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_unload/1">engine_unload(Engine) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Engine = term()</code></li>
	<li><code>Result = ok | {error, Reason::term()}</code></li>
      </ul>
      <div class="description">
	<p>
	  Unloads the OpenSSL engine given by <code>EngineId</code>.
	  An error tuple is returned if the engine can't be unloaded.
	</p>
	<p>
	  The function throws a badarg if the parameter is in wrong format.
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
	<p>
	  See also the chapter <a href="../crypto/engine_load.html#engine_load" class="seealso">Engine Load</a>
	  in the User's Guide.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_list/0">engine_list() -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Result = [EngineId::unicode:chardata()]</code></li>
      </ul>
      <div class="description">
	<p>List the id's of all engines in OpenSSL's internal list.</p>
	<p>
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
	<p>
	  See also the chapter <a href="../crypto/engine_load.html#engine_load" class="seealso">Engine Load</a> 
	  in the User's Guide.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_ctrl_cmd_string/3">engine_ctrl_cmd_string(Engine, CmdName, CmdArg) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Engine = term()</code></li>
	<li><code>CmdName = unicode:chardata()</code></li>
	<li><code>CmdArg = unicode:chardata()</code></li>
	<li><code>Result = ok | {error, Reason::term()}</code></li>
      </ul>
      <div class="description">
	<p>
	  Sends ctrl commands to the OpenSSL engine given by <code>Engine</code>.
	  This function is the same as calling <code>engine_ctrl_cmd_string/4</code> with 
	  <code>Optional</code> set to <code>false</code>.
	</p>
	<p>
	  The function throws a badarg if the parameters are in wrong format.
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
      </div>
    </div>

    <div class="function">
      <h3 id="engine_ctrl_cmd_string/4">engine_ctrl_cmd_string(Engine, CmdName, CmdArg, Optional) -&gt; Result</h3>
      
      <ul class="type">
	<li><code>Engine = term()</code></li>
	<li><code>CmdName = unicode:chardata()</code></li>
	<li><code>CmdArg = unicode:chardata()</code></li>
	<li><code>Optional = boolean()</code></li>
	<li><code>Result = ok | {error, Reason::term()}</code></li>
      </ul>
      <div class="description">
	<p>
	  Sends ctrl commands to the OpenSSL engine given by <code>Engine</code>.
	  <code>Optional</code> is a boolean argument that can relax the semantics of the function. 
	  If set to <code>true</code> it will only return failure if the ENGINE supported the given 
	  command name but failed while executing it, if the ENGINE doesn't support the command 
	  name it will simply return success without doing anything. In this case we assume 
	  the user is only supplying commands specific to the given ENGINE so we set this to
	  <code>false</code>.
	</p>
	<p>
	  The function throws a badarg if the parameters are in wrong format.
	  It may also throw the exception notsup in case there is 
	  no engine support in the underlying OpenSSL implementation.
	</p>
      </div>
    </div>

 </div>

  
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
