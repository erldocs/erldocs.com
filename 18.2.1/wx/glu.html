<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>glu (wx) -  (Erlang Documentation)</title>
    <link href="../erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44246018-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        

<h1>glu</h1>
<h2 class="modsummary"> A part of the standard OpenGL Utility api.</h2>
<div class="description">
<p> A part of the standard OpenGL Utility api.
  See <url href="http://www.opengl.org/sdk/docs/man/">www.opengl.org</url></p>
 
  <p>Booleans are represented by integers 0 and 1.</p></div>
<div id="types" class="category"><h4><a href="#types">Types</a></h4><hr/>
    <div class="type"><h3 id="type-enum">enum() = integer() &gt;= 0</h3></div>
    <div class="type"><h3 id="type-matrix">matrix() = <a href="#type-matrix12" class="seealso">matrix12()</a> | <a href="#type-matrix16" class="seealso">matrix16()</a></h3></div>
    <div class="type"><h3 id="type-matrix12">matrix12() = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float()}</h3></div>
    <div class="type"><h3 id="type-matrix16">matrix16() = <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float()}</h3></div>
    <div class="type"><h3 id="type-mem">mem() = binary() | tuple()</h3></div>
    <div class="type"><h3 id="type-vertex">vertex() = {float(), float(), float()}</h3></div></div>
<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>
<div class="function">
<h3 id="tesselate/2">tesselate(Normal, Vs::[Vs]) -&gt; {Triangles, VertexPos}</h3>

<ul class="type">
<li><code>Normal = vertex()</code></li><li><code>Vs = vertex()</code></li><li><code>Triangles = [integer()]</code></li><li><code>VertexPos = binary()</code></li></ul>
<div class="description">

<p>General purpose polygon triangulation.
  The first argument is the normal and the second a list of
  vertex positions. Returned is a list of indecies of the vertices
  and a binary (64bit native float) containing an array of
  vertex positions, it starts with the vertices in Vs and
  may contain newly created vertices in the end.</p>
</div></div>
<div class="function">
<h3 id="build1DMipmapLevels/9">build1DMipmapLevels(Target, InternalFormat, Width, Format, Type, Level, Base, Max, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Level = integer()</code></li><li><code>Base = integer()</code></li><li><code>Max = integer()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a subset of one-dimensional mipmap levels</p>
 
  <p><code>glu:build1DMipmapLevels</code> builds a subset of prefiltered one-dimensional texture maps  
of decreasing resolutions called a mipmap. This is used for the antialiasing of texture  
mapped primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>A series of mipmap levels from  <code>Base</code>  to  <code>Max</code>  is built by decimating   <code>Data</code>
   in half  until size   1×1 is reached. At each level, each texel in the halved mipmap
  level is an average of the corresponding two texels in the larger mipmap level.   <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>
   is called to load these mipmap levels from  <code>Base</code>  to  <code>Max</code> . If  <code>Max</code>  is
  larger than the highest mipmap level for the texture of the specified size, then a GLU
  error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a> ) and nothing is loaded.</p>
 
   <p>For example, if  <code>Level</code>  is 2 and  <code>Width</code>  is 16, the following levels are possible:
    16×1,   8×1,   4×1,  2×1,   1×1. These correspond to levels 2 through 6 respectively.
  If  <code>Base</code>  is 3 and  <code>Max</code>  is 5, then only mipmap levels   8×1,  4×1 and   2×1
  are loaded. However, if  <code>Max</code>  is 7, then an error is returned and nothing is loaded
  since  <code>Max</code>  is larger than the highest mipmap level which is, in  this case, 6.</p>
 
   <p>The highest mipmap level can be derived from the formula  log 2(width×2 level).</p>
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for  <code>Type</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for  <code>Level</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild1DMipmapLevels.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="build1DMipmaps/6">build1DMipmaps(Target, InternalFormat, Width, Format, Type, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a one-dimensional mipmap</p>
 
  <p><code>glu:build1DMipmaps</code> builds a series of prefiltered one-dimensional texture maps of  
decreasing resolutions called a mipmap. This is used for the antialiasing of texture mapped  
primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>Initially, the  <code>Width</code>  of  <code>Data</code>  is checked to see if it is a power of 2. If
  not, a copy of  <code>Data</code>  is scaled up or down to the nearest power of 2. (If  <code>Width</code>
   is exactly between powers of 2, then the copy of  <code>Data</code>  will scale upwards.) This
  copy will be used for subsequent mipmapping operations described below.  For example, if  <code>Width</code>
   is 57, then a copy of  <code>Data</code>  will scale up to 64 before mipmapping takes place.</p>
 
   <p>Then, proxy textures (see  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a> ) are used to determine if the implementation
  can fit the requested texture. If not,  <code>Width</code>  is continually halved until it fits.</p>
 
   <p>Next, a series of mipmap levels is built by decimating a copy of  <code>Data</code>  in half  
until size   1×1 is reached. At each level, each texel in the halved mipmap level is an  
average of the corresponding two texels in the larger mipmap level.</p>
 
   <p><a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  is called to load each of these mipmap levels. Level 0 is a copy
  of  <code>Data</code> .  The highest level is  (log 2)(width). For example, if  <code>Width</code>  is 64 and the implementation  
can store a texture of this size, the following mipmap levels are built:   64×1,   32×1,    
16×1,   8×1,  4×1,   2×1, and   1×1. These correspond to  levels 0 through 6, respectively.</p>
 
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for the  <code>Type</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for the  <code>Data</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild1DMipmaps.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="build2DMipmapLevels/10">build2DMipmapLevels(Target, InternalFormat, Width, Height, Format, Type, Level, Base, Max, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Height = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Level = integer()</code></li><li><code>Base = integer()</code></li><li><code>Max = integer()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a subset of two-dimensional mipmap levels</p>
 
  <p><code>glu:build2DMipmapLevels</code> builds a subset of prefiltered two-dimensional texture maps  
of decreasing resolutions called a mipmap. This is used for the antialiasing of texture  
mapped primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>A series of mipmap levels from  <code>Base</code>  to  <code>Max</code>  is built by decimating   <code>Data</code>
   in half along both dimensions until size   1×1 is reached. At each level, each texel
  in the halved mipmap level is an average of the corresponding four texels in the larger
  mipmap level. (In the case of rectangular images, the decimation will ultimately  reach
  an   N×1 or   1×N configuration. Here, two texels are averaged instead.)  <a href="gl.html#texImage2D/9" class="seealso">gl:texImage2D/9</a>
   is called to load these mipmap levels from  <code>Base</code>  to  <code>Max</code> . If  <code>Max</code>  is
  larger than the highest mipmap level for the texture of the specified size, then a GLU
  error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a> ) and nothing is loaded.</p>
 
   <p>For example, if  <code>Level</code>  is 2 and  <code>Width</code>  is 16 and  <code>Height</code>  is 8, the
  following levels are possible:   16×8,   8×4,   4×2,  2×1,   1×1. These correspond to
  levels 2 through 6 respectively. If  <code>Base</code>  is 3 and  <code>Max</code>  is 5, then only mipmap
  levels  8×4,   4×2, and   2×1 are loaded. However, if  <code>Max</code>  is 7, then an error is
  returned and nothing is loaded since  <code>Max</code>  is larger than the highest mipmap level  
which is, in this case, 6.</p>
 
   <p>The highest mipmap level can be derived from the formula  log 2(max(width height)×2 level).</p>
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for  <code>Format</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for  <code>Type</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild2DMipmapLevels.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="build2DMipmaps/7">build2DMipmaps(Target, InternalFormat, Width, Height, Format, Type, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Height = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a two-dimensional mipmap</p>
 
  <p><code>glu:build2DMipmaps</code> builds a series of prefiltered two-dimensional texture maps of  
decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped  
primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>Initially, the  <code>Width</code>  and  <code>Height</code>  of  <code>Data</code>  are checked to see if they
  are a power of 2. If not, a copy of  <code>Data</code>  (not  <code>Data</code> ), is scaled up or down
  to the nearest power of 2. This copy will be used for subsequent mipmapping operations
  described below. (If  <code>Width</code>  or  <code>Height</code>  is exactly between powers of 2, then
  the copy of  <code>Data</code>  will scale upwards.) For example, if  <code>Width</code>  is 57 and  <code>Height</code>
   is 23, then a copy of  <code>Data</code>  will scale up to 64 in  <code>Width</code>  and down to 16  
in depth, before mipmapping takes place.</p>
 
   <p>Then, proxy textures (see  <a href="gl.html#texImage2D/9" class="seealso">gl:texImage2D/9</a> ) are used to determine if the implementation
  can fit the requested texture. If not, both dimensions are continually halved until it
  fits. (If the OpenGL version is (&lt;= 1.0, both maximum texture dimensions are clamped
  to the value returned by  <a href="gl.html#getBooleanv/1" class="seealso">gl:getBooleanv/1</a>  with the argument <code>?GLU_MAX_TEXTURE_SIZE</code>  
.)</p>
 
   <p>Next, a series of mipmap levels is built by decimating a copy of  <code>Data</code>  in half  
along both dimensions until size   1×1 is reached. At each level, each texel in the halved  
mipmap level is an average of the corresponding four texels in the larger mipmap level.  
(In the case of rectangular images, the decimation will ultimately reach an   N×1 or  1×N  
configuration. Here, two texels are averaged instead.)</p>
 
   <p><a href="gl.html#texImage2D/9" class="seealso">gl:texImage2D/9</a>  is called to load each of these mipmap levels. Level 0 is a copy
  of  <code>Data</code> . The highest level is (log 2)(max(width height)). For example, if  <code>Width</code>  is 64 and  <code>Height</code>   
is 16 and the implementation can store a texture of this size, the following mipmap levels  
are built:   64×16,   32×8,   16×4,  8×2,   4×1,   2×1, and   1×1 These correspond to  
levels 0 through 6, respectively.</p>
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for  <code>Format</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for  <code>Type</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild2DMipmaps.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="build3DMipmapLevels/11">build3DMipmapLevels(Target, InternalFormat, Width, Height, Depth, Format, Type, Level, Base, Max, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Height = integer()</code></li><li><code>Depth = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Level = integer()</code></li><li><code>Base = integer()</code></li><li><code>Max = integer()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a subset of three-dimensional mipmap levels</p>
 
  <p><code>glu:build3DMipmapLevels</code> builds a subset of prefiltered three-dimensional texture  
maps of decreasing resolutions called a mipmap. This is used for the antialiasing of texture  
mapped primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>A series of mipmap levels from  <code>Base</code>  to  <code>Max</code>  is built by decimating  <code>Data</code>
   in half along both dimensions until size  1×1×1 is reached. At each level, each texel
  in the halved mipmap level is an average of the corresponding eight texels in the larger
  mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly
  two of the dimensions are 1, two texels are averaged.)  <a href="gl.html#texImage3D/0" class="seealso">gl:texImage3D/10</a>  is called
  to load these mipmap levels from  <code>Base</code>  to  <code>Max</code> . If  <code>Max</code>  is larger than
  the highest mipmap level for the texture of the specified size, then a GLU error code
  is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a> ) and nothing is loaded.</p>
 
   <p>For example, if  <code>Level</code>  is 2 and  <code>Width</code>  is 16,  <code>Height</code>  is 8 and  <code>Depth</code>
   is 4, the following levels are possible:   16×8×4,   8×4×2,  4×2×1,   2×1×1,  1×1×1.
  These correspond to levels 2 through 6 respectively. If  <code>Base</code>  is 3 and  <code>Max</code>
  is 5, then only mipmap levels   8×4×2,  4×2×1, and   2×1×1 are loaded. However, if  <code>Max</code>
   is 7, then an error is returned and nothing is loaded, since  <code>Max</code>  is larger than  
the highest mipmap level which is, in this case, 6.</p>
 
   <p>The highest mipmap level can be derived from the formula  log 2(max(width height depth)×2 level).</p>
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for  <code>Format</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for  <code>Type</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild3DMipmapLevels.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="build3DMipmaps/8">build3DMipmaps(Target, InternalFormat, Width, Height, Depth, Format, Type, Data) -&gt; integer()</h3>

<ul class="type">
<li><code>Target = enum()</code></li><li><code>InternalFormat = integer()</code></li><li><code>Width = integer()</code></li><li><code>Height = integer()</code></li><li><code>Depth = integer()</code></li><li><code>Format = enum()</code></li><li><code>Type = enum()</code></li><li><code>Data = binary()</code></li></ul>
<div class="description">

<p>Builds a three-dimensional mipmap</p>
 
  <p><code>glu:build3DMipmaps</code> builds a series of prefiltered three-dimensional texture maps  
of decreasing resolutions called a mipmap. This is used for the antialiasing of texture-mapped  
primitives.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>Initially, the  <code>Width</code> ,  <code>Height</code>  and  <code>Depth</code>  of  <code>Data</code>  are checked
  to see if they are a power of 2. If not, a copy of  <code>Data</code>  is made and scaled up or
  down to the nearest power of 2. (If  <code>Width</code> ,  <code>Height</code> , or  <code>Depth</code>  is exactly
  between powers of 2, then the copy of  <code>Data</code>  will scale upwards.) This copy will
  be used for subsequent mipmapping operations described below. For example, if  <code>Width</code>
  is 57,  <code>Height</code>  is 23, and  <code>Depth</code>  is 24, then a copy of  <code>Data</code>  will scale  
up to 64 in width, down to 16 in height, and up to 32 in depth before mipmapping takes  
place.</p>
 
   <p>Then, proxy textures (see  <a href="gl.html#texImage3D/0" class="seealso">gl:texImage3D/10</a> ) are used to determine if the implementation  
can fit the requested texture. If not, all three dimensions are continually halved until  
it fits.</p>
 
   <p>Next, a series of mipmap levels is built by decimating a copy of  <code>Data</code>  in half  
along all three dimensions until size   1×1×1 is reached. At each level, each texel in  
the halved mipmap level is an average of the corresponding eight texels in the larger  
mipmap level. (If exactly one of the dimensions is 1, four texels are averaged. If exactly  
two of the dimensions are 1, two texels are averaged.)</p>
 
   <p><a href="gl.html#texImage3D/0" class="seealso">gl:texImage3D/10</a>  is called to load each of these mipmap levels. Level 0 is a copy
  of  <code>Data</code> . The highest level is (log 2)(max(width height depth)). For example, if  <code>Width</code>  is 64,  <code>Height</code>
  is 16, and  <code>Depth</code>  is 32, and the implementation can store a texture of this size,  
the following mipmap levels are built:   64×16×32,  32×8×16,   16×4×8,  8×2×4,   4×1×2,  
2×1×1, and   1×1×1. These correspond to levels 0 through 6, respectively.</p>
 
   <p>See the  <a href="gl.html#texImage1D/8" class="seealso">gl:texImage1D/8</a>  reference page for a description of the acceptable values
  for  <code>Format</code>  parameter. See the  <a href="gl.html#drawPixels/5" class="seealso">gl:drawPixels/5</a>   reference page for a description
  of the acceptable values  for  <code>Type</code>  parameter.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluBuild3DMipmaps.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="checkExtension/2">checkExtension(ExtName, ExtString) -&gt; 0 | 1</h3>

<ul class="type">
<li><code>ExtName = string()</code></li><li><code>ExtString = string()</code></li></ul>
<div class="description">

<p>Determines if an extension name is supported</p>
 
  <p><code>glu:checkExtension</code> returns <code>?GLU_TRUE</code> if  <code>ExtName</code>  is supported otherwise
   <code>?GLU_FALSE</code> is returned.</p>
 
   <p>This is used to check for the presence for OpenGL, GLU, or GLX extension names by passing
  the extension strings returned by  <a href="gl.html#getString/1" class="seealso">gl:getString/1</a> ,   <a href="glu.html#getString/1" class="seealso">glu:getString/1</a> , see <code>glXGetClientString</code>
  , see <code>glXQueryExtensionsString</code>, or see <code>glXQueryServerString</code>, respectively,
  as  <code>ExtString</code> .</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluCheckExtension.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="cylinder/6">cylinder(Quad, Base, Top, Height, Slices, Stacks) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Base = float()</code></li><li><code>Top = float()</code></li><li><code>Height = float()</code></li><li><code>Slices = integer()</code></li><li><code>Stacks = integer()</code></li></ul>
<div class="description">

<p>Draw a cylinder</p>
 
  <p><code>glu:cylinder</code> draws a cylinder oriented along the <code>z</code> axis. The base of the
  cylinder is placed at <code>z</code> = 0 and the top at   z=height. Like a sphere, a cylinder
  is subdivided around the <code>z</code> axis into slices and along the  <code>z</code> axis into stacks.</p>
 
 
   <p>Note that if  <code>Top</code>  is set to 0.0, this routine generates a cone.</p>
 
   <p>If the orientation is set to <code>?GLU_OUTSIDE</code>  (with  <a href="glu.html#quadricOrientation/2" class="seealso">glu:quadricOrientation/2</a> ),
  then any generated normals point away from the <code>z</code> axis. Otherwise, they point toward
  the  <code>z</code> axis.</p>
 
   <p>If texturing is turned on (with  <a href="glu.html#quadricTexture/2" class="seealso">glu:quadricTexture/2</a> ), then texture  coordinates
  are generated so that <code>t</code> ranges linearly from 0.0  at <code>z</code> = 0 to 1.0 at <code>z</code>
   =  <code>Height</code> , and <code>s</code>  ranges from 0.0 at the +<code>y</code> axis, to 0.25 at the +<code>x</code>
   axis,  to 0.5 at the -<code>y</code> axis, to 0.75 at the -<code>x</code> axis,  and back to 1.0
  at the +<code>y</code> axis.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluCylinder.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="deleteQuadric/1">deleteQuadric(Quad) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li></ul>
<div class="description">

<p>Destroy a quadrics object</p>
 
  <p><code>glu:deleteQuadric</code> destroys the quadrics object (created with  <a href="glu.html#newQuadric/0" class="seealso">glu:newQuadric/0</a> )
  and frees any memory it uses.  Once <code>glu:deleteQuadric</code> has been called,  <code>Quad</code>  
cannot be used again.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluDeleteQuadric.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="disk/5">disk(Quad, Inner, Outer, Slices, Loops) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Inner = float()</code></li><li><code>Outer = float()</code></li><li><code>Slices = integer()</code></li><li><code>Loops = integer()</code></li></ul>
<div class="description">

<p>Draw a disk</p>
 
  <p><code>glu:disk</code> renders a disk on the <code>z</code> = 0 plane. The disk has a radius of   <code>Outer</code>
   and contains a concentric circular hole with a radius  of  <code>Inner</code> . If  <code>Inner</code>
  is 0, then no hole is generated. The disk is subdivided around the <code>z</code> axis into
  slices (like pizza slices) and also about the <code>z</code> axis into rings  (as specified by  <code>Slices</code>
   and  <code>Loops</code> , respectively).</p>
 
   <p>With respect to orientation, the +<code>z</code> side of the disk is considered to be  <code>outside</code>
  (see  <a href="glu.html#quadricOrientation/2" class="seealso">glu:quadricOrientation/2</a> ). This means that if the orientation is set to <code>?GLU_OUTSIDE</code>
  , then any normals generated  point along the +<code>z</code> axis. Otherwise, they point along
  the -<code>z</code>  axis.</p>
 
   <p>If texturing has been turned on (with  <a href="glu.html#quadricTexture/2" class="seealso">glu:quadricTexture/2</a> ),  texture coordinates
  are generated linearly such that where   r=outer, the value at (<code>r</code>, 0, 0) is  (1,
  0.5), at (0, <code>r</code>, 0) it is (0.5, 1), at (-<code>r</code>, 0, 0)  it is (0, 0.5), and  at
  (0, -<code>r</code>, 0) it is (0.5, 0).</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluDisk.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="errorString/1">errorString(Error) -&gt; string()</h3>

<ul class="type">
<li><code>Error = enum()</code></li></ul>
<div class="description">

<p>Produce an error string from a GL or GLU error code</p>
 
  <p><code>glu:errorString</code> produces an error string from a GL or GLU error code. The string
  is in ISO Latin 1 format. For example, <code>glu:errorString</code>(<code>?GLU_OUT_OF_MEMORY</code>)
  returns the string  <code>out of memory</code>.</p>
 
   <p>The standard GLU error codes are <code>?GLU_INVALID_ENUM</code>,  <code>?GLU_INVALID_VALUE</code>,
  and <code>?GLU_OUT_OF_MEMORY</code>. Certain other GLU functions can return specialized error
  codes through callbacks. See the  <a href="gl.html#getError/0" class="seealso">gl:getError/0</a>  reference page for the list of  
GL error codes.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluErrorString.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="getString/1">getString(Name) -&gt; string()</h3>

<ul class="type">
<li><code>Name = enum()</code></li></ul>
<div class="description">

<p>Return a string describing the GLU version or GLU extensions</p>
 
  <p><code>glu:getString</code> returns a pointer to a static string describing the  GLU version or  
the GLU extensions that are supported.</p>
 
   <p>The version number is one of the following forms:</p>
 
  <p><code>major_number.minor_number</code><code>major_number.minor_number.release_number</code>.</p>
 
   <p>The version string is of the following form:</p>
 
  <p><code>version number&lt;space&gt;vendor-specific information</code></p>
 
   <p>Vendor-specific information is optional. Its format and contents depend on the implementation.</p>
 
 
   <p>The standard GLU contains a basic set of features and capabilities. If a company or group
  of companies wish to support other features, these may be included as extensions to the
  GLU.  If  <code>Name</code>  is  <code>?GLU_EXTENSIONS</code>, then <code>glu:getString</code> returns a space-separated  
list of names of supported GLU extensions. (Extension names never contain spaces.)</p>
 
   <p>All strings are null-terminated.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluGetString.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="lookAt/9">lookAt(EyeX, EyeY, EyeZ, CenterX, CenterY, CenterZ, UpX, UpY, UpZ) -&gt; ok</h3>

<ul class="type">
<li><code>EyeX = float()</code></li><li><code>EyeY = float()</code></li><li><code>EyeZ = float()</code></li><li><code>CenterX = float()</code></li><li><code>CenterY = float()</code></li><li><code>CenterZ = float()</code></li><li><code>UpX = float()</code></li><li><code>UpY = float()</code></li><li><code>UpZ = float()</code></li></ul>
<div class="description">

<p>Define a viewing transformation</p>
 
  <p><code>glu:lookAt</code> creates a viewing matrix derived from an eye point, a reference point
  indicating the center of the scene, and an <code>UP</code> vector.</p>
 
   <p>The matrix maps the reference point to the negative <code>z</code> axis and the eye point to
  the origin. When a typical projection matrix is used, the center of the scene therefore
  maps to the center of the viewport. Similarly, the direction described by the <code>UP</code>
  vector projected onto the viewing plane is mapped to the positive <code>y</code>  axis so that
  it points upward in the viewport. The <code>UP</code> vector must not be parallel to the line  
of sight from the eye point to the reference point.</p>
 
   <p>Let</p>
 
   <p>F=(centerX-eyeX centerY-eyeY centerZ-eyeZ)</p>
 
   <p>Let <code>UP</code> be the vector  (upX upY upZ).</p>
 
   <p>Then normalize as follows:   f=F/(||F||)</p>
 
   <p>UP"=UP/(||UP||)</p>
 
   <p>Finally, let   s=f×UP", and   u=s×f.</p>
 
   <p>M is then constructed as follows:  M=(s[0] s[1] s[2] 0 u[0] u[1] u[2] 0-f[0]-f[1]-f[2] 0 0 0 0 1)</p>
 
   <p>and <code>glu:lookAt</code> is equivalent to   glMultMatrixf(M); glTranslated(-eyex, -eyey,  
-eyez);</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluLookAt.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="newQuadric/0">newQuadric() -&gt; integer()</h3>


<div class="description">

<p>Create a quadrics object</p>
 
  <p><code>glu:newQuadric</code> creates and returns a pointer to a new quadrics object. This object  
must be referred to when calling quadrics rendering and control functions. A return value  
of 0 means that there is not enough memory to allocate the object.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluNewQuadric.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="ortho2D/4">ortho2D(Left, Right, Bottom, Top) -&gt; ok</h3>

<ul class="type">
<li><code>Left = float()</code></li><li><code>Right = float()</code></li><li><code>Bottom = float()</code></li><li><code>Top = float()</code></li></ul>
<div class="description">

<p>Define a 2D orthographic projection matrix</p>
 
  <p><code>glu:ortho2D</code> sets up a two-dimensional orthographic viewing region.  This is equivalent
  to calling  <a href="gl.html#ortho/6" class="seealso">gl:ortho/6</a>  with   near=-1 and   far=1.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluOrtho2D.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="partialDisk/7">partialDisk(Quad, Inner, Outer, Slices, Loops, Start, Sweep) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Inner = float()</code></li><li><code>Outer = float()</code></li><li><code>Slices = integer()</code></li><li><code>Loops = integer()</code></li><li><code>Start = float()</code></li><li><code>Sweep = float()</code></li></ul>
<div class="description">

<p>Draw an arc of a disk</p>
 
  <p><code>glu:partialDisk</code> renders a partial disk on the   z=0 plane. A partial disk is  similar
  to a full disk, except that only the subset of the disk from  <code>Start</code>  through  <code>Start</code>
   +  <code>Sweep</code>  is included (where 0 degrees is along the  +f2yf axis, 90 degrees along
  the +<code>x</code> axis, 180 degrees along the -<code>y</code> axis, and  270 degrees along the -<code>x</code>   
axis).</p>
 
   <p>The partial disk has a radius of   <code>Outer</code>  and contains a concentric circular hole
  with a radius  of  <code>Inner</code> . If  <code>Inner</code>  is 0, then no hole is generated. The partial
  disk is subdivided around the <code>z</code> axis into slices (like pizza slices) and also about
  the <code>z</code> axis into rings  (as specified by  <code>Slices</code>  and  <code>Loops</code> , respectively).</p>
 
 
   <p>With respect to orientation, the +<code>z</code>  side of the partial disk is considered to
   be outside (see  <a href="glu.html#quadricOrientation/2" class="seealso">glu:quadricOrientation/2</a> ). This means that if the  orientation
  is set to <code>?GLU_OUTSIDE</code>, then any normals generated  point along the +<code>z</code> axis.
  Otherwise, they point along the -<code>z</code>  axis.</p>
 
   <p>If texturing is turned on (with  <a href="glu.html#quadricTexture/2" class="seealso">glu:quadricTexture/2</a> ), texture coordinates are
  generated linearly such that where   r=outer, the value at (<code>r</code>, 0, 0) is  (1.0,
  0.5), at (0, <code>r</code>, 0) it is (0.5, 1.0), at (-<code>r</code>, 0, 0)  it is (0.0, 0.5), and
   at (0, -<code>r</code>, 0) it is (0.5, 0.0).</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluPartialDisk.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="perspective/4">perspective(Fovy, Aspect, ZNear, ZFar) -&gt; ok</h3>

<ul class="type">
<li><code>Fovy = float()</code></li><li><code>Aspect = float()</code></li><li><code>ZNear = float()</code></li><li><code>ZFar = float()</code></li></ul>
<div class="description">

<p>Set up a perspective projection matrix</p>
 
  <p><code>glu:perspective</code> specifies a viewing frustum into the world coordinate system. In
  general, the aspect ratio in <code>glu:perspective</code> should match the aspect ratio of the
  associated viewport. For example,   aspect=2.0 means  the viewer's angle of view is twice
  as wide in <code>x</code> as it is in <code>y</code>. If the viewport is twice as wide as it is tall,  
it displays the image without distortion.</p>
 
   <p>The matrix generated by <code>glu:perspective</code> is multipled by the current matrix, just
  as if  <a href="gl.html#multMatrixd/1" class="seealso">gl:multMatrixd/1</a>  were called with the generated matrix. To load the perspective
  matrix onto the current matrix stack instead, precede the call to <code>glu:perspective</code>
  with a call to  <a href="gl.html#loadIdentity/0" class="seealso">gl:loadIdentity/0</a> .</p>
 
   <p>Given <code>f</code> defined as follows:</p>
 
   <p>f=cotangent(fovy/2) The generated matrix is</p>
 
  <p>(f/aspect 0 0 0 0 f 0 0 0 0(zFar+zNear)/(zNear-zFar)(2×zFar×zNear)/(zNear-zFar) 0 0 -1 0)</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluPerspective.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="pickMatrix/5">pickMatrix(X, Y, DelX, DelY, Viewport) -&gt; ok</h3>

<ul class="type">
<li><code>X = float()</code></li><li><code>Y = float()</code></li><li><code>DelX = float()</code></li><li><code>DelY = float()</code></li><li><code>Viewport = {integer(), integer(), integer(), integer()}</code></li></ul>
<div class="description">

<p>Define a picking region</p>
 
  <p><code>glu:pickMatrix</code> creates a projection matrix that can be used to restrict drawing
  to a small region of the viewport. This is typically useful to determine what objects
  are being drawn near the cursor. Use <code>glu:pickMatrix</code> to restrict drawing to a small
  region around the cursor. Then, enter selection mode (with  <a href="gl.html#renderMode/1" class="seealso">gl:renderMode/1</a> ) and  
rerender the scene. All primitives that would have been drawn near the cursor are identified  
and stored in the selection buffer.</p>
 
   <p>The matrix created by <code>glu:pickMatrix</code> is multiplied by the current matrix just as
  if  <a href="gl.html#multMatrixd/1" class="seealso">gl:multMatrixd/1</a>  is called with the generated matrix. To effectively use the
  generated pick matrix for picking, first call  <a href="gl.html#loadIdentity/0" class="seealso">gl:loadIdentity/0</a>  to load an identity
  matrix onto the perspective matrix stack. Then call <code>glu:pickMatrix</code>, and, finally,
  call a command (such as  <a href="glu.html#perspective/4" class="seealso">glu:perspective/4</a> ) to multiply the perspective matrix by  
the pick matrix.</p>
 
   <p>When using <code>glu:pickMatrix</code> to pick NURBS, be careful to turn off the NURBS  property
  <code>?GLU_AUTO_LOAD_MATRIX</code>. If <code>?GLU_AUTO_LOAD_MATRIX</code> is not turned off, then  
any NURBS surface rendered is subdivided differently with the pick matrix than the way  
it was subdivided without the pick matrix.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluPickMatrix.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="project/6">project(ObjX, ObjY, ObjZ, Model, Proj, View) -&gt; {integer(), WinX::float(), WinY::float(), WinZ::float()}</h3>

<ul class="type">
<li><code>ObjX = float()</code></li><li><code>ObjY = float()</code></li><li><code>ObjZ = float()</code></li><li><code>Model = matrix()</code></li><li><code>Proj = matrix()</code></li><li><code>View = {integer(), integer(), integer(), integer()}</code></li></ul>
<div class="description">

<p>Map object coordinates to window coordinates</p>
 
  <p><code>glu:project</code> transforms the specified object coordinates into window coordinates
  using  <code>Model</code> ,  <code>Proj</code> , and  <code>View</code> . The result is stored  in  <code>WinX</code> ,  <code>WinY</code>
  , and  <code>WinZ</code> . A return value of  <code>?GLU_TRUE</code> indicates success, a return value
  of <code>?GLU_FALSE</code> indicates failure.</p>
 
   <p>To compute the coordinates, let   v=(objX objY objZ 1.0) represented as a matrix with 4 rows and 1 column.
  Then <code>glu:project</code> computes   v" as follows:</p>
 
   <p>v"=P×M×v</p>
 
   <p>where   P is the current projection matrix  <code>Proj</code>  and   M is the current modelview
  matrix  <code>Model</code>  (both represented as  4×4 matrices in column-major order).</p>
 
   <p>The window coordinates are then computed as follows:</p>
 
   <p>winX=view(0)+view(2)×(v"(0)+1)/2</p>
 
   <p>winY=view(1)+view(3)×(v"(1)+1)/2</p>
 
   <p>winZ=(v"(2)+1)/2</p>
 
 
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluProject.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="quadricDrawStyle/2">quadricDrawStyle(Quad, Draw) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Draw = enum()</code></li></ul>
<div class="description">

<p>Specify the draw style desired for quadrics</p>
 
  <p><code>glu:quadricDrawStyle</code> specifies the draw style for quadrics rendered with  <code>Quad</code> .  
The legal values are as follows:</p>
 
  <p><code>?GLU_FILL</code>:  Quadrics are rendered with polygon primitives. The polygons  are drawn
  in a counterclockwise fashion with respect to their normals (as defined with  <a href="glu.html#quadricOrientation/2" class="seealso">glu:quadricOrientation/2</a>  
).</p>
 
  <p><code>?GLU_LINE</code>:  Quadrics are rendered as a set of lines.</p>
 
  <p><code>?GLU_SILHOUETTE</code>:  Quadrics are rendered as a set of lines, except that edges separating  
coplanar faces will not be drawn.</p>
 
  <p><code>?GLU_POINT</code>:  Quadrics are rendered as a set of points.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluQuadricDrawStyle.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="quadricNormals/2">quadricNormals(Quad, Normal) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Normal = enum()</code></li></ul>
<div class="description">

<p>Specify what kind of normals are desired for quadrics</p>
 
  <p><code>glu:quadricNormals</code> specifies what kind of normals are desired for quadrics rendered
  with  <code>Quad</code> . The legal values are as follows:</p>
 
  <p><code>?GLU_NONE</code>:  No normals are generated.</p>
 
  <p><code>?GLU_FLAT</code>:  One normal is generated for every facet of a quadric.</p>
 
  <p><code>?GLU_SMOOTH</code>:  One normal is generated for every vertex of a quadric. This is the  
initial value.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluQuadricNormals.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="quadricOrientation/2">quadricOrientation(Quad, Orientation) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Orientation = enum()</code></li></ul>
<div class="description">

<p>Specify inside/outside orientation for quadrics</p>
 
  <p><code>glu:quadricOrientation</code> specifies what kind of orientation is desired for quadrics
  rendered  with  <code>Quad</code> . The  <code>Orientation</code>  values are as follows:</p>
 
  <p><code>?GLU_OUTSIDE</code>:  Quadrics are drawn with normals pointing outward (the initial value).</p>
 
 
  <p><code>?GLU_INSIDE</code>:  Quadrics are drawn with normals pointing inward.</p>
 
   <p>Note that the interpretation of <code>outward</code> and <code>inward</code> depends on the quadric  
being drawn.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluQuadricOrientation.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="quadricTexture/2">quadricTexture(Quad, Texture) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Texture = 0 | 1</code></li></ul>
<div class="description">

<p>Specify if texturing is desired for quadrics</p>
 
  <p><code>glu:quadricTexture</code> specifies if texture coordinates should be generated for quadrics
  rendered with  <code>Quad</code> . If the value of  <code>Texture</code>  is <code>?GLU_TRUE</code>, then texture
  coordinates  are generated, and if  <code>Texture</code>  is <code>?GLU_FALSE</code>, they are not.
  The initial value is <code>?GLU_FALSE</code>.</p>
 
   <p>The manner in which texture coordinates are generated depends  upon the specific quadric  
rendered.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluQuadricTexture.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="scaleImage/9">scaleImage(Format, WIn, HIn, TypeIn, DataIn, WOut, HOut, TypeOut, DataOut) -&gt; integer()</h3>

<ul class="type">
<li><code>Format = enum()</code></li><li><code>WIn = integer()</code></li><li><code>HIn = integer()</code></li><li><code>TypeIn = enum()</code></li><li><code>DataIn = binary()</code></li><li><code>WOut = integer()</code></li><li><code>HOut = integer()</code></li><li><code>TypeOut = enum()</code></li><li><code>DataOut = mem()</code></li></ul>
<div class="description">

<p>Scale an image to an arbitrary size</p>
 
  <p><code>glu:scaleImage</code> scales a pixel image using the appropriate pixel store modes to  
unpack data from the source image and pack data into the destination image.</p>
 
   <p>When shrinking an image, <code>glu:scaleImage</code> uses a box filter to sample the source  
image and create pixels for the destination image. When magnifying an image, the pixels  
from the source image are linearly interpolated to create the destination image.</p>
 
   <p>A return value of zero indicates success, otherwise a GLU error code is returned (see  <a href="glu.html#errorString/1" class="seealso">glu:errorString/1</a>  
).</p>
 
   <p>See the  <a href="gl.html#readPixels/7" class="seealso">gl:readPixels/7</a>  reference page for a description of the acceptable values
  for the  <code>Format</code> ,  <code>TypeIn</code> , and  <code>TypeOut</code>  parameters.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluScaleImage.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="sphere/4">sphere(Quad, Radius, Slices, Stacks) -&gt; ok</h3>

<ul class="type">
<li><code>Quad = integer()</code></li><li><code>Radius = float()</code></li><li><code>Slices = integer()</code></li><li><code>Stacks = integer()</code></li></ul>
<div class="description">

<p>Draw a sphere</p>
 
  <p><code>glu:sphere</code> draws a sphere of the given radius centered around the origin. The sphere
  is subdivided around the <code>z</code> axis into slices and along the  <code>z</code> axis  into  
stacks (similar to lines of longitude and latitude).</p>
 
   <p>If the orientation is set to <code>?GLU_OUTSIDE</code>  (with  <a href="glu.html#quadricOrientation/2" class="seealso">glu:quadricOrientation/2</a> ),  
then any normals generated  point away from the center of the sphere. Otherwise, they  
point toward the center of the sphere.</p>
 
   <p>If texturing is turned on (with  <a href="glu.html#quadricTexture/2" class="seealso">glu:quadricTexture/2</a> ), then texture  coordinates
  are  generated so that <code>t</code> ranges from 0.0 at   z=-radius to 1.0 at   z=radius (<code>t</code>
   increases linearly along longitudinal lines), and <code>s</code> ranges from 0.0 at the +<code>y</code>
   axis, to 0.25 at the  +<code>x</code> axis,  to 0.5 at the -<code>y</code> axis, to 0.75 at the -<code>x</code>
   axis, and back to 1.0  at the +<code>y</code> axis.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluSphere.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="unProject/6">unProject(WinX, WinY, WinZ, Model, Proj, View) -&gt; {integer(), ObjX::float(), ObjY::float(), ObjZ::float()}</h3>

<ul class="type">
<li><code>WinX = float()</code></li><li><code>WinY = float()</code></li><li><code>WinZ = float()</code></li><li><code>Model = matrix()</code></li><li><code>Proj = matrix()</code></li><li><code>View = {integer(), integer(), integer(), integer()}</code></li></ul>
<div class="description">

<p>Map window coordinates to object coordinates</p>
 
  <p><code>glu:unProject</code> maps the specified window coordinates into object  coordinates using  <code>Model</code>
  ,  <code>Proj</code> , and  <code>View</code> . The result is stored in  <code>ObjX</code> ,  <code>ObjY</code> , and  <code>ObjZ</code>
  . A return value of  <code>?GLU_TRUE</code> indicates success; a return value of <code>?GLU_FALSE</code>   
indicates failure.</p>
 
   <p>To compute the coordinates  (objX objY objZ), <code>glu:unProject</code> multiplies the normalized device coordinates
  by the inverse of  <code>Model</code>  *  <code>Proj</code>  as follows:</p>
 
  <p>(objX objY objZ W)=INV(P  M) ((2(winX-view[0]))/(view[2])-1(2(winY-view[1]))/(view[3])-1 2(winZ)-1 1) INV denotes matrix inversion.  W is an unused variable, included for consistent  
matrix notation.</p>
 
  <p>See <url href="http://www.opengl.org/sdk/docs/man/xhtml/gluUnProject.xml">external</url> documentation.</p>
</div></div>
<div class="function">
<h3 id="unProject4/9">unProject4(WinX, WinY, WinZ, ClipW, Model, Proj, View, NearVal, FarVal) -&gt; {integer(), ObjX::float(), ObjY::float(), ObjZ::float(), ObjW::float()}</h3>

<ul class="type">
<li><code>WinX = float()</code></li><li><code>WinY = float()</code></li><li><code>WinZ = float()</code></li><li><code>ClipW = float()</code></li><li><code>Model = matrix()</code></li><li><code>Proj = matrix()</code></li><li><code>View = {integer(), integer(), integer(), integer()}</code></li><li><code>NearVal = float()</code></li><li><code>FarVal = float()</code></li></ul>
<div class="description">

<p>
  See <a href="#unProject/6" class="seealso">unProject/6</a></p>
</div></div></div>

<authors>
<aname> </aname>
<email> </email></authors>
      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
