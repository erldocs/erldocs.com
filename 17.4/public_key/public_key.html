<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>public_key (public_key) -  (Erlang Documentation)</title>
    <link href="../erldocs.css" type="text/css" rel="stylesheet"/>
    <link href="/search.xml" rel="search" type="application/opensearchdescription+xml" title="erldocs"/>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44246018-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" placeholder="press TAB to search"/>
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>public_key</h1>
  <h2 class="modsummary"> API module for public key infrastructure.</h2>
  <div class="description">
    <p>This module provides functions to handle public key infrastructure. It can
    encode/decode different file formats (PEM, openssh), sign and verify digital signatures and validate
    certificate paths and certificate revocation lists.
    </p>
  </div>

  <div class="section">
    <h4>public_key</h4>

    <list type="bulleted">
      <item>public_key requires the crypto and asn1 applications, the latter since R16 (hopefully the runtime dependency on asn1 will
      be removed again in the future).</item>

      <item>Supports <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280 </url> -
      Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc3447.txt"> PKCS-1 </url> - RSA Cryptography Standard </item>
      <item>Supports <url href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf"> DSS</url>- Digital Signature Standard (DSA - Digital Signature Algorithm)</item>
      <item>Supports <url href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-3-diffie-hellman-key-agreement-standar.htm"> PKCS-3 </url> - Diffie-Hellman Key Agreement Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc2898.txt"> PKCS-5</url> - Password-Based Cryptography Standard </item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5208.txt"> PKCS-8</url> - Private-Key Information Syntax Standard</item>
      <item>Supports <url href="http://www.ietf.org/rfc/rfc5967.txt"> PKCS-10</url> - Certification Request Syntax Standard</item>
    </list>
  </div>

  <div class="section">
    <h4>COMMON DATA TYPES </h4> 
    
    <div class="note"><h2>Note!</h2><p>All records used in this manual 
    are generated from ASN.1 specifications
    and are documented in the User's Guide. See <a href="public_key_records.html" class="seealso">Public key records</a> and <a href="cert_records.html" class="seealso">X.509 Certificate records</a>. 
    </p></div>
    
    <p>Use the following include directive to get access to the 
    records and constant macros described here and in the User's Guide.</p>
    
    <code> -include_lib("public_key/include/public_key.hrl").</code>

    <p><em>Data Types </em></p>
    
    <p><code>oid() - Object Identifier, a tuple of integers as generated by the ASN1 compiler.</code></p>

    <p><code>boolean() = true | false</code></p>

    <p><code>string() = [bytes()]</code></p>

    <p><code>der_encoded() = binary()</code></p>
   
    <p><code>pki_asn1_type() = 'Certificate' | 'RSAPrivateKey'| 'RSAPublicKey' |
    'DSAPrivateKey' | 'DSAPublicKey' | 'DHParameter' |
    'SubjectPublicKeyInfo' | 'PrivateKeyInfo' |
    'CertificationRequest' | 'ECPrivateKey' | 'EcpkParameters'</code></p>
    
    <p><code>pem_entry () = {pki_asn1_type(), binary(), %% DER or encrypted DER
    not_encrypted | cipher_info()}</code></p>

    <p><code>cipher_info()  =  {"RC2-CBC | "DES-CBC" | "DES-EDE3-CBC",
    crypto:rand_bytes(8) | {#'PBEParameter{}, digest_type()} |#'PBES2-params'{}}</code></p>
	  
    <p><code>public_key()  = rsa_public_key() | dsa_public_key() | ec_public_key()</code></p>
    <p><code>private_key() = rsa_private_key() | dsa_private_key() | ec_private_key()</code></p>
    <p><code>rsa_public_key()  = #'RSAPublicKey'{}</code></p>

    <p><code>rsa_private_key() = #'RSAPrivateKey'{}</code></p>

    <p><code>dsa_public_key()  = {integer(),  #'Dss-Parms'{}}</code></p>

    <p><code>dsa_private_key() = #'DSAPrivateKey'{}</code></p>

    <p><code>ec_public_key()   = {#'ECPoint'{}, #'EcpkParameters'{} |
    {namedCurve, oid()}}</code></p>
    
    <p><code>ec_private_key()  = #'ECPrivateKey'{}</code></p>

    <p><code>public_crypt_options() = [{rsa_pad, rsa_padding()}].</code></p>

    <p><code>rsa_padding() =  'rsa_pkcs1_padding' | 'rsa_pkcs1_oaep_padding' |
    'rsa_no_padding'</code></p>

    <p><code>digest_type() - Union of below digest types</code></p>
    
    <p><code>rsa_digest_type()   = 'md5' | 'sha' | 'sha224' | 'sha256' | 'sha384' |
    'sha512'</code></p>

    <p><code>dss_digest_type()   = 'sha'</code></p>

    <p><code>ecdsa_digest_type() = 'sha'| 'sha224' | 'sha256' | 'sha384' | 'sha512'</code></p>

    <p><code>crl_reason()  = unspecified | keyCompromise | cACompromise |
    affiliationChanged | superseded | cessationOfOperation |
    certificateHold | privilegeWithdrawn | aACompromise</code></p>

    <p><code>ssh_file()  = openssh_public_key | rfc4716_public_key | known_hosts |
    auth_keys</code></p>
    
</div> 

<div id="functions" class="category"><h4><a href="#functions">Functions</a></h4><hr/>    

  <div class="function">
    <h3 id="compute_key/2">compute_key(OthersKey, MyKey)-&gt;</h3>
    <h3 id="compute_key/3">compute_key(OthersKey, MyKey, Params)-&gt;</h3>
    
    <ul class="type">
      <li><code>OthersKey = #'ECPoint'{} | binary(), MyKey = #'ECPrivateKey'{} | binary()</code></li>
      <li><code>Params =  #'DHParameter'{}</code></li>
    </ul>
  <div class="description">
    <p> Compute shared secret </p>
  </div>
  </div>

  <div class="function">
    <h3 id="decrypt_private/2">decrypt_private(CipherText, Key) -&gt; binary()</h3>
    <h3 id="decrypt_private/3">decrypt_private(CipherText, Key, Options) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p>Public key decryption using the private key. See also <a href="../crypto/crypto.html#private_decrypt/4" class="seealso">crypto:private_decrypt/4</a></p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="decrypt_public/2">decrypt_public(CipherText, Key) - &gt; binary()</h3>
    <h3 id="decrypt_public/3">decrypt_public(CipherText, Key, Options) - &gt; binary()</h3>
    
    <ul class="type">
      <li><code>CipherText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li>
      <li><code>Options = public_crypt_options()</code></li>
  </ul> 
  <div class="description"> 
    <p> Public key decryption using the public key. See also <a href="../crypto/crypto.html#public_decrypt/4" class="seealso">crypto:public_decrypt/4</a></p> 
  </div> 
  </div> 

  <div class="function">
    <h3 id="der_decode/2">der_decode(Asn1type, Der) -&gt; term()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d> ASN.1 type present in the public_key applications
      asn1 specifications.</d>
      <li><code>Der = der_encoded()</code></li>
    </ul> 
    <div class="description"> 
      <p> Decodes a public key ASN.1 DER encoded entity.</p>
    </div> 
  </div>
    
  <div class="function">
    <h3 id="der_encode/2">der_encode(Asn1Type, Entity) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d> Asn1 type present in the public_key applications
	 ASN.1 specifications.</d>
      <li><code>Entity = term()</code></li>
      <d>The erlang representation of <code>Asn1Type</code></d>
  </ul> 
  <div class="description"> 
    <p> Encodes a public key entity with ASN.1 DER encoding.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="generate_key/1">generate_key(Params) -&gt; {Public::binary(), Private::binary()}  | #'ECPrivateKey'{} </h3>
    
    <ul class="type">
      <li><code> Params = #'DHParameter'{} |  {namedCurve, oid()} |  #'ECParameters'{} </code></li>
    </ul>
  <div class="description">
    <p>Generates a new keypair</p>
  </div>
  </div>

  <div class="function">
    <h3 id="pem_decode/1">pem_decode(PemBin) -&gt; [pem_entry()]</h3>
    
    <ul class="type">
      <li><code>PemBin = binary()</code></li>
      <d>Example {ok, PemBin} = file:read_file("cert.pem").</d>
    </ul> 
  <div class="description"> 
    <p>Decode PEM binary data and return
    entries as ASN.1 DER encoded entities.</p>
  </div> 
  </div> 
    
   <div class="function">
    <h3 id="pem_encode/1">pem_encode(PemEntries) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code> PemEntries = [pem_entry()] </code></li> 
  </ul> 
  <div class="description"> 
    <p>Creates a PEM binary</p> 
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_decode/1">pem_entry_decode(PemEntry) -&gt; term()</h3>
    <h3 id="pem_entry_decode/2">pem_entry_decode(PemEntry, Password) -&gt; term()</h3>
    
    <ul class="type">
      <li><code> PemEntry = pem_entry() </code></li> 
      <li><code> Password = string() </code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes a PEM entry. pem_decode/1 returns a list of PEM
    entries. Note that if the PEM entry is of type
    'SubjectPublickeyInfo' it will be further decoded to an
    rsa_public_key() or dsa_public_key().</p>
  </div> 
  </div>

   <div class="function">
    <h3 id="pem_entry_encode/2">pem_entry_encode(Asn1Type, Entity) -&gt; pem_entry()</h3>
    <h3 id="pem_entry_encode/4">pem_entry_encode(Asn1Type, Entity, {CipherInfo, Password}) -&gt; pem_entry()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = pki_asn1_type()</code></li>
      <li><code>Entity = term()</code></li>
      <d>The Erlang representation of
      <code>Asn1Type</code>.  If <code>Asn1Type</code> is 'SubjectPublicKeyInfo'
      then <code>Entity</code> must be either an rsa_public_key() or a
      dsa_public_key() and this function will create the appropriate
      'SubjectPublicKeyInfo' entry.
      </d>
      <li><code>CipherInfo = cipher_info()</code></li>
      <li><code>Password = string()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Creates a PEM entry that can be feed to pem_encode/1.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="encrypt_private/2">encrypt_private(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_private_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Public key encryption using the private key.
     See also <a href="../crypto/crypto.html#private_encrypt/4" class="seealso">crypto:private_encrypt/4</a></p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="encrypt_public/2">encrypt_public(PlainText, Key) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>PlainText = binary()</code></li>
      <li><code>Key = rsa_public_key()</code></li> 
  </ul> 
  <div class="description"> 
    <p> Public key encryption using the public key.  See also <a href="../crypto/crypto.html#public_encrypt/4" class="seealso">crypto:public_encrypt/4</a></p> 
  </div> 
  </div>   
  
  <div class="function">
    <h3 id="pkix_decode_cert/2">pkix_decode_cert(Cert, otp|plain) -&gt;  #'Certificate'{} | #'OTPCertificate'{}</h3>
    
    <ul class="type">
      <li><code>Cert = der_encoded()</code></li> 
  </ul> 
  <div class="description"> 
    <p>Decodes an ASN.1 DER encoded PKIX certificate.  The otp option
    will use the customized ASN.1 specification OTP-PKIX.asn1 for
    decoding and also recursively decode most of the standard
    parts.</p>
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_encode/3">pkix_encode(Asn1Type, Entity, otp | plain) -&gt; der_encoded()</h3>
    
    <ul class="type">
      <li><code>Asn1Type = atom()</code></li>
      <d>The ASN.1 type can be 'Certificate', 'OTPCertificate' or a subtype of either .</d>
      <li><code>Entity = #'Certificate'{} | #'OTPCertificate'{} | a valid subtype</code></li>
  </ul> 
  <div class="description"> 
    <p>DER encodes a PKIX x509 certificate or part of such a
    certificate. This function must be used for encoding certificates or parts of certificates
    that are decoded/created in the otp format, whereas for the plain format this
    function will directly call der_encode/2. </p> 
  </div> 
  </div>

 <div class="function">
    <h3 id="pkix_is_issuer/2">pkix_is_issuer(Cert, IssuerCert) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
      <li><code>IssuerCert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if <code>IssuerCert</code> issued <code>Cert</code> </p> 
  </div> 
  </div>
  
  <div class="function">
    <h3 id="pkix_is_fixed_dh_cert/1">pkix_is_fixed_dh_cert(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
        <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if a Certificate is a fixed Diffie-Hellman Cert.</p> 
  </div> 
  </div>  
  
  <div class="function">
    <h3 id="pkix_is_self_signed/1">pkix_is_self_signed(Cert) -&gt; boolean()</h3>
    
    <ul class="type">
       <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li> 
  </ul> 
  <div class="description"> 
    <p> Checks if a Certificate is self signed.</p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_issuer_id/2">pkix_issuer_id(Cert, IssuedBy) -&gt; {ok, IssuerID} | {error, Reason}</h3>
    
    <ul class="type">
        <li><code>Cert = der_encode() | #'OTPCertificate'{}</code></li>
	<li><code>IssuedBy = self | other</code></li>
	<li><code>IssuerID = {integer(), {rdnSequence, [#'AttributeTypeAndValue'{}]}}</code></li>
	<d>The issuer id consists of the serial number and the issuers name.</d>
	<li><code>Reason = term()</code></li>
  </ul> 
  <div class="description"> 
    <p> Returns the issuer id.</p> 
  </div> 
  </div>

  <div class="function">
    <h3 id="pkix_normalize_name/1">pkix_normalize_name(Issuer) -&gt; Normalized</h3>
    
    <ul class="type">
      <li><code>Issuer = {rdnSequence,[#'AttributeTypeAndValue'{}]}</code></li>
      <li><code>Normalized = {rdnSequence, [#'AttributeTypeAndValue'{}]}</code></li>
  </ul> 
  <div class="description"> 
    <p>Normalizes a issuer name so that it can be easily
    compared to another issuer name.</p> 
  </div> 
  </div>
   
  <div class="function">
    <h3 id="pkix_path_validation/3">pkix_path_validation(TrustedCert, CertChain, Options) -&gt; {ok, {PublicKeyInfo, PolicyTree}} | {error, {bad_cert, Reason}} </h3>
    
     <ul class="type">
       <li><code> TrustedCert =  #'OTPCertificate'{} | der_encode() | atom()  </code></li>
       <d>Normally a trusted certificate but it can also be a path validation
       error that can be discovered while
       constructing the input to this function and that should be run through the <code>verify_fun</code>.
       For example <code>unknown_ca </code> or <code>selfsigned_peer </code>
       </d>
       <li><code> CertChain = [der_encode()]</code></li>
       <d>A list of DER encoded certificates in trust order ending with the peer certificate.</d>
       <li><code> Options = proplists:proplist()</code></li>
       <li><code>PublicKeyInfo = {?'rsaEncryption' | ?'id-dsa',
       rsa_public_key() | integer(), 'NULL' | 'Dss-Parms'{}}</code></li>
       <li><code> PolicyTree = term() </code></li>
       <d>At the moment this will always be an empty list as Policies are not currently supported</d>
       <li><code> Reason = cert_expired | invalid_issuer | invalid_signature | name_not_permitted |
       missing_basic_constraint | invalid_key_usage | {revoked, crl_reason()} | atom()
       </code></li>
     </ul>
     <div class="description">
       <p>
	 Performs a basic path validation according to
	 <url href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280.</url>
	 However CRL validation is done separately by <a href="#pkix_crls_validate/3" class="seealso">pkix_crls_validate/3 </a> and should be called
	 from the supplied <code>verify_fun</code>
       </p>

       <taglist>
	 <p> Available options are: </p>

	<dt>{verify_fun, fun()}</dt>
	<item>
	  <p>The fun should be defined as:</p>

	  <code>
fun(OtpCert :: #'OTPCertificate'{},
    Event :: {bad_cert, Reason :: atom() | {revoked, atom()}} |
             {extension, #'Extension'{}},
    InitialUserState :: term()) -&gt;
	{valid, UserState :: term()} |
	{valid_peer, UserState :: term()} |
	{fail, Reason :: term()} |
	{unknown, UserState :: term()}.
	  </code>

	<p>If the verify callback fun returns {fail, Reason}, the
	verification process is immediately stopped. If the verify
	callback fun returns {valid, UserState}, the verification
	process is continued, this can be used to accept specific path
	validation errors such as <code>selfsigned_peer</code> as well as
	verifying application specific extensions.  If called with an
	extension unknown to the user application the return value
	{unknown, UserState} should be used.</p>

	</item>
	<dt>{max_path_length, integer()}</dt>
	<item>
	  The <code>max_path_length</code> is the maximum number of non-self-issued
	  intermediate certificates that may follow the peer certificate
	  in a valid certification path.  So if <code>max_path_length</code> is 0 the PEER must
	  be signed by the trusted ROOT-CA directly, if 1 the path can
	  be PEER, CA, ROOT-CA, if it is 2 PEER, CA, CA, ROOT-CA and so
	  on.
	</item>
      </taglist>

      <p> Possible reasons for a bad certificate are: </p>
      <taglist>
	<dt>cert_expired</dt>
	<item>The certificate is no longer valid as its expiration date has passed.</item>

	<dt>invalid_issuer</dt>
	<item>The certificate issuer name does not match the name of the issuer certificate in the chain.</item>

	<dt>invalid_signature</dt>
	<item>The certificate was not signed by its issuer certificate in the chain.</item>

	<dt>name_not_permitted</dt>
	<item>Invalid Subject Alternative Name extension.</item>

	<dt>missing_basic_constraint</dt>
	<item>Certificate, required to have the basic constraints extension, does not have
	a basic constraints extension.</item>

	<dt>invalid_key_usage</dt>
	<item>Certificate key is used in an invalid way according to the key usage extension.</item>

	<dt>{revoked, crl_reason()}</dt>
	<item>Certificate has been revoked.</item>

	<dt>atom()</dt>
	<item>Application specific error reason that should be checked by the verify_fun</item>
      </taglist>

    </div>
   </div>

   <div class="function">
     <h3 id="pkix_crls_validate/3">pkix_crls_validate(OTPCertificate, DPAndCRLs, Options) -&gt; CRLStatus()</h3>
     
     <ul class="type">
       <li><code> OTPCertificate =  #'OTPCertificate'{}</code></li>
       <li><code> DPAndCRLs  = [{DP::#'DistributionPoint'{}, {DerCRL::der_encoded(), CRL::#'CertificateList'{}}}] </code></li>
       <li><code> Options = proplists:proplist()</code></li>
       <li><code> CRLStatus() =  valid | {bad_cert, revocation_status_undetermined} |
       {bad_cert, {revoked, crl_reason()}}</code></li>
     </ul>
     <div class="description">
      <p> Performs CRL validation. It is intended to be called from
      the verify fun of  <a href="#pkix_path_validation/3" class="seealso"> pkix_path_validation/3
       </a></p>
      <taglist>
	<p> Available options are: </p>
	<dt>{update_crl, fun()}</dt>
	<item>
	  <p>The fun has the following type spec:</p>

	  <code> fun(#'DistributionPoint'{}, #'CertificateList'{}) -&gt;
        #'CertificateList'{}</code>

	  <p>The fun should use the information in the distribution point to acesses
	  the lates possible version of the CRL. If this fun is not specified
	  public_key will use the default implementation:
	  </p>
	  <code> fun(_DP, CRL) -&gt; CRL end</code>
	</item>

	<dt>{issuer_fun, fun()}</dt>
	<item>
	  <p>The fun has the following type spec:</p>

	  <code>
fun(#'DistributionPoint'{}, #'CertificateList'{},
    {rdnSequence,[#'AttributeTypeAndValue'{}]}, term()) -&gt;
	{ok, #'OTPCertificate'{}, [der_encoded]}</code>

	  <p>The fun should return the root certificate and certificate chain
	  that has signed the CRL. 
	  </p>
	  <code> fun(DP, CRL, Issuer, UserState) -&gt; {ok, RootCert, CertChain}</code>
	</item>	
      </taglist>
    </div>
   </div>

  <div class="function">
    <h3 id="pkix_sign/2">pkix_sign(#'OTPTBSCertificate'{}, Key) -&gt; der_encode()</h3>
    
    <ul class="type">
      <li><code>Key = rsa_public_key() | dsa_public_key()</code></li> 
    </ul> 
    <div class="description"> 
      <p>Signs a 'OTPTBSCertificate'. Returns the corresponding
      der encoded certificate.</p> 
    </div> 
  </div> 

  <div class="function">
    <h3 id="pkix_sign_types/1">pkix_sign_types(AlgorithmId) -&gt; {DigestType, SignatureType}</h3>
    
    <ul class="type">
      <li><code>AlgorithmId = oid()</code></li>
      <d>Signature oid from a certificate or a certificate revocation list</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type() </code></li>
      <li><code>SignatureType = rsa | dsa</code></li>
    </ul>
    <div class="description">
      <p>Translates signature algorithm oid to erlang digest and signature types.
      </p>
    </div>
  </div>

  <div class="function">  
    <h3 id="pkix_verify/2">pkix_verify(Cert, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Cert = der_encode()</code></li> 
      <li><code>Key = rsa_public_key() | dsa_public_key()</code></li> 
    </ul> 
  <div class="description"> 
    <p> Verify PKIX x.509 certificate signature.</p>
  </div> 
  </div> 

  <div class="function">
    <h3 id="sign/3">sign(Msg, DigestType, Key) -&gt; binary()</h3>
    
    <ul class="type">
       <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The msg is either the binary "plain text" data to be
       signed or it is the hashed value of "plain text" i.e. the
       digest.</d>
       <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
       <li><code>Key = rsa_private_key() | dsa_private_key() | ec_private_key()</code></li>
  </ul>
  <div class="description">
    <p> Creates a digital signature.</p> 
  </div> 
  </div>   

  <div class="function">
    <h3 id="ssh_decode/2">ssh_decode(SshBin,  Type) -&gt; [{public_key(), Attributes::list()}]</h3>
    
    <ul class="type">
      <li><code>SshBin = binary()</code></li>
      <d>Example {ok, SshBin} = file:read_file("known_hosts").</d>
      <li><code> Type = public_key | ssh_file()</code></li>
      <d>If <code>Type</code> is <code>public_key</code> the binary may be either
      a rfc4716 public key or a openssh public key.</d>
    </ul>
  <div class="description">
    <p> Decodes a ssh file-binary. In the case of know_hosts or
    auth_keys the binary may include one or more lines of the
    file. Returns a list of public keys and their attributes, possible
    attribute values depends on the file type represented by the
    binary.
    </p>

    <taglist>
      <dt>rfc4716 attributes - see RFC 4716</dt>
      <item>{headers, [{string(), utf8_string()}]}</item>
      <dt>auth_key attributes - see man sshd </dt>
      <item>{comment, string()}</item>
      <item>{options, [string()]}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
      <dt>known_host attributes - see man sshd</dt>
      <item>{hostnames, [string()]}</item>
      <item>{comment, string()}</item>
      <item>{bits, integer()} - In ssh version 1 files</item>
    </taglist>

  </div>
  </div>

  <div class="function">
    <h3 id="ssh_encode/3">ssh_encode([{Key, Attributes}], Type) -&gt; binary()</h3>
    
    <ul class="type">
      <li><code>Key = public_key()</code></li>
      <li><code>Attributes = list()</code></li>
      <li><code>Type = ssh_file()</code></li>
    </ul>
  <div class="description">
    <p>Encodes a list of ssh file entries (public keys and attributes) to a binary. Possible
    attributes depends on the file type, see <a href="#ssh_decode/2" class="seealso"> ssh_decode/2 </a></p>
  </div>
  </div>

  <div class="function">
    <h3 id="verify/4">verify(Msg, DigestType, Signature, Key) -&gt; boolean()</h3>
    
    <ul class="type">
      <li><code>Msg = binary() | {digest,binary()}</code></li>
       <d>The msg is either the binary "plain text" data 
        or it is the hashed value of "plain text" i.e. the digest.</d>
      <li><code>DigestType = rsa_digest_type() | dss_digest_type() | ecdsa_digest_type()</code></li>
      <li><code>Signature = binary()</code></li>
      <li><code>Key = rsa_public_key() | dsa_public_key() | ec_public_key()</code></li>
  </ul>
  <div class="description">
    <p>Verifies a digital signature</p>
  </div> 
  </div>
  
</div>


      </div>
  </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>
  </body>
</html>
