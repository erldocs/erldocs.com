<module name="lists">
<spec>
  <name>all</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>all(Pred, List) -&gt; boolean()</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>any</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>any(Pred, List) -&gt; boolean()</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>append</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>append(ListOfLists) -&gt; List1</head>
      <guard>
        <subtype><typename>ListOfLists</typename><string>ListOfLists = [List]</string></subtype>
        <subtype><typename>List</typename><string>List = List1 = [T]</string></subtype>
        <subtype><typename>List1</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>List1</anno>
  <anno>ListOfLists</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>append</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>append(List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = List3 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>List3</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>concat</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>concat(Things) -&gt; string()</head>
      <guard>
        <subtype><typename>Things</typename><string>Things = [Thing]</string></subtype>
        <subtype><typename>Thing</typename><string>Thing = atom() | integer() | float() | string()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Thing</anno>
  <anno>Things</anno>
</spec>
<spec>
  <name>delete</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>delete(Elem, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Elem</typename><string>Elem = T</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>dropwhile</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>dropwhile(Pred, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>duplicate</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>duplicate(N, Elem) -&gt; List</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 0</string></subtype>
        <subtype><typename>Elem</typename><string>Elem = T</string></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>N</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>filter</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>filter(Pred, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>filtermap</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>filtermap(Fun, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((Elem) -&gt; boolean() | {true, Value})</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [Elem]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Elem | Value]</string></subtype>
        <subtype><typename>Elem</typename><string>Elem = Value = term()</string></subtype>
        <subtype><typename>Value</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Value</anno>
</spec>
<spec>
  <name>flatlength</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>flatlength(DeepList) -&gt; integer() &gt;= 0</head>
      <guard>
        <subtype><typename>DeepList</typename><string>DeepList = [term() | DeepList]</string></subtype>
      </guard></clause>
  </contract>
  <anno>DeepList</anno>
</spec>
<spec>
  <name>flatmap</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>flatmap(Fun, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A) -&gt; [B])</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
</spec>
<spec>
  <name>flatten</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>flatten(DeepList) -&gt; List</head>
      <guard>
        <subtype><typename>DeepList</typename><string>DeepList = [term() | DeepList]</string></subtype>
        <subtype><typename>List</typename><string>List = [term()]</string></subtype>
      </guard></clause>
  </contract>
  <anno>DeepList</anno>
  <anno>List</anno>
</spec>
<spec>
  <name>flatten</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>flatten(DeepList, Tail) -&gt; List</head>
      <guard>
        <subtype><typename>DeepList</typename><string>DeepList = [term() | DeepList]</string></subtype>
        <subtype><typename>Tail</typename><string>Tail = List = [term()]</string></subtype>
        <subtype><typename>List</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>DeepList</anno>
  <anno>List</anno>
  <anno>Tail</anno>
</spec>
<spec>
  <name>foldl</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>foldl(Fun, Acc0, List) -&gt; Acc1</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)</string></subtype>
        <subtype><typename>Acc0</typename><string>Acc0 = Acc1 = AccIn = AccOut = term()</string></subtype>
        <subtype><typename>Acc1</typename><string/></subtype>
        <subtype><typename>AccIn</typename><string/></subtype>
        <subtype><typename>AccOut</typename><string/></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Acc0</anno>
  <anno>Acc1</anno>
  <anno>AccIn</anno>
  <anno>AccOut</anno>
  <anno>Elem</anno>
  <anno>Fun</anno>
  <anno>List</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>foldr</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>foldr(Fun, Acc0, List) -&gt; Acc1</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((Elem :: T, AccIn) -&gt; AccOut)</string></subtype>
        <subtype><typename>Acc0</typename><string>Acc0 = Acc1 = AccIn = AccOut = term()</string></subtype>
        <subtype><typename>Acc1</typename><string/></subtype>
        <subtype><typename>AccIn</typename><string/></subtype>
        <subtype><typename>AccOut</typename><string/></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Acc0</anno>
  <anno>Acc1</anno>
  <anno>AccIn</anno>
  <anno>AccOut</anno>
  <anno>Elem</anno>
  <anno>Fun</anno>
  <anno>List</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>foreach</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>foreach(Fun, List) -&gt; ok</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((Elem :: T) -&gt; term())</string></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>Fun</anno>
  <anno>List</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>keydelete</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keydelete(Key, N, TupleList1) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>keyfind</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keyfind(Key, N, TupleList) -&gt; Tuple | false</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList</typename><string>TupleList = [Tuple]</string></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList</anno>
</spec>
<spec>
  <name>keymap</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keymap(Fun, N, TupleList1) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((Term1 :: term()) -&gt; Term2 :: term())</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Fun</anno>
  <anno>N</anno>
  <anno>Term1</anno>
  <anno>Term2</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>keymember</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keymember(Key, N, TupleList) -&gt; boolean()</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList</typename><string>TupleList = [Tuple]</string></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList</anno>
</spec>
<spec>
  <name>keymerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = [T1]</string></subtype>
        <subtype><typename>TupleList2</typename><string>TupleList2 = [T2]</string></subtype>
        <subtype><typename>TupleList3</typename><string>TupleList3 = [(T1 | T2)]</string></subtype>
        <subtype><typename>T1</typename><string>T1 = T2 = Tuple</string></subtype>
        <subtype><typename>T2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>N</anno>
  <anno>T1</anno>
  <anno>T2</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
  <anno>TupleList3</anno>
</spec>
<spec>
  <name>keyreplace</name>
  <arity>4</arity>
  <contract>
    <clause>
      <head>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>NewTuple</typename><string>NewTuple = Tuple</string></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>NewTuple</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>keysearch</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList</typename><string>TupleList = [Tuple]</string></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList</anno>
</spec>
<spec>
  <name>keysort</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>keysort(N, TupleList1) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>keystore</name>
  <arity>4</arity>
  <contract>
    <clause>
      <head>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string>TupleList2 = [Tuple, ...]</string></subtype>
        <subtype><typename>NewTuple</typename><string>NewTuple = Tuple</string></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>NewTuple</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>keytake</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</head>
      <guard>
        <subtype><typename>Key</typename><string>Key = term()</string></subtype>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [tuple()]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Key</anno>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>last</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>last(List) -&gt; Last</head>
      <guard>
        <subtype><typename>List</typename><string>List = [T, ...]</string></subtype>
        <subtype><typename>Last</typename><string>Last = T</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Last</anno>
  <anno>List</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>map</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>map(Fun, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A) -&gt; B)</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
</spec>
<spec>
  <name>mapfoldl</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A, AccIn) -&gt; {B, AccOut})</string></subtype>
        <subtype><typename>Acc0</typename><string>Acc0 = Acc1 = AccIn = AccOut = term()</string></subtype>
        <subtype><typename>Acc1</typename><string/></subtype>
        <subtype><typename>AccIn</typename><string/></subtype>
        <subtype><typename>AccOut</typename><string/></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>Acc0</anno>
  <anno>Acc1</anno>
  <anno>AccIn</anno>
  <anno>AccOut</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
</spec>
<spec>
  <name>mapfoldr</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A, AccIn) -&gt; {B, AccOut})</string></subtype>
        <subtype><typename>Acc0</typename><string>Acc0 = Acc1 = AccIn = AccOut = term()</string></subtype>
        <subtype><typename>Acc1</typename><string/></subtype>
        <subtype><typename>AccIn</typename><string/></subtype>
        <subtype><typename>AccOut</typename><string/></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>Acc0</anno>
  <anno>Acc1</anno>
  <anno>AccIn</anno>
  <anno>AccOut</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
</spec>
<spec>
  <name>max</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>max(List) -&gt; Max</head>
      <guard>
        <subtype><typename>List</typename><string>List = [T, ...]</string></subtype>
        <subtype><typename>Max</typename><string>Max = T</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>Max</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>member</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>member(Elem, List) -&gt; boolean()</head>
      <guard>
        <subtype><typename>Elem</typename><string>Elem = T</string></subtype>
        <subtype><typename>List</typename><string>List = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>merge</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>merge(ListOfLists) -&gt; List1</head>
      <guard>
        <subtype><typename>ListOfLists</typename><string>ListOfLists = [List]</string></subtype>
        <subtype><typename>List</typename><string>List = List1 = [T]</string></subtype>
        <subtype><typename>List1</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>List1</anno>
  <anno>ListOfLists</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>merge</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>merge(List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [(X | Y)]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>merge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>merge(Fun, List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A, B) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [(A | B)]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
</spec>
<spec>
  <name>merge3</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>merge3(List1, List2, List3) -&gt; List4</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [Z]</string></subtype>
        <subtype><typename>List4</typename><string>List4 = [(X | Y | Z)]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = Z = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
        <subtype><typename>Z</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>List4</anno>
  <anno>X</anno>
  <anno>Y</anno>
  <anno>Z</anno>
</spec>
<spec>
  <name>min</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>min(List) -&gt; Min</head>
      <guard>
        <subtype><typename>List</typename><string>List = [T, ...]</string></subtype>
        <subtype><typename>Min</typename><string>Min = T</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>Min</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>nth</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>nth(N, List) -&gt; Elem</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>List</typename><string>List = [T, ...]</string></subtype>
        <subtype><typename>Elem</typename><string>Elem = T</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>N</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>nthtail</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>nthtail(N, List) -&gt; Tail</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 0</string></subtype>
        <subtype><typename>List</typename><string>List = [T, ...]</string></subtype>
        <subtype><typename>Tail</typename><string>Tail = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>N</anno>
  <anno>T</anno>
  <anno>Tail</anno>
</spec>
<spec>
  <name>partition</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>partition(Pred, List) -&gt; {Satisfying, NotSatisfying}</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List</typename><string>List = Satisfying = NotSatisfying = [T]</string></subtype>
        <subtype><typename>Satisfying</typename><string/></subtype>
        <subtype><typename>NotSatisfying</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List</anno>
  <anno>NotSatisfying</anno>
  <anno>Pred</anno>
  <anno>Satisfying</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>prefix</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>prefix(List1, List2) -&gt; boolean()</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>reverse</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>reverse(List1) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>reverse</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>reverse(List1, Tail) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [T]</string></subtype>
        <subtype><typename>Tail</typename><string>Tail = term()</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [T]</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
  <anno>Tail</anno>
</spec>
<spec>
  <name>rkeymerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rkeymerge(Index :: integer() &gt;= 1, X :: [X], Y :: [Y]) -&gt; [R]</head>
      <guard>
        <subtype><typename>X</typename><string>X = Y = R = tuple()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
        <subtype><typename>R</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>Index</anno>
  <anno>R</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rmerge</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>rmerge(X :: [X], Y :: [Y]) -&gt; [(X | Y)]</head></clause>
  </contract>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rmerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rmerge(Fun :: fun((X, Y) -&gt; boolean()), X :: [X], Y :: [Y]) -&gt;<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>[(X | Y)]</head></clause>
  </contract>
  <anno>Fun</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rmerge3</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rmerge3(X :: [X], Y :: [Y], Z :: [Z]) -&gt; [(X | Y | Z)]</head></clause>
  </contract>
  <anno>X</anno>
  <anno>Y</anno>
  <anno>Z</anno>
</spec>
<spec>
  <name>rukeymerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rukeymerge(Index :: integer() &gt;= 1, X :: [X], Y :: [Y]) -&gt;<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>[(X | Y)]</head>
      <guard>
        <subtype><typename>X</typename><string>X = Y = tuple()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>Index</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rumerge</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>rumerge(X :: [X], Y :: [Y]) -&gt; [(X | Y)]</head></clause>
  </contract>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rumerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rumerge(Fun :: fun((X, Y) -&gt; boolean()), X :: [X], Y :: [Y]) -&gt;<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>[(X | Y)]</head></clause>
  </contract>
  <anno>Fun</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>rumerge3</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>rumerge3(X :: [X], Y :: [Y], Z :: [Z]) -&gt; [(X | Y | Z)]</head></clause>
  </contract>
  <anno>X</anno>
  <anno>Y</anno>
  <anno>Z</anno>
</spec>
<spec>
  <name>seq</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>seq(From, To) -&gt; Seq</head>
      <guard>
        <subtype><typename>From</typename><string>From = To = integer()</string></subtype>
        <subtype><typename>To</typename><string/></subtype>
        <subtype><typename>Seq</typename><string>Seq = [integer()]</string></subtype>
      </guard></clause>
  </contract>
  <anno>From</anno>
  <anno>Seq</anno>
  <anno>To</anno>
</spec>
<spec>
  <name>seq</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>seq(From, To, Incr) -&gt; Seq</head>
      <guard>
        <subtype><typename>From</typename><string>From = To = Incr = integer()</string></subtype>
        <subtype><typename>To</typename><string/></subtype>
        <subtype><typename>Incr</typename><string/></subtype>
        <subtype><typename>Seq</typename><string>Seq = [integer()]</string></subtype>
      </guard></clause>
  </contract>
  <anno>From</anno>
  <anno>Incr</anno>
  <anno>Seq</anno>
  <anno>To</anno>
</spec>
<spec>
  <name>sort</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>sort(List1) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>sort</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>sort(Fun, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A :: T, B :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>split</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>split(N, List1) -&gt; {List2, List3}</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 0</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = List3 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>List3</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>N</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>splitwith</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>splitwith(Pred, List) -&gt; {List1, List2}</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((T) -&gt; boolean())</string></subtype>
        <subtype><typename>List</typename><string>List = List1 = List2 = [T]</string></subtype>
        <subtype><typename>List1</typename><string/></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>sublist</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>sublist(List1, Len) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>Len</typename><string>Len = integer() &gt;= 0</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Len</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>sublist</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>sublist(List1, Start, Len) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>Start</typename><string>Start = integer() &gt;= 1</string></subtype>
        <subtype><typename>Len</typename><string>Len = integer() &gt;= 0</string></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Len</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Start</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>subtract</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>subtract(List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = List3 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>List3</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>suffix</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>suffix(List1, List2) -&gt; boolean()</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>sum</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>sum(List) -&gt; number()</head>
      <guard>
        <subtype><typename>List</typename><string>List = [number()]</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
</spec>
<spec>
  <name>takewhile</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>takewhile(Pred, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Pred</typename><string>Pred = fun((Elem :: T) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Elem</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>Pred</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>ukeymerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = [T1]</string></subtype>
        <subtype><typename>TupleList2</typename><string>TupleList2 = [T2]</string></subtype>
        <subtype><typename>TupleList3</typename><string>TupleList3 = [(T1 | T2)]</string></subtype>
        <subtype><typename>T1</typename><string>T1 = T2 = Tuple</string></subtype>
        <subtype><typename>T2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>N</anno>
  <anno>T1</anno>
  <anno>T2</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
  <anno>TupleList3</anno>
</spec>
<spec>
  <name>ukeysort</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>ukeysort(N, TupleList1) -&gt; TupleList2</head>
      <guard>
        <subtype><typename>N</typename><string>N = integer() &gt;= 1</string></subtype>
        <subtype><typename>TupleList1</typename><string>TupleList1 = TupleList2 = [Tuple]</string></subtype>
        <subtype><typename>TupleList2</typename><string/></subtype>
        <subtype><typename>Tuple</typename><string>Tuple = tuple()</string></subtype>
      </guard></clause>
  </contract>
  <anno>N</anno>
  <anno>Tuple</anno>
  <anno>TupleList1</anno>
  <anno>TupleList2</anno>
</spec>
<spec>
  <name>umerge</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>umerge(ListOfLists) -&gt; List1</head>
      <guard>
        <subtype><typename>ListOfLists</typename><string>ListOfLists = [List]</string></subtype>
        <subtype><typename>List</typename><string>List = List1 = [T]</string></subtype>
        <subtype><typename>List1</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List</anno>
  <anno>List1</anno>
  <anno>ListOfLists</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>umerge</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>umerge(List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [(X | Y)]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>umerge</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>umerge(Fun, List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((A, B) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [(A | B)]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
</spec>
<spec>
  <name>umerge3</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>umerge3(List1, List2, List3) -&gt; List4</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [Z]</string></subtype>
        <subtype><typename>List4</typename><string>List4 = [(X | Y | Z)]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = Z = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
        <subtype><typename>Z</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>List4</anno>
  <anno>X</anno>
  <anno>Y</anno>
  <anno>Z</anno>
</spec>
<spec>
  <name>unzip</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>unzip(List1) -&gt; {List2, List3}</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [{A, B}]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [A]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [B]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
</spec>
<spec>
  <name>unzip3</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>unzip3(List1) -&gt; {List2, List3, List4}</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [{A, B, C}]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [A]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [B]</string></subtype>
        <subtype><typename>List4</typename><string>List4 = [C]</string></subtype>
        <subtype><typename>A</typename><string>A = B = C = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
        <subtype><typename>C</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>C</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>List4</anno>
</spec>
<spec>
  <name>usort</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>usort(List1) -&gt; List2</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>usort</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>usort(Fun, List1) -&gt; List2</head>
      <guard>
        <subtype><typename>Fun</typename><string>Fun = fun((T, T) -&gt; boolean())</string></subtype>
        <subtype><typename>List1</typename><string>List1 = List2 = [T]</string></subtype>
        <subtype><typename>List2</typename><string/></subtype>
        <subtype><typename>T</typename><string>T = term()</string></subtype>
      </guard></clause>
  </contract>
  <anno>Fun</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>T</anno>
</spec>
<spec>
  <name>zf</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>zf(F :: fun((T) -&gt; boolean() | {true, X}), T :: [T]) -&gt; [(T | X)]</head></clause>
  </contract>
  <anno>F</anno>
  <anno>T</anno>
  <anno>X</anno>
</spec>
<spec>
  <name>zip</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>zip(List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [{A, B}]</string></subtype>
        <subtype><typename>A</typename><string>A = B = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
</spec>
<spec>
  <name>zip3</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>zip3(List1, List2, List3) -&gt; List4</head>
      <guard>
        <subtype><typename>List1</typename><string>List1 = [A]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [B]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [C]</string></subtype>
        <subtype><typename>List4</typename><string>List4 = [{A, B, C}]</string></subtype>
        <subtype><typename>A</typename><string>A = B = C = term()</string></subtype>
        <subtype><typename>B</typename><string></string></subtype>
        <subtype><typename>C</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>A</anno>
  <anno>B</anno>
  <anno>C</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>List4</anno>
</spec>
<spec>
  <name>zipwith</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>zipwith(Combine, List1, List2) -&gt; List3</head>
      <guard>
        <subtype><typename>Combine</typename><string>Combine = fun((X, Y) -&gt; T)</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [T]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = T = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
        <subtype><typename>T</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>Combine</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>T</anno>
  <anno>X</anno>
  <anno>Y</anno>
</spec>
<spec>
  <name>zipwith3</name>
  <arity>4</arity>
  <contract>
    <clause>
      <head>zipwith3(Combine, List1, List2, List3) -&gt; List4</head>
      <guard>
        <subtype><typename>Combine</typename><string>Combine = fun((X, Y, Z) -&gt; T)</string></subtype>
        <subtype><typename>List1</typename><string>List1 = [X]</string></subtype>
        <subtype><typename>List2</typename><string>List2 = [Y]</string></subtype>
        <subtype><typename>List3</typename><string>List3 = [Z]</string></subtype>
        <subtype><typename>List4</typename><string>List4 = [T]</string></subtype>
        <subtype><typename>X</typename><string>X = Y = Z = T = term()</string></subtype>
        <subtype><typename>Y</typename><string></string></subtype>
        <subtype><typename>Z</typename><string></string></subtype>
        <subtype><typename>T</typename><string></string></subtype>
      </guard></clause>
  </contract>
  <anno>Combine</anno>
  <anno>List1</anno>
  <anno>List2</anno>
  <anno>List3</anno>
  <anno>List4</anno>
  <anno>T</anno>
  <anno>X</anno>
  <anno>Y</anno>
  <anno>Z</anno>
</spec>
<timestamp>Generated by EDoc, May 5 2014, 23:15:50.</timestamp>
</module>