<?xml version="1.0" encoding="utf8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>cerl_clauses</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>cerl_clauses.xml</file></header>
<module>cerl_clauses</module>
<modulesummary>Utility functions for Core Erlang case/receive clauses.</modulesummary>
<description>
<p>Utility functions for Core Erlang case/receive clauses.</p>
 
  <p>Syntax trees are defined in the module <seealso marker="">cerl</seealso>.</p>
 </description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>cerl() = cerl() (see module cerl)</c></tag>
<item><marker id="type-cerl"/> </item>
</taglist></section>
<funcs>
<func>
<name>is_catchall(Clause::cerl()) -&gt; boolean()</name>
<fsummary>Returns true if an abstract clause is a
  catch-all, otherwise false.</fsummary>

<desc><marker id="is_catchall-1"/>

<p>Returns <c>true</c> if an abstract clause is a
  catch-all, otherwise <c>false</c>. A clause is a catch-all if
  all its patterns are variables, and its guard expression always
  evaluates to <c>true</c>; cf. <c>eval_guard/1</c>.</p>
 
  <p>Note: <c>Clause</c> must have type
  <c>clause</c>.</p>
 
<p><em>See also:</em> <seealso marker="#any_catchall-1">any_catchall/1</seealso>, <seealso marker="#eval_guard-1">eval_guard/1</seealso>.</p>
</desc></func>
<func>
<name>any_catchall(Clauses::[cerl()]) -&gt; boolean()</name>
<fsummary>Returns true if any of the abstract clauses in
  the list is a catch-all, otherwise false.</fsummary>

<desc><marker id="any_catchall-1"/>

<p>Returns <c>true</c> if any of the abstract clauses in
  the list is a catch-all, otherwise <c>false</c>.  See
  <c>is_catchall/1</c> for details.</p>
 
  <p>Note: each node in <c>Clauses</c> must have type
  <c>clause</c>.</p>
 
<p><em>See also:</em> <seealso marker="#is_catchall-1">is_catchall/1</seealso>.</p>
</desc></func>
<func>
<name>eval_guard(Expr::cerl()) -&gt; none | {value, term()}</name>
<fsummary>Tries to reduce a guard expression to a single constant value,
  if possible.</fsummary>

<desc><marker id="eval_guard-1"/>

<p>Tries to reduce a guard expression to a single constant value,
  if possible. The returned value is <c>{value, Term}</c> if the
  guard expression <c>Expr</c> always yields the constant value
  <c>Term</c>, and is otherwise <c>none</c>.</p>
 
  <p>Note that although guard expressions should only yield boolean
  values, this function does not guarantee that <c>Term</c> is
  either <c>true</c> or <c>false</c>. Also note that only
  simple constructs like let-expressions are examined recursively;
  general constant folding is not performed.</p>
 
<p><em>See also:</em> <seealso marker="#is_catchall-1">is_catchall/1</seealso>.</p>
</desc></func>
<func>
<name>reduce(Cs::Clauses) -&gt; {true, {Clause, Bindings}} | {false, Clauses}</name>
<fsummary>Equivalent to reduce(Cs, []).
</fsummary>

<desc><marker id="reduce-1"/>
<p>Equivalent to <seealso marker="#reduce-2">reduce(Cs, [])</seealso>.</p>
</desc></func>
<func>
<name>reduce(Clauses::[Clause], Exprs::[Expr]) -&gt; {true, {Clause, Bindings}} | {false, [Clause]}</name>
<fsummary>Selects a single clause, if possible, or otherwise reduces the
  list of selectable clauses.</fsummary>
<type>
<v>Clause = cerl()</v><v>Expr = any | cerl()</v><v>Bindings = [{cerl(), cerl()}]</v></type>
<desc><marker id="reduce-2"/>

<p>Selects a single clause, if possible, or otherwise reduces the
  list of selectable clauses. The input is a list <c>Clauses</c>
  of abstract clauses (i.e., syntax trees of type <c>clause</c>),
  and a list of switch expressions <c>Exprs</c>. The function
  tries to uniquely select a single clause or discard unselectable
  clauses, with respect to the switch expressions. All abstract clauses
  in the list must have the same number of patterns. If
  <c>Exprs</c> is not the empty list, it must have the same
  length as the number of patterns in each clause; see
  <c>match_list/2</c> for details.</p>
 
  <p>A clause can only be selected if its guard expression always
  yields the atom <c>true</c>, and a clause whose guard
  expression always yields the atom <c>false</c> can never be
  selected. Other guard expressions are considered to have unknown
  value; cf. <c>eval_guard/1</c>.</p>
 
  <p>If a particular clause can be selected, the function returns
  <c>{true, {Clause, Bindings}}</c>, where <c>Clause</c> is
  the selected clause and <c>Bindings</c> is a list of pairs
  <c>{Var, SubExpr}</c> associating the variables occurring in
  the patterns of <c>Clause</c> with the corresponding
  subexpressions in <c>Exprs</c>. The list of bindings is given
  in innermost-first order; see the <c>match/2</c> function for
  details.</p>
 
  <p>If no clause could be definitely selected, the function returns
  <c>{false, NewClauses}</c>, where <c>NewClauses</c> is
  the list of entries in <c>Clauses</c> that remain after
  eliminating unselectable clauses, preserving the relative order.</p>
 
<p><em>See also:</em> <seealso marker="#eval_guard-1">eval_guard/1</seealso>, <seealso marker="#match-2">match/2</seealso>, <seealso marker="#match_list-2">match_list/2</seealso>.</p>
</desc></func>
<func>
<name>match(Pattern::cerl(), E::Expr) -&gt; none | {true, Bindings} | {false, Bindings}</name>
<fsummary>Matches a pattern against an expression.</fsummary>
<type>
<v>Expr = any | cerl()</v><v>Bindings = [{cerl(), Expr}]</v></type>
<desc><marker id="match-2"/>

<p>Matches a pattern against an expression. The returned value is
  <c>none</c> if a match is impossible, <c>{true,
  Bindings}</c> if <c>Pattern</c> definitely matches
  <c>Expr</c>, and <c>{false, Bindings}</c> if a match is
  not definite, but cannot be excluded. <c>Bindings</c> is then
  a list of pairs <c>{Var, SubExpr}</c>, associating each
  variable in the pattern with either the corresponding subexpression
  of <c>Expr</c>, or with the atom <c>any</c> if no
  matching subexpression exists. (Recall that variables may not be
  repeated in a Core Erlang pattern.) The list of bindings is given
  in innermost-first order; this should only be of interest if
  <c>Pattern</c> contains one or more alias patterns. If the
  returned value is <c>{true, []}</c>, it implies that the  
pattern and the expression are syntactically identical.</p>
 
  <p>Instead of a syntax tree, the atom <c>any</c> can be
  passed for <c>Expr</c> (or, more generally, be used for any
  subtree of <c>Expr</c>, in as much the abstract syntax tree
  implementation allows it); this means that it cannot be decided
  whether the pattern will match or not, and the corresponding
  variable bindings will all map to <c>any</c>. The typical use
  is for producing bindings for <c>receive</c> clauses.</p>
 
  <p>Note: Binary-syntax patterns are never structurally matched
  against binary-syntax expressions by this function.</p>
 
  <p>Examples:
  </p><list>
    <item><p>Matching a pattern "<c>{X, Y}</c>" against the
    expression "<c>{foo, f(Z)}</c>" yields <c>{true,
    Bindings}</c> where <c>Bindings</c> associates
    "<c>X</c>" with the subtree "<c>foo</c>" and
    "<c>Y</c>" with the subtree "<c>f(Z)</c>".</p></item>
 
    <item><p>Matching pattern "<c>{X, {bar, Y}}</c>" against
    expression "<c>{foo, f(Z)}</c>" yields <c>{false,
    Bindings}</c> where <c>Bindings</c> associates
    "<c>X</c>" with the subtree "<c>foo</c>" and
    "<c>Y</c>" with <c>any</c> (because it is not known
    if "<c>{foo, Y}</c>" might match the run-time value of
    "<c>f(Z)</c>" or not).</p></item>
 
    <item><p>Matching pattern "<c>{foo, bar}</c>" against expression
    "<c>{foo, f()}</c>" yields <c>{false, []}</c>,
    telling us that there might be a match, but we cannot deduce any
    bindings.</p></item>
 
    <item><p>Matching <c>{foo, X = {bar, Y}}</c> against expression
    "<c>{foo, {bar, baz}}</c>" yields <c>{true,
    Bindings}</c> where <c>Bindings</c> associates
    "<c>Y</c>" with "<c>baz</c>", and "<c>X</c>"
    with "<c>{bar, baz}</c>".</p></item>
 
    <item><p>Matching a pattern "<c>{X, Y}</c>" against
    <c>any</c> yields <c>{false, Bindings}</c> where
    <c>Bindings</c> associates both "<c>X</c>" and
    "<c>Y</c>" with <c>any</c>.</p></item>
  </list>
</desc></func>
<func>
<name>match_list(Patterns::[cerl()], Exprs::[Expr]) -&gt; none | {true, Bindings} | {false, Bindings}</name>
<fsummary>Like match/2, but matching a sequence of patterns
  against a sequence of expressions.</fsummary>
<type>
<v>Expr = any | cerl()</v><v>Bindings = [{cerl(), cerl()}]</v></type>
<desc><marker id="match_list-2"/>

<p>Like <c>match/2</c>, but matching a sequence of patterns
  against a sequence of expressions. Passing an empty list for
  <c>Exprs</c> is equivalent to passing a list of
  <c>any</c> atoms of the same length as <c>Patterns</c>.
 </p>
<p><em>See also:</em> <seealso marker="#match-2">match/2</seealso>.</p>
</desc></func></funcs>

<authors>
<aname> </aname>
<email> </email></authors></erlref>