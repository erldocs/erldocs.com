<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8" />
    <title>erl_nif - R13B04 - erldocs.com (Erlang Documentation)</title>
    <link type="text/css" rel="stylesheet" href="../erldocs.css" />
  </head>
  
  <body>

    <div id="sidebar">
      <input type="text" value="Loading..." id="search" autocomplete="off" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
      
  
  <h1>erl_nif</h1>
  <libsummary>API functions for an Erlang NIF library</libsummary>
  <div class="description">
     <div class="warning"><h2>Warning!</h2><p>The NIF concept was introduced in R13B03 as an
	EXPERIMENTAL feature. The interfaces may be changed in any way
	in coming releases. The plan is however to lift the experimental label and
  maintain interface backward compatibility from R14B.</p>
  <p>Incompatible changes in <em>R13B04</em>:</p>
  <ul>
    <li>The function prototypes of the NIFs have  changed to expect <code>argc</code> and <code>argv</code>
	  arguments. The arity of a NIF is by that no longer limited to 3.</li>
    <li><code>enif_get_data</code> renamed as <code>enif_priv_data</code>.</li>
    <li><code>enif_make_string</code> got a third argument for character encoding.</li>
  </ul>
  </div>

    <p>A NIF library contains native implementation of some functions
    of an Erlang module. The native implemented functions (NIFs) are
    called like any other functions without any difference to the
    caller. Each NIF must also have an implementation in Erlang that
    will be invoked if the function is called before the NIF library
    has been successfully loaded. A typical such stub implementation
    is to throw an exception. But it can also be used as a fallback
    implementation if the NIF library is not implemented for some
    architecture.</p>     
    <p>A minimal example of a NIF library can look like this:</p>
      <p  />
      <pre class="sh_erlang">
/* niftest.c */
#include "erl_nif.h"

static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{
    return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
}

static ErlNifFunc nif_funcs[] =
{
    {"hello", 0, hello}
};

ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)
</pre>

    <p>and the Erlang module would have to look something like
    this:</p>
      <p  />
      <pre class="sh_erlang">
-module(niftest).

-export([init/0, hello/0]).

init() -&gt;
      erlang:load_nif("./niftest", 0).

hello() -&gt;
      "NIF library not loaded".
</pre>
    <p>and compile and test something like this (on Linux):</p>
      <p  />
      <pre class="sh_erlang">
$&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
$&gt; erl

1&gt; c(niftest).
{ok,niftest}
2&gt; niftest:hello().
"NIF library not loaded"
3&gt; niftest:init().
ok
4&gt; niftest:hello().
"Hello world!"
</pre>

     <p>A better solution for a real module is to take advantage of
     the new directive <a href="../doc/reference_manual/code_loading.html#on_load" class="seealso">on_load</a> to automatically
     load the NIF library when the module is loaded.</p>
     <div class="note"><h2>Note!</h2><p>A NIF must be exported or used locally by the module (or both).
     An unused local stub function will be optimized away by the compiler
      causing loading of the NIF library to fail.</p>
    </div>
     <p>A loaded NIF library is tied to the Erlang module code version
     that loaded it. If the module is upgraded with a new version, the
     new Erlang code will have to load its own NIF library (or maybe choose not
     to). The new code version can however choose to load the exact
     same NIF library as the old code if it wants to. Sharing the same
     dynamic library will mean that static data defined by the library
     will be shared as well. To avoid unintentionally shared static
     data, each Erlang module code can keep its own private data. This
     private data can be set when the NIF library is loaded and
     then retrieved by calling <a href="#enif_priv_data" class="seealso">enif_priv_data()</a>.</p>
    <p>There is no way to explicitly unload a NIF library. A library will be
     automatically unloaded when the module code that it belongs to is purged
     by the code server. A NIF library will also be unloaded if it is replaced
     by another version of the library by a second call to
     <code>erlang:load_nif/2</code> from the same module code.</p> 
  </div>
  <div class="section">
  <h4>FUNCTIONALITY</h4>
  <p>All functions that a NIF library needs to do with Erlang are
      performed through the NIF API functions. There are functions
      for the following functionality:</p>
    <dl>
      <dt>Read and write Erlang terms</dt>
      <dd><p>Any Erlang terms can be passed to a NIF as function arguments and
      be returned as function return values. The terms are of C-type <code>ERL_NIF_TERM</code>
      and can only be read or written using API functions. Most functions to read
      the content of a term are prefixed <code>enif_get_</code> and usually return
      true (or false) if the term was of the expected type (or not).    
      The functions to write terms are all prefixed <code>enif_make_</code> and usually
      return the created <code>ERL_NIF_TERM</code>. There are also some functions
      to query terms, like <code>enif_is_atom</code>, <code>enif_is_identical</code> and
      <code>enif_compare</code>.</p></dd>
      <dt>Binaries</dt>
      <dd><p>Terms of type binary are accessed with the help of the struct type
      <a href="#ErlNifBinary" class="seealso">ErlNifBinary</a>    
      that contains a pointer (<code>data</code>) to the raw binary data and the length
      (<code>size</code>) of the data in bytes. Both <code>data</code> and <code>size</code> are
      read-only and should only be written using calls to API functions.
      Instances of <code>ErlNifBinary</code> are however always allocated by the user
      (usually as local variables).</p>
      <p>The raw data pointed to by <code>data</code> is only mutable after a call to
      <a href="#enif_alloc_binary" class="seealso">enif_alloc_binary</a> or
      <a href="#enif_realloc_binary" class="seealso">enif_realloc_binary</a>.
      All other functions that operates on a binary will leave the data as read-only.
      A mutable binary must in the end either be freed with
      <a href="#enif_release_binary" class="seealso">enif_release_binary</a>
      or made read-only by transferring it to an Erlang term with
      <a href="#enif_make_binary" class="seealso">enif_make_binary</a>.
      But it does not have do happen in the same NIF call. Read-only binaries
      does not have to be released.</p>
      <p>Binaries are sequences of whole bytes. Bitstrings with an arbitrary
      bit length have no support yet.</p>
       </dd>
      <dt>Resource objects</dt>
      <dd><p>The use of resource objects is a way to return pointers to
      native data structures from a NIF in a safe way. A resource object is
      just a block of memory allocated with
      <a href="#enif_alloc_resource" class="seealso">enif_alloc_resource()</a>.
      A handle ("safe pointer") to this memory block can then be returned to Erlang by the use of
      <a href="#enif_make_resource" class="seealso">enif_make_resource()</a>.
      The term returned by <code>enif_make_resource</code>
      is totally opaque in nature. It can be stored and passed between processses
      on the same node, but the only real end usage is to pass it back as argument to a NIF.
      The NIF can then do <a href="#enif_get_resource" class="seealso">enif_get_resource()</a>
      and get back a pointer to the memory block that is guaranteed to still be
      valid. A resource object will not be deallocated until the last handle term
      has been garbage collected by the VM and the resource has been
      released with <a href="#enif_release_resource" class="seealso">enif_release_resource()</a>
      (not necessarily in that order).</p>      
      <p>All resource objects are created as instances of some <em>resource type</em>.
      This makes resources from different modules to be distinguishable. 
      A resource type is created by calling
      <a href="#enif_open_resource_type" class="seealso">enif_open_resource_type()</a>
      when a library is loaded. Objects of that resource type can then later be allocated
      and <code>enif_get_resource</code> verifies that the resource is of the expected type.
      A resource type can have a user supplied destructor function that is
      automatically called when resources of that type are released (by either
      the garbage collector or <code>enif_release_resource</code>). Resource types
      are uniquely identified by a supplied name string.</p>
      <p>Resource types support upgrade in runtime by allowing a loaded NIF
      library to takeover an already existing resource type and thereby
      "inherit" all existing objects of that type. The destructor of the new
      library will thereafter be called for the inherited objects and the
      library with the old destructor function can be safely unloaded. Existing
      resource objects, of a module that is upgraded, must either be deleted
      or taken over by the new NIF library. The unloading of a library will be
      postponed as long as it exists resource objects with a destructor
      function in the library.
      </p>
      <p>Here is a template example of how to create and return a resource object.</p>
      <p  />
      <pre class="sh_erlang">
    ERL_NIF_TERM term;
    MyStruct* ptr = enif_alloc_resource(env, my_resource_type, sizeof(MyStruct));

    /* initialize struct ... */

    term = enif_make_resource(env, ptr);

    if (keep_a_reference_of_our_own) {
        /* store 'ptr' in static variable, private data or other resource object */
    }
    else {
        enif_release_resource(env, obj);
        /* resource now only owned by "Erlang" */
    }
    return term;
}
</pre>

      </dd>
      <dt>Threads and concurrency</dt>
      <dd><p>A NIF is thread-safe without any explicit synchronization as
      long as it acts as a pure function and only reads the supplied
      arguments. As soon as you write towards a shared state either through
      static variables or <a href="#enif_priv_data" class="seealso">enif_priv_data</a>
      you need to supply your own explicit synchronization. Resource objects
      will also require synchronization if you treat them as mutable.</p>
      <p>The library initialization callbacks <code>load</code>, <code>reload</code> and
      <code>upgrade</code> are all thread-safe even for shared state data.</p>
      <p>Avoid doing lengthy work in NIF calls as that may degrade the
      responsiveness of the VM. NIFs are called directly by the same scheduler
      thread that executed the calling Erlang code. The calling scheduler will thus
      be blocked from doing any other work until the NIF returns.</p>
      </dd>
    </dl>
  </div>
  <div class="section">
    <h4>INITIALIZATION</h4>
    <dl>
      <dt><span id="ERL_NIF_INIT"> </span>ERL_NIF_INIT(MODULE, ErlNifFunc funcs[], load, reload, upgrade, unload)</dt>
      <dd><p>This is the magic macro to initialize a NIF library. It
      should be evaluated in global file scope.</p>
      <p><code>MODULE</code> is the name of the Erlang module as an
      identifier without string quotations. It will be stringified by
      the macro.</p>
      <p><code>funcs</code> is a static array of function descriptors for
      all the implemented NIFs in this library.</p>
      <p><code>load</code>, <code>reload</code>, <code>upgrade</code> and <code>unload</code>
      are pointers to functions. One of <code>load</code>, <code>reload</code> or
      <code>upgrade</code> will be called to initialize the library.
      <code>unload</code> is called to release the library. They are all
      described individually below.</p>
      </dd>

      <dt><span id="load"> </span>int (*load)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</dt>
       <dd><p><code>load</code> is called when the NIF library is loaded
        and there is no previously loaded library for this module.</p>
        <p><code>*priv_data</code> can be set to point to some private data
           that the library needs in able to keep a state between NIF 
           calls. <code>enif_priv_data()</code> will return this pointer.
           <code>*priv_data</code> will be initialized to NULL when <code>load</code> is
           called.</p> 
        <p><code>load_info</code> is the second argument to <a href="erlang.html#load_nif-2" class="seealso">erlang:load_nif/2</a>.</p>
        <p>The library will fail to load if <code>load</code> returns
           anything other than 0. <code>load</code> can be NULL in case no
           initialization is needed.</p> 
       </dd>

      <dt><span id="reload"> </span>int (*reload)(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)</dt>
       <dd><p><code>reload</code> is called when the NIF library is loaded
        and there is already a previously loaded library for this
        module code.</p>
        <p>Works the same as <code>load</code>. The only difference is that
        <code>*priv_data</code> already contains the value set by the
        previous call to <code>load</code> or <code>reload</code>.</p>
        <p>The library will fail to load if <code>reload</code> returns
           anything other than 0 or if <code>reload</code> is NULL.</p> 
      </dd>

      <dt><span id="upgrade"> </span>int (*upgrade)(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info)</dt>
       <dd><p><code>upgrade</code> is called when the NIF library is loaded
        and there is no previously loaded library for this module
        code, BUT there is old code of this module with a loaded NIF library.</p>
        <p>Works the same as <code>load</code>. The only difference is that
        <code>*old_priv_data</code> already contains the value set by the
         last call to <code>load</code> or <code>reload</code> for the old module
         code. <code>*priv_data</code> will be initialized to NULL when <code>upgrade</code>
         is called. It is allowed to write to both *priv_data and *old_priv_data.</p> 
        <p>The library will fail to load if <code>upgrade</code> returns
           anything other than 0 or if <code>upgrade</code> is NULL.</p>
      </dd>

      <dt><span id="unload"> </span>void (*unload)(ErlNifEnv* env, void* priv_data)</dt>
       <dd><p><code>unload</code> is called when the module code that
       the NIF library belongs to is purged as old. New code
       of the same module may or may not exist. Note that <code>unload</code> is not
       called for a replaced library as a consequence of <code>reload</code>.</p>
      </dd>

    </dl>
  </div>

  <div class="section">
    <h4>DATA TYPES</h4>

    <dl>
      <dt><span id="ERL_NIF_TERM"> </span>ERL_NIF_TERM</dt>
       <dd>
        <p>Variables of type <code>ERL_NIF_TERM</code> can refer to any Erlang term.
        This is an opaque type and values of it can only by used either as
        arguments to API functions or as return values from NIFs. A variable of
        type <code>ERL_NIF_TERM</code> is only valid until the NIF call, where it was
        obtained, returns.</p>
      </dd>
     <dt><span id="ErlNifEnv"> </span>ErlNifEnv</dt>
      <dd>
        <p><code>ErlNifEnv</code> contains information about the context in
          which a NIF call is made. This pointer should not be
          dereferenced in any way, but only passed on to API
          functions. An <code>ErlNifEnv</code> pointer is only valid until
          the function, where is what supplied as argument,
          returns. There is thus useless and dangerous to store <code>ErlNifEnv</code>
          pointers in between NIF calls.</p>
      </dd>
    <dt><span id="ErlNifFunc"> </span>ErlNifFunc</dt>
     <dd>
      <p  />
      <pre class="sh_erlang">
typedef struct {
    const char* <em>name</em>;
    unsigned <em>arity</em>;
    ERL_NIF_TERM (*<em>fptr</em>)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
} ErlNifFunc;
</pre>
        <p>Describes a NIF by its name, arity and implementation.
        <code>fptr</code> is a pointer to the function that implements the
        NIF. The argument <code>argv</code> of a NIF will contain the
        function arguments passed to the NIF and <code>argc</code> is the
        length of the array, i.e. the function arity. <code>argv[N-1]</code>
        will thus denote the Nth argument to the NIF. Note that the
        <code>argc</code> argument allows for the same C function to
        implement several Erlang functions with different arity (but
        same name probably).</p>
      </dd>
    <dt><span id="ErlNifBinary"> </span>ErlNifBinary</dt>
     <dd>
      <p  />
      <pre class="sh_erlang">
typedef struct {
    unsigned <em>size</em>;
    unsigned char* <em>data</em>;
} ErlNifBinary;
</pre>
        <p><code>ErlNifBinary</code> contains transient information about an
          inspected binary term. <code>data</code> is a pointer to a buffer
          of <code>size</code> bytes with the raw content of the binary.</p>
      </dd>
      <dt><span id="ErlNifResourceType"> </span>ErlNifResourceType</dt>
       <dd>
          <p>Each instance of <code>ErlNifResourceType</code> represent a class of
          memory managed resource objects that can be garbage collected.
          Each resource type has a unique name and a destructor function that
          is called when objects of its type are released.</p>
        </dd>
        <dt><span id="ErlNifResourceDtor"> </span>ErlNifResourceDtor</dt>
         <dd>
           <p  />
           <pre class="sh_erlang">
typedef void ErlNifResourceDtor(ErlNifEnv* env, void* obj);
</pre>
            <p>The function prototype of a resource destructor function.
            A destructor function is not allowed to call any term-making functions.</p>
          </dd>
          <dt><span id="ErlNifCharEncoding"> </span>ErlNifCharEncoding</dt>
           <dd>
             <p  />
             <pre class="sh_erlang">
typedef enum {
    ERL_NIF_LATIN1
}ErlNifCharEncoding;
</pre>
              <p>The character encoding used in strings. The only supported
              encoding is currently <code>ERL_NIF_LATIN1</code> for iso-latin-1
              (8-bit ascii).</p>
            </dd>
            <dt><span id="ErlNifSysInfo"> </span>ErlNifSysInfo</dt>
             <dd>
                <p>Used by <a href="#enif_system_info" class="seealso">enif_system_info</a>
                to return information about the runtime system. Contains currently
                the exact same content as <a href="erl_driver.html#ErlDrvSysInfo" class="seealso">ErlDrvSysInfo</a>.</p>
              </dd>

    </dl>
  </div>

  <div class="functions"><h4>Functions</h4><hr  />
    <div class="function">
      
      <div class="description"><p>Allocate memory of <code>size</code> bytes. Return NULL if allocation failed.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Allocate a new binary of size of <code>size</code>
      bytes. Initialize the structure pointed to by <code>bin</code> to
      refer to the allocated binary. The binary must either be released by 
      <a href="#enif_release_binary" class="seealso">enif_release_binary()</a> 
      or ownership transferred to an Erlang term with 
      <a href="#enif_make_binary" class="seealso">enif_make_binary()</a>. 
      An allocated (and owned) <code>ErlNifBinary</code> can be kept between NIF
      calls.</p>
        <p>Return false if allocation failed.</p>
      </div>
    </div>
    <div class="function">
      
      <div class="description"><p>Allocate a memory managed resource object of type <code>type</code> and size <code>size</code> bytes.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return an integer less than, equal to, or greater than
      zero if <code>lhs</code> is found, respectively, to be less than,
      equal, or greater than <code>rhs</code>. Corresponds to the Erlang
      operators <code>==</code>, <code>/=</code>, <code>=&lt;</code>, <code>&lt;</code>,
      <code>&gt;=</code> and <code>&gt;</code> (but <em>not</em> <code>=:=</code> or <code>=/=</code>).</p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_cond_broadcast" class="seealso">erl_drv_cond_broadcast()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_cond_create" class="seealso">erl_drv_cond_create()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_cond_destroy" class="seealso">erl_drv_cond_destroy()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_cond_signal" class="seealso">erl_drv_cond_signal()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_cond_wait" class="seealso">erl_drv_cond_wait()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_equal_tids" class="seealso">erl_drv_equal_tids()</a>.
          </p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Free memory allocated by <code>enif_alloc</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Write a null-terminated string, in the buffer pointed to by
              <code>buf</code> of size <code>size</code>, consisting of the string 
              representation of the atom <code>term</code>. Return the number of bytes
              written (including terminating null character) or 0 if
              <code>term</code> is not an atom with maximum length of 
              <code>size-1</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*dp</code> to the floating point value of
      <code>term</code> or return false if <code>term</code> is not a float.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*ip</code> to the integer value of
      <code>term</code> or return false if <code>term</code> is not an integer or is
      outside the bounds of type <code>int</code></p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*head</code> and <code>*tail</code> from
      <code>list</code> or return false if <code>list</code> is not a non-empty
      list.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*ip</code> to the long integer value of
      <code>term</code> or return false if <code>term</code> is not an integer or is
      outside the bounds of type <code>long int</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*objp</code> to point to the resource object referred to by <code>term</code>.
      The pointer is valid until the calling NIF returns and should not be released.</p>
      <p>Return false if <code>term</code> is not a handle to a resource object
      of type <code>type</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Write a null-terminated string, in the buffer pointed to by
              <code>buf</code> with size <code>size</code>, consisting of the characters
              in the string <code>list</code>. The characters are written using encoding
              <a href="#ErlNifCharEncoding" class="seealso">encode</a>.
              Return the number of bytes written (including terminating null
              character), or <code>-size</code> if the string was truncated due to
              buffer space, or 0 if <code>list</code> is not a string that can be
              encoded with <code>encode</code> or if <code>size</code> was less than 1.              
              The written string is always null-terminated unless buffer
              <code>size</code> is less than 1.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>If <code>term</code> is a tuple, set <code>*array</code> to point
      to an array containing the elements of the tuple and set
      <code>*arity</code> to the number of elements. Note that the array
      is read-only and <code>(*array)[N-1]</code> will be the Nth element of
      the tuple. <code>*array</code> is undefined if the arity of the tuple
      is zero.</p><p>Return false if <code>term</code> is not a
      tuple.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Set <code>*ip</code> to the unsigned integer value of
      <code>term</code> or return false if <code>term</code> is not an unsigned integer or is
      outside the bounds of type <code>unsigned int</code></p></div>
    </div>

    <div class="function">
      
      <div class="description"><p>Set <code>*ip</code> to the unsigned long integer value of
      <code>term</code> or return false if <code>term</code> is not an unsigned integer or is
      outside the bounds of type <code>unsigned long</code></p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Initialize the structure pointed to by <code>bin</code> with 
              information about the binary term
      <code>bin_term</code>. Return false if <code>bin_term</code> is not a binary.</p></div> 
    </div>
    <div class="function">
      
      <div class="description"><p>Initialize the structure pointed to by <code>bin</code> with one
      continuous buffer with the same byte content as <code>iolist</code>. As with 
      inspect_binary, the data pointed to by <code>bin</code> is transient and does 
      not need to be released. Return false if <code>iolist</code> is not an
      iolist.</p>
      </div> 
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is an atom.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is a binary</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is an empty list.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is a fun.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if the two terms are identical. Corresponds to the
      Erlang operators <code>=:=</code> and
      <code>=/=</code>.</p></div> 
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is a pid.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is a port.</p></div>
    </div>

    <div class="function">
      
      <div class="description"><p>Return true if <code>term</code> is a reference.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an atom term from the C-string <code>name</code>. Unlike other terms, atom
      terms may be saved and used between NIF calls.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Make a badarg exception to be returned from a NIF.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Make a binary term from <code>bin</code>. Any ownership of 
              the binary data will be transferred to the created term and
              <code>bin</code> should be considered read-only for the rest of the NIF
              call and then as released.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an floating-point term from a <code>double</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Try to create the term of an already existing atom from
      the C-string <code>name</code>. If the atom already exist store the
      term in <code>*atom</code> and return true, otherwise return
      false.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an integer term.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an ordinary list term of length <code>cnt</code>. Expects
      <code>cnt</code> number of arguments (after <code>cnt</code>) of type ERL_NIF_TERM as the
      elements of the list. An empty list is returned if <code>cnt</code> is 0.</p></div>
    </div>
    <div class="function">
    
    
    
    
    
    
    
    
      
      <div class="description"><p>Create an ordinary list term with length indicated by the
      function name. Prefer these functions (macros) over the variadic
      <code>enif_make_list</code>  to get compile time error if the number of
      arguments does not match.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create a list cell <code>[head | tail]</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an ordinary list containing the elements of array <code>arr</code>
      of length <code>cnt</code>. An empty list is returned if <code>cnt</code> is 0.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an integer term from a <code>long int</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create a reference like <a href="erlang.html#make_ref-0" class="seealso">erlang:make_ref/0</a>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an opaque handle to a memory managed resource object
      obtained by <a href="#enif_alloc_resource" class="seealso">enif_alloc_resource</a>.
      No ownership transfer is done, the resource object still needs to be released by
      <a href="#enif_release_resource" class="seealso">enif_release_resource</a>.</p>
      <p>Note that the only defined behaviour when using of a resource term in
      an Erlang program is to store it and send it between processes on the
      same node. Other operations such as matching or <code>term_to_binary</code>
      will have unpredictable (but harmless) results.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create a list containing the characters of the
      null-terminated string <code>string</code> with encoding <a href="#ErlNifCharEncoding" class="seealso">encoding</a>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Make a subbinary of binary <code>bin_term</code>, starting at 
              zero-based position <code>pos</code> with a length of <code>size</code> bytes. 
              <code>bin_term</code> must be a binary or bitstring and
              <code>pos+size</code> must be less or equal to the number of whole
              bytes in <code>bin_term</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create a tuple term of arity <code>cnt</code>. Expects
      <code>cnt</code> number of arguments (after <code>cnt</code>) of type ERL_NIF_TERM as the
      elements of the tuple.</p></div>
    </div>
    <div class="function">
    
    
    
    
    
    
    
    
      
      <div class="description"><p>Create a tuple term with length indicated by the
      function name. Prefer these functions (macros) over the variadic
      <code>enif_make_tuple</code>  to get compile time error if the number of
      arguments does not match.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create a tuple containing the elements of array <code>arr</code>
      of length <code>cnt</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an integer term from an <code>unsigned int</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create an integer term from an <code>unsigned long int</code>.</p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_mutex_create" class="seealso">erl_drv_mutex_create()</a>.
    </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_mutex_destroy" class="seealso">erl_drv_mutex_destroy()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_mutex_lock" class="seealso">erl_drv_mutex_lock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_mutex_trylock" class="seealso">erl_drv_mutex_trylock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_mutex_unlock" class="seealso">erl_drv_mutex_unlock()</a>.
          </p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Create or takeover a resource type identified by the string
      <code>name</code> and give it the destructor function pointed to by <a href="#ErlNifResourceDtor" class="seealso">dtor</a>.
      Argument <code>flags</code> can have the following values:</p>
      <dl>
        <dt><code>ERL_NIF_RT_CREATE</code></dt>
              <dd>Create a new resource type that does not already exist.</dd>
        <dt><code>ERL_NIF_RT_TAKEOVER</code></dt>
              <dd>Open an existing resource type and take over ownership of all its instances.
               The supplied destructor <code>dtor</code> will be called both for existing instances
               as well as new instances not yet created by the calling NIF library.</dd>            
      </dl>
      <p>The two flag values can be combined with bitwise-or. To avoid unintentionally
      name clashes a good practice is to include the module name as part of the
      type <code>name</code>. The <code>dtor</code> may  be <code>NULL</code> in case no destructor
      is needed.</p>
      <p>On success, return a pointer to the resource type and <code>*tried</code>
      will be set to either <code>ERL_NIF_RT_CREATE</code> or
      <code>ERL_NIF_RT_TAKEOVER</code> to indicate what was actually done.
       On failure, return <code>NULL</code> and set <code>*tried</code> to <code>flags</code>.
       It is allowed to set <code>tried</code> to <code>NULL</code>.</p>
       <p>Note that <code>enif_open_resource_type</code> is only allowed to be called in the three callbacks
       <a href="#load" class="seealso">load</a>, <a href="#reload" class="seealso">reload</a>
       and <a href="#upgrade" class="seealso">upgrade</a>.</p>
      </div>
    </div>
    <div class="function">
      
      <div class="description"><p>Return the pointer to the private data that was set by <code>load</code>,
      <code>reload</code> or <code>upgrade</code>.</p>
      <p>Was previously named <code>enif_get_data</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Change the size of a binary <code>bin</code>. The source binary
      may be read-only, in which case it will be left untouched and
      a mutable copy is allocated and assigned to <code>*bin</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Release a binary obtained 
              from <code>enif_alloc_binary</code>.</p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Release a resource objects obtained from <code>enif_alloc_resource</code>.
      The object may still be alive if it is referred to by Erlang terms. Each call to
      <code>enif_release_resource</code> must correspond to a previous call to <code>enif_alloc_resource</code>.
      References made by <code>enif_make_resource</code> can only be released by the garbage collector.</p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_create" class="seealso">erl_drv_rwlock_create()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_destroy" class="seealso">erl_drv_rwlock_destroy()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rlock" class="seealso">erl_drv_rwlock_rlock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_runlock" class="seealso">erl_drv_rwlock_runlock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rwlock" class="seealso">erl_drv_rwlock_rwlock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_rwunlock" class="seealso">erl_drv_rwlock_rwunlock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_tryrlock" class="seealso">erl_drv_rwlock_tryrlock()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_rwlock_tryrwlock" class="seealso">erl_drv_rwlock_tryrwlock()</a>.
          </p></div>
    </div>
    <div class="function">
      
      <div class="description"><p>Get the byte size of a resource object <code>obj</code> obtained by
      <code>enif_alloc_resource</code>.</p></div>
    </div>
    <div class="function">
      
      
      <div class="description"><p>Same as <a href="erl_driver.html#driver_system_info" class="seealso">driver_system_info()</a>.
            </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_create" class="seealso">erl_drv_thread_create()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_exit" class="seealso">erl_drv_thread_exit()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_join" class="seealso">erl_drv_thread_join ()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_opts_create" class="seealso">erl_drv_thread_opts_create()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_opts_destroy" class="seealso">erl_drv_thread_opts_destroy()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_thread_self" class="seealso">erl_drv_thread_self()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_tsd_key_create" class="seealso">erl_drv_tsd_key_create()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_tsd_key_destroy" class="seealso">erl_drv_tsd_key_destroy()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_tsd_get" class="seealso">erl_drv_tsd_get()</a>.
          </p></div>
    </div>
    <div class="function">
    
    <div class="description"><p>Same as <a href="erl_driver.html#erl_drv_tsd_set" class="seealso">erl_drv_tsd_set()</a>.
          </p></div>
    </div>
  </div>
  <div class="section">
    <h4>SEE ALSO</h4>
    <p><a href="erlang.html#load_nif-2" class="seealso">load_nif(3)</a></p>
  </div>

      <ul id="funs" />
    </div>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59760-14']);
      _gaq.push(['_trackPageview']);
      
      (function() {
        var ga = document.createElement('script');
        ga.src = ('https:' == document.location.protocol ?
          'https://ssl' : 'http://www') +
          '.google-analytics.com/ga.js';
        ga.setAttribute('async', 'true');
        document.documentElement.firstChild.appendChild(ga);
      })();
    </script>
  </body>
</html>

