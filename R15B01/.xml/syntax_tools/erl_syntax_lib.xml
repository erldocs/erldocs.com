<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>erl_syntax_lib</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>erl_syntax_lib.xml</file></header>
<module>erl_syntax_lib</module>
<modulesummary>Support library for abstract Erlang syntax trees.</modulesummary>
<description>
<p>Support library for abstract Erlang syntax trees.</p>
 
  <p>This module contains utility functions for working with the
  abstract data type defined in the module <seealso marker="erl_syntax">erl_syntax</seealso>.
 </p></description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><c>info_pair() = {key(), term()}</c></tag>
<item><marker id="type-info_pair"/> </item>
<tag><c>key() = attributes | errors | exports | functions | imports | module | records | rules | warnings</c></tag>
<item><marker id="type-key"/> </item>
<tag><c>ordset(T) = ordset(T) (see module //stdlib/ordsets)</c></tag>
<item><marker id="type-ordset"/> </item>
<tag><c>syntaxTree() = syntaxTree() (see module erl_syntax)</c></tag>
<item><marker id="type-syntaxTree"/>
<p>An abstract syntax
  tree. See the <seealso marker="erl_syntax">erl_syntax</seealso> module for details.</p>
</item>
</taglist></section>
<funcs>
<func>
<name>map(F::Function, Tree::syntaxTree()) -&gt; syntaxTree()</name>
<fsummary>Applies a function to each node of a syntax tree.</fsummary>
<type>
<v>Function = (syntaxTree()) -&gt; syntaxTree()</v></type>
<desc><marker id="map-2"/>

<p>Applies a function to each node of a syntax tree. The result of
  each application replaces the corresponding original node. The order
  of traversal is bottom-up.
 </p>
<p><em>See also:</em> <seealso marker="#map_subtrees-2">map_subtrees/2</seealso>.</p>
</desc></func>
<func>
<name>map_subtrees(F::Function, Tree::syntaxTree()) -&gt; syntaxTree()</name>
<fsummary>Applies a function to each immediate subtree of a syntax tree.</fsummary>
<type>
<v>Function = (Tree) -&gt; Tree1</v></type>
<desc><marker id="map_subtrees-2"/>

<p>Applies a function to each immediate subtree of a syntax tree.
  The result of each application replaces the corresponding original
  node.
 </p>
<p><em>See also:</em> <seealso marker="#map-2">map/2</seealso>.</p>
</desc></func>
<func>
<name>fold(F::Function, Start::term(), Tree::syntaxTree()) -&gt; term()</name>
<fsummary>Folds a function over all nodes of a syntax tree.</fsummary>
<type>
<v>Function = (syntaxTree(), term()) -&gt; term()</v></type>
<desc><marker id="fold-3"/>

<p>Folds a function over all nodes of a syntax tree. The result is
  the value of <c>Function(X1, Function(X2, ... Function(Xn, Start)
  ... ))</c>, where <c>[X1, X2, ..., Xn]</c> are the nodes of
  <c>Tree</c> in a post-order traversal.
 </p>
<p><em>See also:</em> <seealso marker="#fold_subtrees-3">fold_subtrees/3</seealso>, <seealso marker="#foldl_listlist-3">foldl_listlist/3</seealso>.</p>
</desc></func>
<func>
<name>fold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -&gt; term()</name>
<fsummary>Folds a function over the immediate subtrees of a syntax tree.</fsummary>
<type>
<v>Function = (syntaxTree(), term()) -&gt; term()</v></type>
<desc><marker id="fold_subtrees-3"/>

<p>Folds a function over the immediate subtrees of a syntax tree.
  This is similar to <c>fold/3</c>, but only on the immediate
  subtrees of <c>Tree</c>, in left-to-right order; it does not
  include the root node of <c>Tree</c>.
 </p>
<p><em>See also:</em> <seealso marker="#fold-3">fold/3</seealso>.</p>
</desc></func>
<func>
<name>foldl_listlist(F::Function, Start::term(), Ls::[[term()]]) -&gt; term()</name>
<fsummary>Like lists:foldl/3, but over a list of lists.</fsummary>
<type>
<v>Function = (term(), term()) -&gt; term()</v></type>
<desc><marker id="foldl_listlist-3"/>

<p>Like <c>lists:foldl/3</c>, but over a list of lists.
 </p>
<p><em>See also:</em> <seealso marker="stdlib:lists#foldl/3">lists:foldl/3</seealso>, <seealso marker="#fold-3">fold/3</seealso>.</p>
</desc></func>
<func>
<name>mapfold(F::Function, Start::term(), Tree::syntaxTree()) -&gt; {syntaxTree(), term()}</name>
<fsummary>Combines map and fold in a single operation.</fsummary>
<type>
<v>Function = (syntaxTree(), term()) -&gt; {syntaxTree(), term()}</v></type>
<desc><marker id="mapfold-3"/>

<p>Combines map and fold in a single operation. This is similar to
  <c>map/2</c>, but also propagates an extra value from each
  application of the <c>Function</c> to the next, while doing a
  post-order traversal of the tree like <c>fold/3</c>. The value
  <c>Start</c> is passed to the first function application, and
  the final result is the result of the last application.
 </p>
<p><em>See also:</em> <seealso marker="#fold-3">fold/3</seealso>, <seealso marker="#map-2">map/2</seealso>.</p>
</desc></func>
<func>
<name>mapfold_subtrees(F::Function, Start::term(), Tree::syntaxTree()) -&gt; {syntaxTree(), term()}</name>
<fsummary>Does a mapfold operation over the immediate subtrees of a syntax
  tree.</fsummary>
<type>
<v>Function = (syntaxTree(), term()) -&gt; {syntaxTree(), term()}</v></type>
<desc><marker id="mapfold_subtrees-3"/>

<p>Does a mapfold operation over the immediate subtrees of a syntax
  tree. This is similar to <c>mapfold/3</c>, but only on the
  immediate subtrees of <c>Tree</c>, in left-to-right order; it
  does not include the root node of <c>Tree</c>.
 </p>
<p><em>See also:</em> <seealso marker="#mapfold-3">mapfold/3</seealso>.</p>
</desc></func>
<func>
<name>mapfoldl_listlist(F::Function, S::State, Ls::[[term()]]) -&gt; {[[term()]], term()}</name>
<fsummary>Like lists:mapfoldl/3, but over a list of lists.</fsummary>
<type>
<v>Function = (term(), term()) -&gt; {term(), term()}</v></type>
<desc><marker id="mapfoldl_listlist-3"/>

<p>Like <c>lists:mapfoldl/3</c>, but over a list of lists.
  The list of lists in the result has the same structure as the given
  list of lists.</p>
</desc></func>
<func>
<name>variables(Tree::syntaxTree()) -&gt; set(atom())</name>
<fsummary>Returns the names of variables occurring in a syntax tree, The
  result is a set of variable names represented by atoms.</fsummary>
<type>
<v>set(T) (see module //stdlib/sets)</v></type>
<desc><marker id="variables-1"/>

<p>Returns the names of variables occurring in a syntax tree, The
  result is a set of variable names represented by atoms. Macro names
  are not included.
 </p>
<p><em>See also:</em> <seealso marker="stdlib:sets">sets(3)</seealso>.</p>
</desc></func>
<func>
<name>new_variable_name(Used::set(atom())) -&gt; atom()</name>
<fsummary>Returns an atom which is not already in the set Used.</fsummary>

<desc><marker id="new_variable_name-1"/>

<p>Returns an atom which is not already in the set <c>Used</c>. This is
  equivalent to <c>new_variable_name(Function, Used)</c>, where <c>Function</c>
  maps a given integer <c>N</c> to the atom whose name consists of "<c>V</c>"
  followed by the numeral for <c>N</c>.
 </p>
<p><em>See also:</em> <seealso marker="#new_variable_name-2">new_variable_name/2</seealso>.</p>
</desc></func>
<func>
<name>new_variable_name(F::Function, Used::set(atom())) -&gt; atom()</name>
<fsummary>Returns a user-named atom which is not already in the set
  Used.</fsummary>
<type>
<v>Function = (integer()) -&gt; atom()</v></type>
<desc><marker id="new_variable_name-2"/>

<p>Returns a user-named atom which is not already in the set
  <c>Used</c>. The atom is generated by applying the given
  <c>Function</c> to a generated integer. Integers are generated  
using an algorithm which tries to keep the names randomly distributed  
within a reasonably small range relative to the number of elements in  
the set.</p>
 
  <p>This function uses the module <c>random</c> to generate new
  keys. The seed it uses may be initialized by calling
  <c>random:seed/0</c> or <c>random:seed/3</c> before this
  function is first called.
 </p>
<p><em>See also:</em> <seealso marker="stdlib:random">random(3)</seealso>, <seealso marker="stdlib:sets">sets(3)</seealso>, <seealso marker="#new_variable_name-1">new_variable_name/1</seealso>.</p>
</desc></func>
<func>
<name>new_variable_names(N::integer(), Used::set(atom())) -&gt; [atom()]</name>
<fsummary>Like new_variable_name/1, but generates a list of
  N new names.</fsummary>

<desc><marker id="new_variable_names-2"/>

<p>Like <c>new_variable_name/1</c>, but generates a list of
  <c>N</c> new names.
 </p>
<p><em>See also:</em> <seealso marker="#new_variable_name-1">new_variable_name/1</seealso>.</p>
</desc></func>
<func>
<name>new_variable_names(N::integer(), F::Function, Used::set(atom())) -&gt; [atom()]</name>
<fsummary>Like new_variable_name/2, but generates a list of
  N new names.</fsummary>
<type>
<v>Function = (integer()) -&gt; atom()</v></type>
<desc><marker id="new_variable_names-3"/>

<p>Like <c>new_variable_name/2</c>, but generates a list of
  <c>N</c> new names.
 </p>
<p><em>See also:</em> <seealso marker="#new_variable_name-2">new_variable_name/2</seealso>.</p>
</desc></func>
<func>
<name>annotate_bindings(Tree::syntaxTree(), Bindings::ordset(atom())) -&gt; syntaxTree()</name>
<fsummary>Adds or updates annotations on nodes in a syntax tree.</fsummary>

<desc><marker id="annotate_bindings-2"/>

<p>Adds or updates annotations on nodes in a syntax tree.
  <c>Bindings</c> specifies the set of bound variables in the
  environment of the top level node. The following annotations are
  affected:
  </p><list>
      <item><p><c>{env, Vars}</c>, representing the input environment
      of the subtree.</p></item>
 
      <item><p><c>{bound, Vars}</c>, representing the variables that
      are bound in the subtree.</p></item>
 
      <item><p><c>{free, Vars}</c>, representing the free variables in
      the subtree.</p></item>
  </list><p>
  <c>Bindings</c> and <c>Vars</c> are ordered-set lists
  (cf. module <c>ordsets</c>) of atoms representing variable
  names.
 </p>
<p><em>See also:</em> <seealso marker="stdlib:ordsets">ordsets(3)</seealso>, <seealso marker="#annotate_bindings-1">annotate_bindings/1</seealso>.</p>
</desc></func>
<func>
<name>annotate_bindings(Tree::syntaxTree()) -&gt; syntaxTree()</name>
<fsummary>Adds or updates annotations on nodes in a syntax tree.</fsummary>

<desc><marker id="annotate_bindings-1"/>

<p>Adds or updates annotations on nodes in a syntax tree.
  Equivalent to <c>annotate_bindings(Tree, Bindings)</c> where
  the top-level environment <c>Bindings</c> is taken from the
  annotation <c>{env, Bindings}</c> on the root node of
  <c>Tree</c>. An exception is thrown if no such annotation
  should exist.
 </p>
<p><em>See also:</em> <seealso marker="#annotate_bindings-2">annotate_bindings/2</seealso>.</p>
</desc></func>
<func>
<name>is_fail_expr(Tree::syntaxTree()) -&gt; boolean()</name>
<fsummary>Returns true if Tree represents an
  expression which never terminates normally.</fsummary>

<desc><marker id="is_fail_expr-1"/>

<p>Returns <c>true</c> if <c>Tree</c> represents an
  expression which never terminates normally. Note that the reverse
  does not apply. Currently, the detected cases are calls to
  <c>exit/1</c>, <c>throw/1</c>,
  <c>erlang:error/1</c> and <c>erlang:error/2</c>.
 </p>
<p><em>See also:</em> <seealso marker="erts:erlang#error/1">erlang:error/1</seealso>, <seealso marker="erts:erlang#error/2">erlang:error/2</seealso>, <seealso marker="erts:erlang#exit/1">erlang:exit/1</seealso>, <seealso marker="erts:erlang#throw/1">erlang:throw/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_forms(Forms) -&gt; [{Key, term()}]</name>
<fsummary>Analyzes a sequence of "program forms".</fsummary>
<type>
<v>Forms = syntaxTree() | [syntaxTree()]</v><v>Key = attributes | errors | exports | functions | imports | module | records | rules | warnings</v></type>
<desc><marker id="analyze_forms-1"/>

<p>Analyzes a sequence of "program forms". The given
  <c>Forms</c> may be a single syntax tree of type
  <c>form_list</c>, or a list of "program form" syntax trees. The
  returned value is a list of pairs <c>{Key, Info}</c>, where
  each value of <c>Key</c> occurs at most once in the list; the  
absence of a particular key indicates that there is no well-defined  
value for that key.</p>
 
  <p>Each entry in the resulting list contains the following
  corresponding information about the program forms:
  </p><taglist>
      <tag><c>{attributes, Attributes}</c></tag>
        <item><list>
  	   <item><p><c>Attributes = [{atom(), term()}]</c></p></item>
        </list><p>
  	 <c>Attributes</c> is a list of pairs representing the
  	 names and corresponding values of all so-called "wild"
  	 attributes (as e.g. "<c>-compile(...)</c>") occurring in
  	 <c>Forms</c> (cf. <c>analyze_wild_attribute/1</c>).
  	 We do not guarantee that each name occurs at most once in the
  	 list. The order of listing is not defined.</p></item>
 
      <tag><c>{errors, Errors}</c></tag>
        <item><list>
  	   <item><p><c>Errors = [term()]</c></p></item>
        </list><p>
  	 <c>Errors</c> is the list of error descriptors of all
  	 <c>error_marker</c> nodes that occur in
  	 <c>Forms</c>. The order of listing is not defined.</p></item>
 
      <tag><c>{exports, Exports}</c></tag>
        <item><list>
  	    <item><p><c>Exports = [FunctionName]</c></p></item>
  	    <item><p><c>FunctionName = atom()
                     | {atom(), integer()}
  		      | {ModuleName, FunctionName}</c></p></item>
  	    <item><p><c>ModuleName = atom()</c></p></item>
        </list><p>
  	 <c>Exports</c> is a list of representations of those
  	 function names that are listed by export declaration attributes
  	 in <c>Forms</c> (cf.
  	 <c>analyze_export_attribute/1</c>). We do not guarantee
  	 that each name occurs at most once in the list. The order of
  	 listing is not defined.</p></item>
 
      <tag><c>{functions, Functions}</c></tag>
        <item><list>
  	    <item><p><c>Functions = [{atom(), integer()}]</c></p></item>
        </list><p>
  	 <c>Functions</c> is a list of the names of the functions
  	 that are defined in <c>Forms</c> (cf.
  	 <c>analyze_function/1</c>). We do not guarantee that each
  	 name occurs at most once in the list. The order of listing is
  	 not defined.</p></item>
 
      <tag><c>{imports, Imports}</c></tag>
        <item><list>
  	    <item><p><c>Imports = [{Module, Names}]</c></p></item>
  	    <item><p><c>Module = atom()</c></p></item>
  	    <item><p><c>Names = [FunctionName]</c></p></item>
  	    <item><p><c>FunctionName = atom()
                     | {atom(), integer()}
  		      | {ModuleName, FunctionName}</c></p></item>
  	    <item><p><c>ModuleName = atom()</c></p></item>
        </list><p>
  	 <c>Imports</c> is a list of pairs representing those
  	 module names and corresponding function names that are listed
  	 by import declaration attributes in <c>Forms</c> (cf.
  	 <c>analyze_import_attribute/1</c>), where each
  	 <c>Module</c> occurs at most once in
  	 <c>Imports</c>. We do not guarantee that each name occurs
  	 at most once in the lists of function names. The order of
  	 listing is not defined.</p></item>
 
      <tag><c>{module, ModuleName}</c></tag>
        <item><list>
  	    <item><p><c>ModuleName = atom()</c></p></item>
        </list><p>
  	 <c>ModuleName</c> is the name declared by a module
  	 attribute in <c>Forms</c>. If no module name is defined
  	 in <c>Forms</c>, the result will contain no entry for the
  	 <c>module</c> key. If multiple module name declarations
  	 should occur, all but the first will be ignored.</p></item>
 
      <tag><c>{records, Records}</c></tag>
        <item><list>
  	    <item><p><c>Records = [{atom(), Fields}]</c></p></item>
  	    <item><p><c>Fields = [{atom(), Default}]</c></p></item>
  	    <item><p><c>Default = none | syntaxTree()</c></p></item>
        </list><p>
  	 <c>Records</c> is a list of pairs representing the names
  	 and corresponding field declarations of all record declaration
  	 attributes occurring in <c>Forms</c>. For fields declared
  	 without a default value, the corresponding value for
  	 <c>Default</c> is the atom <c>none</c> (cf.
  	 <c>analyze_record_attribute/1</c>). We do not guarantee
  	 that each record name occurs at most once in the list. The
  	 order of listing is not defined.</p></item>
 
      <tag><c>{rules, Rules}</c></tag>
        <item><list>
  	    <item><p><c>Rules = [{atom(), integer()}]</c></p></item>
        </list><p>
  	 <c>Rules</c> is a list of the names of the rules that are
  	 defined in <c>Forms</c> (cf.
  	 <c>analyze_rule/1</c>). We do not guarantee that each
  	 name occurs at most once in the list. The order of listing is
  	 not defined.</p></item>
 
      <tag><c>{warnings, Warnings}</c></tag>
        <item><list>
  	    <item><p><c>Warnings = [term()]</c></p></item>
        </list><p>
  	 <c>Warnings</c> is the list of error descriptors of all
  	 <c>warning_marker</c> nodes that occur in
  	 <c>Forms</c>. The order of listing is not defined.</p></item>
  </taglist>
 
  <p>The evaluation throws <c>syntax_error</c> if an ill-formed
  Erlang construct is encountered.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_export_attribute-1">analyze_export_attribute/1</seealso>, <seealso marker="#analyze_function-1">analyze_function/1</seealso>, <seealso marker="#analyze_import_attribute-1">analyze_import_attribute/1</seealso>, <seealso marker="#analyze_record_attribute-1">analyze_record_attribute/1</seealso>, <seealso marker="#analyze_rule-1">analyze_rule/1</seealso>, <seealso marker="#analyze_wild_attribute-1">analyze_wild_attribute/1</seealso>, <seealso marker="erl_syntax#error_marker_info-1">erl_syntax:error_marker_info/1</seealso>, <seealso marker="erl_syntax#warning_marker_info-1">erl_syntax:warning_marker_info/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_form(Node::syntaxTree()) -&gt; {atom(), term()} | atom()</name>
<fsummary>Analyzes a "source code form" node.</fsummary>

<desc><marker id="analyze_form-1"/>

<p>Analyzes a "source code form" node. If <c>Node</c> is a
  "form" type (cf. <c>erl_syntax:is_form/1</c>), the returned
  value is a tuple <c>{Type, Info}</c> where <c>Type</c> is
  the node type and <c>Info</c> depends on <c>Type</c>, as
  follows:
  </p><taglist>
    <tag><c>{attribute, Info}</c></tag>
 
       <item><p>where <c>Info = analyze_attribute(Node)</c>.</p></item>
 
    <tag><c>{error_marker, Info}</c></tag>
 
  	<item><p>where <c>Info =
  	erl_syntax:error_marker_info(Node)</c>.</p></item>
 
    <tag><c>{function, Info}</c></tag>
 
  	    <item><p>where <c>Info = analyze_function(Node)</c>.</p></item>
 
    <tag><c>{rule, Info}</c></tag>
 
  	    <item><p>where <c>Info = analyze_rule(Node)</c>.</p></item>
 
    <tag><c>{warning_marker, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    erl_syntax:warning_marker_info(Node)</c>.</p></item>
  </taglist><p>  
For other types of forms, only the node type is returned.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> is not well-formed.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>, <seealso marker="#analyze_function-1">analyze_function/1</seealso>, <seealso marker="#analyze_rule-1">analyze_rule/1</seealso>, <seealso marker="erl_syntax#error_marker_info-1">erl_syntax:error_marker_info/1</seealso>, <seealso marker="erl_syntax#is_form-1">erl_syntax:is_form/1</seealso>, <seealso marker="erl_syntax#warning_marker_info-1">erl_syntax:warning_marker_info/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_attribute(Node::syntaxTree()) -&gt; preprocessor | {atom(), atom()}</name>
<fsummary>Analyzes an attribute node.</fsummary>

<desc><marker id="analyze_attribute-1"/>

<p>Analyzes an attribute node. If <c>Node</c> represents a
  preprocessor directive, the atom <c>preprocessor</c> is
  returned. Otherwise, if <c>Node</c> represents a module
  attribute "<c>-&lt;em&gt;Name&lt;/em&gt;...</c>", a tuple <c>{Name,
  Info}</c> is returned, where <c>Info</c> depends on
  <c>Name</c>, as follows:
  </p><taglist>
      <tag><c>{module, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    analyze_module_attribute(Node)</c>.</p></item>
 
      <tag><c>{export, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    analyze_export_attribute(Node)</c>.</p></item>
 
      <tag><c>{import, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    analyze_import_attribute(Node)</c>.</p></item>
 
      <tag><c>{file, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    analyze_file_attribute(Node)</c>.</p></item>
 
      <tag><c>{record, Info}</c></tag>
 
  	    <item><p>where <c>Info =
  	    analyze_record_attribute(Node)</c>.</p></item>
 
      <tag><c>{Name, Info}</c></tag>
 
  	    <item><p>where <c>{Name, Info} =
  	    analyze_wild_attribute(Node)</c>.</p></item>
  </taglist><p>
  The evaluation throws <c>syntax_error</c> if <c>Node</c>
  does not represent a well-formed module attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_export_attribute-1">analyze_export_attribute/1</seealso>, <seealso marker="#analyze_file_attribute-1">analyze_file_attribute/1</seealso>, <seealso marker="#analyze_import_attribute-1">analyze_import_attribute/1</seealso>, <seealso marker="#analyze_module_attribute-1">analyze_module_attribute/1</seealso>, <seealso marker="#analyze_record_attribute-1">analyze_record_attribute/1</seealso>, <seealso marker="#analyze_wild_attribute-1">analyze_wild_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_module_attribute(Node::syntaxTree()) -&gt; Name::atom() | {Name::atom(), Variables::[atom()]}</name>
<fsummary>Returns the module name and possible parameters declared by a
  module attribute.</fsummary>

<desc><marker id="analyze_module_attribute-1"/>

<p>Returns the module name and possible parameters declared by a
  module attribute. If the attribute is a plain module declaration such
  as <c>-module(name)</c>, the result is the module name. If the attribute  
is a parameterized module declaration, the result is a tuple  
containing the module name and a list of the parameter variable  
names.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if <c>Node</c> does not represent a
  well-formed module attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_export_attribute(Node::syntaxTree()) -&gt; [FunctionName]</name>
<fsummary>Returns the list of function names declared by an export  
attribute.</fsummary>
<type>
<v>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</v><v>ModuleName = atom()</v></type>
<desc><marker id="analyze_export_attribute-1"/>

<p>Returns the list of function names declared by an export  
attribute. We do not guarantee that each name occurs at most once in  
the list. The order of listing is not defined.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if <c>Node</c> does not represent a
  well-formed export attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_function_name(Node::syntaxTree()) -&gt; FunctionName</name>
<fsummary>Returns the function name represented by a syntax tree.</fsummary>
<type>
<v>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</v><v>ModuleName = atom()</v></type>
<desc><marker id="analyze_function_name-1"/>

<p>Returns the function name represented by a syntax tree. If
  <c>Node</c> represents a function name, such as
  "<c>foo/1</c>" or "<c>bloggs:fred/2</c>", a uniform  
representation of that name is returned. Different nestings of arity  
and module name qualifiers in the syntax tree does not affect the  
result.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed function name.</p>
</desc></func>
<func>
<name>analyze_import_attribute(Node::syntaxTree()) -&gt; {atom(), [FunctionName]} | atom()</name>
<fsummary>Returns the module name and (if present) list of function names
  declared by an import attribute.</fsummary>
<type>
<v>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</v><v>ModuleName = atom()</v></type>
<desc><marker id="analyze_import_attribute-1"/>

<p>Returns the module name and (if present) list of function names
  declared by an import attribute. The returned value is an atom
  <c>Module</c> or a pair <c>{Module, Names}</c>, where
  <c>Names</c> is a list of function names declared as imported
  from the module named by <c>Module</c>. We do not guarantee
  that each name occurs at most once in <c>Names</c>. The order  
of listing is not defined.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if <c>Node</c> does not represent a
  well-formed import attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_wild_attribute(Node::syntaxTree()) -&gt; {atom(), term()}</name>
<fsummary>Returns the name and value of a "wild" attribute.</fsummary>

<desc><marker id="analyze_wild_attribute-1"/>

<p>Returns the name and value of a "wild" attribute. The result is
  the pair <c>{Name, Value}</c>, if <c>Node</c> represents "<c>-Name(Value)</c>".</p>
 
  <p>Note that no checking is done whether <c>Name</c> is a
  reserved attribute name such as <c>module</c> or
  <c>export</c>: it is assumed that the attribute is "wild".</p>
 
  <p>The evaluation throws <c>syntax_error</c> if <c>Node</c> does not represent a
  well-formed wild attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_record_attribute(Node::syntaxTree()) -&gt; {atom(), Fields}</name>
<fsummary>Returns the name and the list of fields of a record declaration
  attribute.</fsummary>
<type>
<v>Fields = [{atom(), none | syntaxTree()}]</v></type>
<desc><marker id="analyze_record_attribute-1"/>

<p>Returns the name and the list of fields of a record declaration
  attribute. The result is a pair <c>{Name, Fields}</c>, if
  <c>Node</c> represents "<c>-record(Name, {...}).</c>",
  where <c>Fields</c> is a list of pairs <c>{Label,
  Default}</c> for each field "<c>Label</c>" or "<c>Label =
  &lt;em&gt;Default&lt;/em&gt;</c>" in the declaration, listed in left-to-right
  order. If the field has no default-value declaration, the value for
  <c>Default</c> will be the atom <c>none</c>. We do not  
guarantee that each label occurs at most one in the list.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed record declaration
  attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>, <seealso marker="#analyze_record_field-1">analyze_record_field/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_record_expr(Node::syntaxTree()) -&gt; {atom(), Info} | atom()</name>
<fsummary>Returns the record name and field name/names of a record
  expression.</fsummary>
<type>
<v>Info = {atom(), [{atom(), Value}]} | {atom(), atom()} | atom()</v><v>Value = none | syntaxTree()</v></type>
<desc><marker id="analyze_record_expr-1"/>

<p>Returns the record name and field name/names of a record
  expression. If <c>Node</c> has type <c>record_expr</c>,
  <c>record_index_expr</c> or <c>record_access</c>, a pair
  <c>{Type, Info}</c> is returned, otherwise an atom
  <c>Type</c> is returned. <c>Type</c> is the node type of
  <c>Node</c>, and <c>Info</c> depends on
  <c>Type</c>, as follows:
  </p><taglist>
    <tag><c>record_expr</c>:</tag>
      <item><p><c>{atom(), [{atom(), Value}]}</c></p></item>
    <tag><c>record_access</c>:</tag>
      <item><p><c>{atom(), atom()} | atom()</c></p></item>
    <tag><c>record_index_expr</c>:</tag>
      <item><p><c>{atom(), atom()}</c></p></item>
  </taglist><p>
 
  </p><p>For a <c>record_expr</c> node, <c>Info</c> represents
  the record name and the list of descriptors for the involved fields,
  listed in the order they appear. (See
  <c>analyze_record_field/1</c> for details on the field
  descriptors). For a <c>record_access</c> node,
  <c>Info</c> represents the record name and the field name (or
  if the record name is not included, only the field name; this is
  allowed only in Mnemosyne-query syntax). For a
  <c>record_index_expr</c> node, <c>Info</c> represents the  
record name and the name field name.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> represents a record expression that is not
  well-formed.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_record_attribute-1">analyze_record_attribute/1</seealso>, <seealso marker="#analyze_record_field-1">analyze_record_field/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_record_field(Node::syntaxTree()) -&gt; {atom(), Value}</name>
<fsummary>Returns the label and value-expression of a record field
  specifier.</fsummary>
<type>
<v>Value = none | syntaxTree()</v></type>
<desc><marker id="analyze_record_field-1"/>

<p>Returns the label and value-expression of a record field
  specifier. The result is a pair <c>{Label, Value}</c>, if
  <c>Node</c> represents "<c>Label = &lt;em&gt;Value&lt;/em&gt;</c>" or
  "<c>Label</c>", where in the first case, <c>Value</c> is
  a syntax tree, and in the second case <c>Value</c> is
  <c>none</c>.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed record field
  specifier.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_record_attribute-1">analyze_record_attribute/1</seealso>, <seealso marker="#analyze_record_expr-1">analyze_record_expr/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_file_attribute(Node::syntaxTree()) -&gt; {string(), integer()}</name>
<fsummary>Returns the file name and line number of a file
  attribute.</fsummary>

<desc><marker id="analyze_file_attribute-1"/>

<p>Returns the file name and line number of a <c>file</c>
  attribute. The result is the pair <c>{File, Line}</c> if
  <c>Node</c> represents "<c>-file(File, Line).</c>".</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed <c>file</c>
  attribute.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_attribute-1">analyze_attribute/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_function(Node::syntaxTree()) -&gt; {atom(), integer()}</name>
<fsummary>Returns the name and arity of a function definition.</fsummary>

<desc><marker id="analyze_function-1"/>

<p>Returns the name and arity of a function definition. The result
  is a pair <c>{Name, A}</c> if <c>Node</c> represents a
  function definition "<c>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) -&gt;
  ...</c>".</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed function
  definition.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_rule-1">analyze_rule/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_rule(Node::syntaxTree()) -&gt; {atom(), integer()}</name>
<fsummary>Returns the name and arity of a Mnemosyne rule.</fsummary>

<desc><marker id="analyze_rule-1"/>

<p>Returns the name and arity of a Mnemosyne rule. The result is a
  pair <c>{Name, A}</c> if <c>Node</c> represents a rule
  "<c>Name(&lt;em&gt;P_1&lt;/em&gt;, ..., &lt;em&gt;P_A&lt;/em&gt;) :- ...</c>".</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed Mnemosyne
  rule.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_function-1">analyze_function/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_implicit_fun(Node::syntaxTree()) -&gt; FunctionName</name>
<fsummary>Returns the name of an implicit fun expression "fun
  &lt;em&gt;F&lt;/em&gt;".</fsummary>
<type>
<v>FunctionName = atom() | {atom(), integer()} | {ModuleName, FunctionName}</v><v>ModuleName = atom()</v></type>
<desc><marker id="analyze_implicit_fun-1"/>

<p>Returns the name of an implicit fun expression "<c>fun
  &lt;em&gt;F&lt;/em&gt;</c>". The result is a representation of the function
  name <c>F</c>. (Cf. <c>analyze_function_name/1</c>.)</p>
 
  <p>The evaluation throws <c>syntax_error</c> if
  <c>Node</c> does not represent a well-formed implicit fun.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_function_name-1">analyze_function_name/1</seealso>.</p>
</desc></func>
<func>
<name>analyze_application(Node::syntaxTree()) -&gt; FunctionName | Arity</name>
<fsummary>Returns the name of a called function.</fsummary>
<type>
<v>FunctionName = {atom(), Arity} | {ModuleName, FunctionName}</v><v>Arity = integer()</v><v>ModuleName = atom()</v></type>
<desc><marker id="analyze_application-1"/>

<p>Returns the name of a called function. The result is a
  representation of the name of the applied function <c>F/A</c>,
  if <c>Node</c> represents a function application
  "<c>&lt;em&gt;F&lt;/em&gt;(&lt;em&gt;X_1&lt;/em&gt;, ..., &lt;em&gt;X_A&lt;/em&gt;)</c>". If the
  function is not explicitly named (i.e., <c>F</c> is given by
  some expression), only the arity <c>A</c> is returned.</p>
 
  <p>The evaluation throws <c>syntax_error</c> if <c>Node</c> does not represent a
  well-formed application expression.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_function_name-1">analyze_function_name/1</seealso>.</p>
</desc></func>
<func>
<name>function_name_expansions(Names::[Name]) -&gt; [{ShortName, Name}]</name>
<fsummary>Creates a mapping from corresponding short names to full
  function names.</fsummary>
<type>
<v>Name = ShortName | {atom(), Name}</v><v>ShortName = atom() | {atom(), integer()}</v></type>
<desc><marker id="function_name_expansions-1"/>

<p>Creates a mapping from corresponding short names to full
  function names. Names are represented by nested tuples of atoms and
  integers (cf. <c>analyze_function_name/1</c>). The result is a
  list containing a pair <c>{ShortName, Name}</c> for each
  element <c>Name</c> in the given list, where the corresponding
  <c>ShortName</c> is the rightmost-innermost part of
  <c>Name</c>. The list thus represents a finite mapping from  
unqualified names to the corresponding qualified names.</p>
 
  <p>Note: the resulting list can contain more than one tuple
  <c>{ShortName, Name}</c> for the same <c>ShortName</c>,
  possibly with different values for <c>Name</c>, depending on
  the given list.
 </p>
<p><em>See also:</em> <seealso marker="#analyze_function_name-1">analyze_function_name/1</seealso>.</p>
</desc></func>
<func>
<name>strip_comments(Tree::syntaxTree()) -&gt; syntaxTree()</name>
<fsummary>Removes all comments from all nodes of a syntax tree.</fsummary>

<desc><marker id="strip_comments-1"/>

<p>Removes all comments from all nodes of a syntax tree. All other
  attributes (such as position information) remain unchanged.
  Standalone comments in form lists are removed; any other standalone
  comments are changed into null-comments (no text, no indentation).</p>
</desc></func>
<func>
<name>to_comment(Tree) -&gt; syntaxTree()</name>
<fsummary>Equivalent to to_comment(Tree, "% ").
</fsummary>

<desc><marker id="to_comment-1"/>
<p>Equivalent to <seealso marker="#to_comment-2">to_comment(Tree, "% ")</seealso>.</p>
</desc></func>
<func>
<name>to_comment(Tree::syntaxTree(), Prefix::string()) -&gt; syntaxTree()</name>
<fsummary>Equivalent to to_comment(Tree, Prefix, F) for a
  default formatting function F.</fsummary>

<desc><marker id="to_comment-2"/>

<p>Equivalent to <c>to_comment(Tree, Prefix, F)</c> for a
  default formatting function <c>F</c>. The default
  <c>F</c> simply calls <c>erl_prettypr:format/1</c>.
 </p>
<p><em>See also:</em> <seealso marker="#to_comment-3">to_comment/3</seealso>, <seealso marker="erl_prettypr#format-1">erl_prettypr:format/1</seealso>.</p>
</desc></func>
<func>
<name>to_comment(Tree::syntaxTree(), Prefix::string(), F::Printer) -&gt; syntaxTree()</name>
<fsummary>Transforms a syntax tree into an abstract comment.</fsummary>
<type>
<v>Printer = (syntaxTree()) -&gt; string()</v></type>
<desc><marker id="to_comment-3"/>

<p>Transforms a syntax tree into an abstract comment. The lines of
  the comment contain the text for <c>Node</c>, as produced by
  the given <c>Printer</c> function. Each line of the comment is
  prefixed by the string <c>Prefix</c> (this does not include the
  initial "<c>%</c>" character of the comment line).</p>
 
  <p>For example, the result of
  <c>to_comment(erl_syntax:abstract([a,b,c]))</c> represents
  </p><pre>
          %% [a,b,c]</pre><p>
  (cf. <c>to_comment/1</c>).</p>
 
  <p>Note: the text returned by the formatting function will be split
  automatically into separate comment lines at each line break. No
  extra work is needed.
 </p>
<p><em>See also:</em> <seealso marker="#to_comment-1">to_comment/1</seealso>, <seealso marker="#to_comment-2">to_comment/2</seealso>.</p>
</desc></func>
<func>
<name>limit(Tree, Depth) -&gt; syntaxTree()</name>
<fsummary>Equivalent to limit(Tree, Depth, Text) using the
  text "..." as default replacement.</fsummary>

<desc><marker id="limit-2"/>

<p>Equivalent to <c>limit(Tree, Depth, Text)</c> using the
  text <c>"..."</c> as default replacement.
 </p>
<p><em>See also:</em> <seealso marker="#limit-3">limit/3</seealso>, <seealso marker="erl_syntax#text-1">erl_syntax:text/1</seealso>.</p>
</desc></func>
<func>
<name>limit(Tree::syntaxTree(), Depth::integer(), Node::syntaxTree()) -&gt; syntaxTree()</name>
<fsummary>Limits a syntax tree to a specified depth.</fsummary>

<desc><marker id="limit-3"/>

<p>Limits a syntax tree to a specified depth. Replaces all non-leaf
  subtrees in <c>Tree</c> at the given <c>Depth</c> by
  <c>Node</c>. If <c>Depth</c> is negative, the result is
  always <c>Node</c>, even if <c>Tree</c> has no subtrees.</p>
 
  <p>When a group of subtrees (as e.g., the argument list of an
  <c>application</c> node) is at the specified depth, and there
  are two or more subtrees in the group, these will be collectively
  replaced by <c>Node</c> even if they are leaf nodes. Groups of
  subtrees that are above the specified depth will be limited in size,
  as if each subsequent tree in the group were one level deeper than
  the previous. E.g., if <c>Tree</c> represents a list of
  integers "<c>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</c>", the result
  of <c>limit(Tree, 5)</c> will represent <c>[1, 2, 3, 4,
  ...]</c>.</p>
 
  <p>The resulting syntax tree is typically only useful for
  pretty-printing or similar visual formatting.
 </p>
<p><em>See also:</em> <seealso marker="#limit-2">limit/2</seealso>.</p>
</desc></func></funcs>

<authors>

<aname>Richard Carlsson</aname>
<email>richardc@it.uu.se</email></authors></erlref>