<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="latin1" />
    <title>regexp (stdlib) - R14B01couch - erldocs.com (Erlang Documentation)</title>
    <link type="text/css" rel="stylesheet" href="../erldocs.css" />
  </head>
  
  <body>

    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off" 
             placeholder="press TAB to search" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
      <div style="margin:0px; padding:10px 20px;">
        
  
  <h1>regexp</h1>
  <h2 class="modsummary">Regular Expression Functions for Strings</h2>
  <div class="description">
    <div class="note"><h2>Note!</h2><p>This module has been obsoleted by the
    <a href="re.html" class="seealso">re</a> module and will be removed in a future
    release.</p></div>
    <p>This module contains functions for regular expression
      matching and substitution.</p>
  </div>
  <div class="functions"><h4>Functions</h4><hr  />
    <div class="function">
      <h3 id="match/2">match(String, RegExp) -&gt; MatchRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = string()</code></li>
        <li><code>MatchRes = {match,Start,Length} | nomatch | {error,errordesc()}</code></li>
        <li><code>Start = Length = integer()</code></li>
      </ul>
      <div class="description">
        <p>Finds the first, longest match of the regular expression <code>RegExp</code> in <code>String</code>. This function searches for the longest possible match and returns the first one found if there are several expressions of the same length. It returns as follows:</p>
        <dl>
          <dt><code>{match,Start,Length}</code></dt>
          <dd>
            <p>if the match succeeded. <code>Start</code> is the starting
              position of the match, and <code>Length</code> is the length of
              the matching string.</p>
          </dd>
          <dt><code>nomatch</code></dt>
          <dd>
            <p>if there were no matching characters.</p>
          </dd>
          <dt><code>{error,Error}</code></dt>
          <dd>
            <p>if there was an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="first_match/2">first_match(String, RegExp) -&gt; MatchRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = string()</code></li>
        <li><code>MatchRes = {match,Start,Length} | nomatch | {error,errordesc()}</code></li>
        <li><code>Start = Length = integer()</code></li>
      </ul>
      <div class="description">
        <p>Finds the first match of the regular expression <code>RegExp</code> in <code>String</code>. This call is
          usually faster than <code>match</code> and it is also a useful way to ascertain that a match exists. It returns as follows:</p>
        <dl>
          <dt><code>{match,Start,Length}</code></dt>
          <dd>
            <p>if the match succeeded. <code>Start</code> is the starting
              position of the match and <code>Length</code> is the length of
              the matching string.</p>
          </dd>
          <dt><code>nomatch</code></dt>
          <dd>
            <p>if there were no matching characters.</p>
          </dd>
          <dt><code>{error,Error}</code></dt>
          <dd>
            <p>if there was an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="matches/2">matches(String, RegExp) -&gt; MatchRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = string()</code></li>
        <li><code>MatchRes = {match, Matches} | {error, errordesc()}</code></li>
        <li><code>Matches = list()</code></li>
      </ul>
      <div class="description">
        <p>Finds all non-overlapping matches of the
          expression <code>RegExp</code> in <code>String</code>.
          It returns as follows:</p>
        <dl>
          <dt><code>{match, Matches}</code></dt>
          <dd>
            <p>if the regular expression was correct.
              The list will be empty if there was no match. Each element in the list looks like <code>{Start, Length}</code>, where <code>Start</code> is the starting position of the match, and <code>Length</code> is the length of the matching string.</p>
          </dd>
          <dt><code>{error,Error}</code></dt>
          <dd>
            <p>if there was an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="sub/3">sub(String, RegExp, New) -&gt; SubRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = New = string()</code></li>
        <li><code>SubRes = {ok,NewString,RepCount} | {error,errordesc()}</code></li>
        <li><code>RepCount = integer()</code></li>
      </ul>
      <div class="description">
        <p>Substitutes the first occurrence of a substring matching <code>RegExp</code> in <code>String</code> with the string <code>New</code>. A <code>&</code> in the string <code>New</code> is replaced by the matched substring of <code>String</code>.  <code>\&</code> puts a literal <code>&</code> into the replacement string. It returns as follows:</p>
        <dl>
          <dt><code>{ok,NewString,RepCount}</code></dt>
          <dd>
            <p>if <code>RegExp</code> is correct. <code>RepCount</code> is the number of replacements which have been made
              (this will be either 0 or 1).</p>
          </dd>
          <dt><code>{error, Error}</code></dt>
          <dd>
            <p>if there is an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="gsub/3">gsub(String, RegExp, New) -&gt; SubRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = New = string()</code></li>
        <li><code>SubRes = {ok,NewString,RepCount} | {error,errordesc()}</code></li>
        <li><code>RepCount = integer()</code></li>
      </ul>
      <div class="description">
        <p>The same as <code>sub</code>, except that all non-overlapping
          occurrences of a substring matching
          <code>RegExp</code> in <code>String</code> are replaced by the string <code>New</code>. It returns:</p>
        <dl>
          <dt><code>{ok,NewString,RepCount}</code></dt>
          <dd>
            <p>if <code>RegExp</code> is correct. <code>RepCount</code> is the number of replacements which have been made.</p>
          </dd>
          <dt><code>{error, Error}</code></dt>
          <dd>
            <p>if there is an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="split/2">split(String, RegExp) -&gt; SplitRes</h3>
      
      <ul class="type">
        <li><code>String = RegExp = string()</code></li>
        <li><code>SubRes = {ok,FieldList} | {error,errordesc()}</code></li>
        <li><code>Fieldlist = [string()]</code></li>
      </ul>
      <div class="description">
        <p><code>String</code> is split into fields (sub-strings) by the
          regular expression <code>RegExp</code>.</p>
        <p>If the separator expression is <code>" "</code> (a single space),
          then the fields are separated by blanks and/or tabs and
          leading and trailing blanks and tabs are discarded. For all
          other values of the separator, leading and trailing blanks
          and tabs are not discarded. It returns:</p>
        <dl>
          <dt><code>{ok, FieldList}</code></dt>
          <dd>
            <p>to indicate that the string has been split up into the fields of
              <code>FieldList</code>.</p>
          </dd>
          <dt><code>{error, Error}</code></dt>
          <dd>
            <p>if there is an error in <code>RegExp</code>.</p>
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="sh_to_awk/1">sh_to_awk(ShRegExp) -&gt; AwkRegExp</h3>
      
      <ul class="type">
        <li><code>ShRegExp AwkRegExp = string()</code></li>
        <li><code>SubRes = {ok,NewString,RepCount} | {error,errordesc()}</code></li>
        <li><code>RepCount = integer()</code></li>
      </ul>
      <div class="description">
        <p>Converts the <code>sh</code> type regular expression
          <code>ShRegExp</code> into a full <code>AWK</code> regular
          expression. Returns the converted regular expression
          string. <code>sh</code> expressions are used in the shell for
          matching file names and have the following special
          characters:</p>
        <dl>
          <dt><code>*</code></dt>
          <dd>
            <p>matches any string including the null string.</p>
          </dd>
          <dt><code>?</code></dt>
          <dd>
            <p>matches any single character.</p>
          </dd>
          <dt><code>[...]</code></dt>
          <dd>
            <p>matches any of the enclosed characters. Character
              ranges are specified by a pair of characters separated
              by a <code>-</code>. If the first character after <code>[</code> is a
              <code>!</code>, then any character not enclosed is matched.</p>
          </dd>
        </dl>
        <p>It may sometimes be more practical to use <code>sh</code> type
          expansions as they are simpler and easier to use, even though they are not as powerful.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="parse/1">parse(RegExp) -&gt; ParseRes</h3>
      
      <ul class="type">
        <li><code>RegExp = string()</code></li>
        <li><code>ParseRes = {ok,RE} | {error,errordesc()}</code></li>
      </ul>
      <div class="description">
        <p>Parses the regular expression <code>RegExp</code> and builds the
          internal representation used in the other regular expression
          functions. Such representations can be used in all of the
          other functions instead of a regular expression string. This
          is more efficient when the same regular expression is used
          in many strings. It returns:</p>
        <dl>
          <dt><code>{ok, RE}</code>if <code>RegExp</code>is correct and <code>RE</code>is the internal representation.</dt>
          <dd>
            <p  />
          </dd>
          <dt><code>{error, Error}</code>if there is an error in <code>RegExpString</code>.</dt>
          <dd>
            <p  />
          </dd>
        </dl>
      </div>
    </div>
    <div class="function">
      <h3 id="format_error/1">format_error(ErrorDescriptor) -&gt; Chars</h3>
      
      <ul class="type">
        <li><code>ErrorDescriptor = errordesc()</code></li>
        <li><code>Chars = [char() | Chars]</code></li>
      </ul>
      <div class="description">
        <p>Returns a string which describes the error <code>ErrorDescriptor</code>
          returned when there is an error in a regular expression.</p>
      </div>
    </div>
  </div>

  <div class="section">
    <h4>Regular Expressions</h4>
    <p>The regular expressions allowed here is a subset of the set found
      in <code>egrep</code> and in the <code>AWK</code> programming language, as
      defined in the book, <code>The AWK Programming Language, by A. V. Aho, B. W. Kernighan, P. J. Weinberger</code>. They are
      composed of the following characters:</p>
    <dl>
      <dt>c</dt>
      <dd>
        <p>matches the non-metacharacter <code>c</code>.</p>
      </dd>
      <dt>\c</dt>
      <dd>
        <p>matches the escape sequence or literal character <code>c</code>.</p>
      </dd>
      <dt>.</dt>
      <dd>
        <p>matches any character.</p>
      </dd>
      <dt>^</dt>
      <dd>
        <p>matches the beginning of a string.</p>
      </dd>
      <dt>$</dt>
      <dd>
        <p>matches the end of a string.</p>
      </dd>
      <dt>[abc...]</dt>
      <dd>
        <p>character class, which matches any of the characters
          <code>abc...</code> Character ranges are specified by a pair of
          characters separated by a <code>-</code>.</p>
      </dd>
      <dt>[^abc...]</dt>
      <dd>
        <p>negated character class, which matches any character except
          <code>abc...</code>.</p>
      </dd>
      <dt>r1 | r2</dt>
      <dd>
        <p>alternation. It matches either <code>r1</code> or <code>r2</code>.</p>
      </dd>
      <dt>r1r2</dt>
      <dd>
        <p>concatenation. It matches <code>r1</code> and then <code>r2</code>.</p>
      </dd>
      <dt>r+</dt>
      <dd>
        <p>matches one or more <code>r</code>s.</p>
      </dd>
      <dt>r*</dt>
      <dd>
        <p>matches zero or more <code>r</code>s.</p>
      </dd>
      <dt>r?</dt>
      <dd>
        <p>matches zero or one <code>r</code>s.</p>
      </dd>
      <dt>(r)</dt>
      <dd>
        <p>grouping. It matches <code>r</code>.</p>
      </dd>
    </dl>
    <p>The escape sequences allowed are the same as for Erlang
      strings:</p>
    <dl>
      <dt><code>\b</code></dt>
      <dd>
        <p>backspace</p>
      </dd>
      <dt><code>\f</code></dt>
      <dd>
        <p>form feed </p>
      </dd>
      <dt><code>\n</code></dt>
      <dd>
        <p>newline (line feed) </p>
      </dd>
      <dt><code>\r</code></dt>
      <dd>
        <p>carriage return </p>
      </dd>
      <dt><code>\t</code></dt>
      <dd>
        <p>tab </p>
      </dd>
      <dt><code>\e</code></dt>
      <dd>
        <p>escape </p>
      </dd>
      <dt><code>\v</code></dt>
      <dd>
        <p>vertical tab </p>
      </dd>
      <dt><code>\s</code></dt>
      <dd>
        <p>space </p>
      </dd>
      <dt><code>\d</code></dt>
      <dd>
        <p>delete </p>
      </dd>
      <dt><code>\ddd</code></dt>
      <dd>
        <p>the octal value ddd </p>
      </dd>
      <dt><code>\xhh</code></dt>
      <dd>
        <p>The hexadecimal value <code>hh</code>.</p>
      </dd>
      <dt><code>\x{h...}</code></dt>
      <dd>
        <p>The hexadecimal value <code>h...</code>.</p>
      </dd>
      <dt><code>\c</code></dt>
      <dd>
        <p>any other character literally, for example <code>\\</code> for backslash,
          <code>\"</code> for ")</p>
      </dd>
    </dl>
    <p>To make these functions easier to use, in combination with the
      function <code>io:get_line</code> which terminates the input line with
      a new line, the <code>$</code> characters also matches a string ending
      with <code>"...\n"</code>. The following examples
      define Erlang data types:</p>
    <pre class="sh_erlang">
Atoms     [a-z][0-9a-zA-Z_]*

Variables [A-Z_][0-9a-zA-Z_]*

Floats    (\+|-)?[0-9]+\.[0-9]+((E|e)(\+|-)?[0-9]+)?</pre>
    <p>Regular expressions are written as Erlang strings when used with the functions in this module. This means that any <code>\</code> or <code>"</code> characters in a regular expression
      string must be written with <code>\</code> as they are also escape characters for the string. For example, the regular expression string for Erlang floats is:
      <code>"(\\+|-)?[0-9]+\\.[0-9]+((E|e)(\\+|-)?[0-9]+)?"</code>.</p>
    <p>It is not really necessary to have the escape sequences as part of the regular expression syntax as they can always be generated directly in the string. They are included for completeness and can they can also be useful when generating regular expressions, or when they are entered other than with Erlang strings.</p>
  </div>

      </div>
      <div id="funwrapper">
        <a id="viewfuns">View Functions</a>
        <ul id="funs"><li><a href="#match/2">match/2</a></li><li><a href="#first_match/2">first_match/2</a></li><li><a href="#matches/2">matches/2</a></li><li><a href="#sub/3">sub/3</a></li><li><a href="#gsub/3">gsub/3</a></li><li><a href="#split/2">split/2</a></li><li><a href="#sh_to_awk/1">sh_to_awk/1</a></li><li><a href="#parse/1">parse/1</a></li><li><a href="#format_error/1">format_error/1</a></li></ul>
      </div>
    </div>

    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>

    <script type="text/javascript" src="../jquery.js"></script>
    <script type="text/javascript" src="../erldocs_index.js"></script>
    <script type="text/javascript" src="../erldocs.js"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-44246018-1']);
      _gaq.push(['_trackPageview']);
      
      (function() {
        var ga = document.createElement('script');
        ga.src = ('https:' == document.location.protocol ?
          'https://ssl' : 'http://www') +
          '.google-analytics.com/ga.js';
        ga.setAttribute('async', 'true');
        document.documentElement.firstChild.appendChild(ga);
      })();
    </script>
  </body>
</html>

