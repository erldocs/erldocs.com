<module name="re">
<type>
  <name>compile_option</name>
  <n_vars>0</n_vars>
  <typedecl>
      <typehead><marker id="type-compile_option">compile_option()</marker> = unicode<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| anchored<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| caseless<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| dollar_endonly<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| dotall<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| extended<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| firstline<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| multiline<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| no_auto_capture<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| dupnames<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| ungreedy<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {newline, <seealso marker="#type-nl_spec">nl_spec()</seealso>}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_anycrlf<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_unicode<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| no_start_optimize<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| ucp<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| never_utf</typehead></typedecl>
</type>
<type>
  <name>mp</name>
  <n_vars>0</n_vars>
  <typedecl>
      <typehead><marker id="type-mp">mp()</marker> = {re_pattern, term(), term(), term(), term()}</typehead></typedecl>
</type>
<type>
  <name>nl_spec</name>
  <n_vars>0</n_vars>
  <typedecl>
      <typehead><marker id="type-nl_spec">nl_spec()</marker> = cr | crlf | lf | anycrlf | any</typehead></typedecl>
</type>
<spec>
  <name>compile</name>
  <arity>1</arity>
  <contract>
    <clause>
      <head>compile(Regexp) -&gt; {ok, MP} | {error, ErrSpec}</head>
      <guard>
        <subtype><typename>Regexp</typename><string>Regexp = iodata()</string></subtype>
        <subtype><typename>MP</typename><string>MP = <seealso marker="#type-mp">mp()</seealso></string></subtype>
        <subtype><typename>ErrSpec</typename><string>ErrSpec = <br/><nbsp/><nbsp/><nbsp/><nbsp/>{ErrString :: string(), Position :: integer() &gt;= 0}</string></subtype>
      </guard></clause>
  </contract>
  <anno>ErrSpec</anno>
  <anno>ErrString</anno>
  <anno>MP</anno>
  <anno>Position</anno>
  <anno>Regexp</anno>
</spec>
<spec>
  <name>compile</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>compile(Regexp, Options) -&gt; {ok, MP} | {error, ErrSpec}</head>
      <guard>
        <subtype><typename>Regexp</typename><string>Regexp = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>Options</typename><string>Options = [Option]</string></subtype>
        <subtype><typename>Option</typename><string>Option = <seealso marker="#type-compile_option">compile_option()</seealso></string></subtype>
        <subtype><typename>MP</typename><string>MP = <seealso marker="#type-mp">mp()</seealso></string></subtype>
        <subtype><typename>ErrSpec</typename><string>ErrSpec = <br/><nbsp/><nbsp/><nbsp/><nbsp/>{ErrString :: string(), Position :: integer() &gt;= 0}</string></subtype>
      </guard></clause>
  </contract>
  <anno>ErrSpec</anno>
  <anno>ErrString</anno>
  <anno>MP</anno>
  <anno>Option</anno>
  <anno>Options</anno>
  <anno>Position</anno>
  <anno>Regexp</anno>
</spec>
<spec>
  <name>grun</name>
  <arity>3</arity>
  <contract/>
</spec>
<spec>
  <name>inspect</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>inspect(MP, Item) -&gt; {namelist, [binary()]}</head>
      <guard>
        <subtype><typename>MP</typename><string>MP = <seealso marker="#type-mp">mp()</seealso></string></subtype>
        <subtype><typename>Item</typename><string>Item = namelist</string></subtype>
      </guard></clause>
  </contract>
  <anno>Item</anno>
  <anno>MP</anno>
</spec>
<spec>
  <name>replace</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>replace(Subject, RE, Replacement) -&gt; iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata()</string></subtype>
        <subtype><typename>Replacement</typename><string>Replacement = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
      </guard></clause>
  </contract>
  <anno>RE</anno>
  <anno>Replacement</anno>
  <anno>Subject</anno>
</spec>
<spec>
  <name>replace</name>
  <arity>4</arity>
  <contract>
    <clause>
      <head>replace(Subject, RE, Replacement, Options) -&gt;<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>Replacement</typename><string>Replacement = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>Options</typename><string>Options = [Option]</string></subtype>
        <subtype><typename>Option</typename><string>Option = anchored<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| global<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notbol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| noteol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty_atstart<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {offset, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {newline, NLSpec}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_anycrlf<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit_recursion, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_unicode<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {return, ReturnType}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| CompileOpt</string></subtype>
        <subtype><typename>ReturnType</typename><string>ReturnType = iodata | list | binary</string></subtype>
        <subtype><typename>CompileOpt</typename><string>CompileOpt = <seealso marker="#type-compile_option">compile_option()</seealso></string></subtype>
        <subtype><typename>NLSpec</typename><string>NLSpec = cr | crlf | lf | anycrlf | any</string></subtype>
      </guard></clause>
  </contract>
  <anno>CompileOpt</anno>
  <anno>NLSpec</anno>
  <anno>Option</anno>
  <anno>Options</anno>
  <anno>RE</anno>
  <anno>Replacement</anno>
  <anno>ReturnType</anno>
  <anno>Subject</anno>
</spec>
<spec>
  <name>run</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>run(Subject, RE) -&gt; {match, Captured} | nomatch</head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata()</string></subtype>
        <subtype><typename>Captured</typename><string>Captured = [CaptureData]</string></subtype>
        <subtype><typename>CaptureData</typename><string>CaptureData = {integer(), integer()}</string></subtype>
      </guard></clause>
  </contract>
  <anno>CaptureData</anno>
  <anno>Captured</anno>
  <anno>RE</anno>
  <anno>Subject</anno>
</spec>
<spec>
  <name>run</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>run(Subject, RE, Options) -&gt;<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>{match, Captured} | match | nomatch | {error, ErrType}</head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>Options</typename><string>Options = [Option]</string></subtype>
        <subtype><typename>Option</typename><string>Option = anchored<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| global<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notbol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| noteol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty_atstart<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| report_errors<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {offset, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit_recursion, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {newline, NLSpec :: <seealso marker="#type-nl_spec">nl_spec()</seealso>}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_anycrlf<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_unicode<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {capture, ValueSpec}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {capture, ValueSpec, Type}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| CompileOpt</string></subtype>
        <subtype><typename>Type</typename><string>Type = index | list | binary</string></subtype>
        <subtype><typename>ValueSpec</typename><string>ValueSpec = all<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| all_but_first<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| all_names<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| first<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| none<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| ValueList</string></subtype>
        <subtype><typename>ValueList</typename><string>ValueList = [ValueID]</string></subtype>
        <subtype><typename>ValueID</typename><string>ValueID = integer() | string() | atom()</string></subtype>
        <subtype><typename>CompileOpt</typename><string>CompileOpt = <seealso marker="#type-compile_option">compile_option()</seealso></string></subtype>
        <subtype><typename>Captured</typename><string>Captured = [CaptureData] | [[CaptureData]]</string></subtype>
        <subtype><typename>CaptureData</typename><string>CaptureData = {integer(), integer()}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| ListConversionData<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| binary()</string></subtype>
        <subtype><typename>ListConversionData</typename><string>ListConversionData = string()<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {error, string(), binary()}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {incomplete, string(), binary()}</string></subtype>
        <subtype><typename>ErrType</typename><string>ErrType = match_limit<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| match_limit_recursion<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {compile, CompileErr}</string></subtype>
        <subtype><typename>CompileErr</typename><string>CompileErr = <br/><nbsp/><nbsp/><nbsp/><nbsp/>{ErrString :: string(), Position :: integer() &gt;= 0}</string></subtype>
      </guard></clause>
  </contract>
  <anno>CaptureData</anno>
  <anno>Captured</anno>
  <anno>CompileErr</anno>
  <anno>CompileOpt</anno>
  <anno>ErrString</anno>
  <anno>ErrType</anno>
  <anno>ListConversionData</anno>
  <anno>NLSpec</anno>
  <anno>Option</anno>
  <anno>Options</anno>
  <anno>Position</anno>
  <anno>RE</anno>
  <anno>Subject</anno>
  <anno>Type</anno>
  <anno>ValueID</anno>
  <anno>ValueList</anno>
  <anno>ValueSpec</anno>
</spec>
<spec>
  <name>split</name>
  <arity>2</arity>
  <contract>
    <clause>
      <head>split(Subject, RE) -&gt; SplitList</head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata()</string></subtype>
        <subtype><typename>SplitList</typename><string>SplitList = [iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso>]</string></subtype>
      </guard></clause>
  </contract>
  <anno>RE</anno>
  <anno>SplitList</anno>
  <anno>Subject</anno>
</spec>
<spec>
  <name>split</name>
  <arity>3</arity>
  <contract>
    <clause>
      <head>split(Subject, RE, Options) -&gt; SplitList</head>
      <guard>
        <subtype><typename>Subject</typename><string>Subject = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>RE</typename><string>RE = <seealso marker="#type-mp">mp()</seealso> | iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso></string></subtype>
        <subtype><typename>Options</typename><string>Options = [Option]</string></subtype>
        <subtype><typename>Option</typename><string>Option = anchored<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notbol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| noteol<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| notempty_atstart<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {offset, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {newline, <seealso marker="#type-nl_spec">nl_spec()</seealso>}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {match_limit_recursion, integer() &gt;= 0}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_anycrlf<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| bsr_unicode<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {return, ReturnType}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| {parts, NumParts}<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| group<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| trim<br/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/><nbsp/>| CompileOpt</string></subtype>
        <subtype><typename>NumParts</typename><string>NumParts = integer() &gt;= 0 | infinity</string></subtype>
        <subtype><typename>ReturnType</typename><string>ReturnType = iodata | list | binary</string></subtype>
        <subtype><typename>CompileOpt</typename><string>CompileOpt = <seealso marker="#type-compile_option">compile_option()</seealso></string></subtype>
        <subtype><typename>SplitList</typename><string>SplitList = [RetData] | [GroupedRetData]</string></subtype>
        <subtype><typename>GroupedRetData</typename><string>GroupedRetData = [RetData]</string></subtype>
        <subtype><typename>RetData</typename><string>RetData = iodata() | <seealso marker="unicode#type-charlist">unicode:charlist()</seealso> | binary() | list()</string></subtype>
      </guard></clause>
  </contract>
  <anno>CompileOpt</anno>
  <anno>GroupedRetData</anno>
  <anno>NumParts</anno>
  <anno>Option</anno>
  <anno>Options</anno>
  <anno>RE</anno>
  <anno>RetData</anno>
  <anno>ReturnType</anno>
  <anno>SplitList</anno>
  <anno>Subject</anno>
</spec>
<spec>
  <name>ucompile</name>
  <arity>2</arity>
  <contract/>
</spec>
<spec>
  <name>urun</name>
  <arity>3</arity>
  <contract/>
</spec>
<timestamp>Generated by EDoc, May 6 2014, 16:26:12.</timestamp>
</module>